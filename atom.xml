<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yu的炼金工房</title>
  
  
  <link href="https://atelieryu.site/atom.xml" rel="self"/>
  
  <link href="https://atelieryu.site/"/>
  <updated>2025-03-29T10:01:00.000Z</updated>
  <id>https://atelieryu.site/</id>
  
  <author>
    <name>Yu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++高性能服务器框架Sylar（一）——日志模块</title>
    <link href="https://atelieryu.site/posts/9da02ca5.html"/>
    <id>https://atelieryu.site/posts/9da02ca5.html</id>
    <published>2025-03-29T07:12:00.000Z</published>
    <updated>2025-03-29T10:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h1><p>模仿log4j日志框架实现一个的日志模块</p><ul><li>难点：Logformatter的init()，将一个字符串解析为模板</li><li>设计点：<ul><li><strong>LogEventWrap</strong>：一个封装LogEvent和Logger的<strong>RAII类</strong></li><li><strong>LoggerManager</strong>：一个管理Logger的<strong>单例类</strong></li><li><strong>LogAppender</strong>：一个<strong>抽象基类</strong>，可以方便地扩展日志的输出地</li><li><strong>一系列辅助函数</strong>：<ul><li>优化用户使用方式，用户可使用<strong>流式方式或格式化方式</strong>进行日志内容的写入</li><li>包括一系列宏函数和inline，辅助函数创建LogEventWrap来实现日志的输出</li></ul></li></ul></li></ul><h1 id="模块UML类图"><a href="#模块UML类图" class="headerlink" title="模块UML类图"></a>模块UML类图</h1><p><img src="https://atelieryu.xyz/elog/202503/49d699bf874ff79e3f2cf7a2245d2330.png" alt="日志模块类图"></p><h2 id="Logger：日志器"><a href="#Logger：日志器" class="headerlink" title="Logger：日志器"></a>Logger：日志器</h2><ul><li>负责进行日志输出</li><li>一个日志器可指定一个日志级别（LogLevel）和多个日志输出地（LogAppender）</li><li>提供log方法，传入日志事件，如果该日志事件的级别高于日志器本身的级别则将其输出，否则将该日志抛弃。</li></ul><h2 id="LogAppender：日志输出器"><a href="#LogAppender：日志输出器" class="headerlink" title="LogAppender：日志输出器"></a>LogAppender：日志输出器</h2><ul><li>用于将一个日志事件输出到对应的输出地。</li><li>类内部包含一个日志格式器（LogFormatter）成员和一个log方法，日志事件经过格式化后输出到对应的输出地。</li><li>由于有多种输出地，所以该类成为一个<strong>抽象基类</strong>，其派生类必须重写它的log方法<ul><li>比如StdoutLogAppender和FileLogAppender为LogAppender的派生类，分别表示输出到终端和文件。</li></ul></li></ul><h2 id="LogFormatter：日志格式器"><a href="#LogFormatter：日志格式器" class="headerlink" title="LogFormatter：日志格式器"></a>LogFormatter：日志格式器</h2><ul><li>与log4cpp的PatternLayout对应，用于格式化一个日志事件（输出log4j日志格式）。</li><li>该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。<ul><li>pattern中每个模板参数或字符串对应一个FormatItem派生类</li></ul></li></ul><h2 id="LogEvent：日志事件"><a href="#LogEvent：日志事件" class="headerlink" title="LogEvent：日志事件"></a>LogEvent：日志事件</h2><ul><li>用于记录日志现场，比如该日志的级别，文件名/行号，日志消息，线程/协程号，所属日志器名称等。</li><li>可以理解为一个日志事件对应一条日志</li></ul><h2 id="LogEventWrap：日志事件包装类"><a href="#LogEventWrap：日志事件包装类" class="headerlink" title="LogEventWrap：日志事件包装类"></a>LogEventWrap：日志事件包装类</h2><ul><li>LogEventWrap是一个<strong>RAII类</strong><ul><li>LogEventWrap在构造时指定日志事件和日志器</li><li>在析构时调用日志器的log方法将日志事件进行输出</li></ul></li><li>LogEventWrap将日志事件和日志器包装到一起<ul><li>一条日志只会在一个日志器上进行输出</li><li>将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。</li></ul></li><li>为什么需要LogEventWrap？<ul><li>由于LogEvent::ptr是智能指针，所以如果直接创建LogEvent::ptr，智能指针将在主函数结束时才释放。</li><li>LogEventWrap的getSS()方法支持以流式方式将日志写入logger</li><li>使用RAII类管理LogEvent，可以<strong>在LogEventWrap析构时自动提交日志事件，并将其释放</strong></li></ul></li></ul><h2 id="LogManager：日志器管理类"><a href="#LogManager：日志器管理类" class="headerlink" title="LogManager：日志器管理类"></a>LogManager：日志器管理类</h2><ul><li><strong>单例模式</strong>，用于统一管理所有的日志器，提供日志器的创建与获取方法<ul><li><strong>LogManager应成为创建Logger的唯一方式，所有的Logger都应该经由LogManager获取</strong></li><li>通过singleton.h中定义的单例类GetInstance方法返回LoggerManager的单例对象</li></ul></li><li>getRoot方法：LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。</li><li>getLogger方法：根据一个名字搜索容器中已有的logger或新建一个logger</li></ul><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p><code>~LogEventWrap()</code> → <code>Logger::log()</code> → <code>LogAppender::log()</code> → <code>LogFormatter::format()</code></p><h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="LogLevel"><a href="#LogLevel" class="headerlink" title="LogLevel"></a>LogLevel</h2><blockquote><p>LogLevel表示日志级别</p><ul><li>类中定义了7种日志级别，实现了日志的分级输出</li><li>提供了<code>ToString</code>和<code>FromString</code>两个静态方法，支持将日志级别名称转换为字符串，或将字符串转换为日志级别<ul><li><code>FromString</code>对输入字符串的大小写不敏感</li></ul></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogLevel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Level</span>&#123;</span><br><span class="line">        UNKNOW = <span class="number">0</span>,     <span class="comment">// 未知级别</span></span><br><span class="line">        DEBUG = <span class="number">1</span>,      <span class="comment">// DEBUG级别</span></span><br><span class="line">        INFO = <span class="number">2</span>,       <span class="comment">// INFO级别</span></span><br><span class="line">        WARN = <span class="number">3</span>,       <span class="comment">// WARN级别</span></span><br><span class="line">        ERROR = <span class="number">4</span>,      <span class="comment">// ERROR级别</span></span><br><span class="line">        FATAL = <span class="number">5</span>,      <span class="comment">// FATAL级别</span></span><br><span class="line">        NOTSET = <span class="number">100</span>    <span class="comment">// NOSET级别，表示不可访问</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ToString</span><span class="params">(Level level)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Level <span class="title">FromString</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过宏函数简化了<code>ToString</code>和<code>FromString</code>的书写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">LogLevel::ToString</span><span class="params">(Level level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (level)&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XX(name) case LogLevel::name: return #name;</span></span><br><span class="line">        <span class="built_in">XX</span>(DEBUG);</span><br><span class="line">        <span class="built_in">XX</span>(INFO);</span><br><span class="line">        <span class="built_in">XX</span>(WARN);</span><br><span class="line">        <span class="built_in">XX</span>(ERROR);</span><br><span class="line">        <span class="built_in">XX</span>(FATAL);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XX</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UNKNOW&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LogLevel::Level <span class="title">LogLevel::FromString</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">strlower</span><span class="params">(str.size(), <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), strlower.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XX(level, v) <span class="keyword">if</span>(strlower == #v)&#123; return LogLevel::level; &#125;</span></span><br><span class="line">    <span class="built_in">XX</span>(DEBUG, debug);</span><br><span class="line">    <span class="built_in">XX</span>(INFO, info);</span><br><span class="line">    <span class="built_in">XX</span>(WARN, warn);</span><br><span class="line">    <span class="built_in">XX</span>(ERROR, error);</span><br><span class="line">    <span class="built_in">XX</span>(FATAL, fatal);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XX</span></span><br><span class="line">    <span class="keyword">return</span> UNKNOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogEvent"><a href="#LogEvent" class="headerlink" title="LogEvent"></a>LogEvent</h2><blockquote><p>LogEvent用于记录日志现场</p></blockquote><p>一个日志事件具体包括以下内容：</p><ul><li>日志内容</li><li>日志器名称</li><li>日志级别</li><li>文件名，对应<strong>FILE</strong>宏</li><li>行号，对应<strong>LINE</strong>宏</li><li>程序运行时间，通过sylar::GetElapsedMS()获取</li><li>线程ID</li><li>协程ID</li><li>UTC时间戳，对应time(0)</li><li>线程名称</li></ul><p>LogEvent提供了<code>format</code>方法，将以上信息格式化写入日志内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志事件，用于记录日志现场</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogEvent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogEvent&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogEvent</span>(std::string loggerName, LogLevel::Level level, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int32_t</span> line</span><br><span class="line">        , <span class="type">int64_t</span> elapse, <span class="type">uint32_t</span> thread_id, <span class="type">uint64_t</span> fiber_id, <span class="type">time_t</span> time</span><br><span class="line">        , <span class="type">const</span> std::string &amp;thread_name);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getFile</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_file; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">getLine</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_line; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getElapse</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_elapse; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getThreadId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_threadId; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getFiberId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_fiberId; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getThreadName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_threadName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ss.<span class="built_in">str</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::stringstream&amp; <span class="title">getSS</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ss; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getLoggerName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_loggerName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LogLevel::Level <span class="title">getLevel</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_level; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以格式化方式将内容写入m_ss</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, Args&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取格式化字符串的长度</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">snprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, fmt, args...);</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用snprintf，将格式化字符串写入缓冲区</span></span><br><span class="line">            <span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, len + <span class="number">1</span>, fmt, args...);</span><br><span class="line">            m_ss &lt;&lt; std::<span class="built_in">string</span>(buf, len);</span><br><span class="line">            <span class="keyword">delete</span>[] buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_loggerName;           <span class="comment">// 日志器</span></span><br><span class="line">    LogLevel::Level m_level;            <span class="comment">// 日志级别</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_file = <span class="literal">nullptr</span>;       <span class="comment">// 文件名</span></span><br><span class="line">    <span class="type">int32_t</span> m_line = <span class="number">0</span>;                 <span class="comment">// 行号</span></span><br><span class="line">    <span class="type">uint32_t</span> m_elapse = <span class="number">0</span>;              <span class="comment">// 程序启动到现在的毫秒数</span></span><br><span class="line">    <span class="type">uint32_t</span> m_threadId = <span class="number">0</span>;            <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="type">uint32_t</span> m_fiberId = <span class="number">0</span>;             <span class="comment">// 协程ID</span></span><br><span class="line">    <span class="type">uint64_t</span> m_time = <span class="number">0</span>;                <span class="comment">// 时间戳</span></span><br><span class="line">    std::string m_threadName;           <span class="comment">// 线程名称</span></span><br><span class="line">    std::stringstream m_ss;             <span class="comment">// 日志内容流</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line">LogEvent::<span class="built_in">LogEvent</span>(std::string loggerName, LogLevel::Level level, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int32_t</span> line</span><br><span class="line">        , <span class="type">int64_t</span> elapse, <span class="type">uint32_t</span> thread_id, <span class="type">uint64_t</span> fiber_id, <span class="type">time_t</span> time</span><br><span class="line">        , <span class="type">const</span> std::string &amp;thread_name)</span><br><span class="line">    : <span class="built_in">m_loggerName</span>(loggerName) </span><br><span class="line">    , <span class="built_in">m_level</span>(level)</span><br><span class="line">    , <span class="built_in">m_file</span>(file)</span><br><span class="line">    , <span class="built_in">m_line</span>(line)</span><br><span class="line">    , <span class="built_in">m_elapse</span>(elapse)</span><br><span class="line">    , <span class="built_in">m_threadId</span>(thread_id)</span><br><span class="line">    , <span class="built_in">m_fiberId</span>(fiber_id)</span><br><span class="line">    , <span class="built_in">m_time</span>(time)</span><br><span class="line">    , <span class="built_in">m_threadName</span>(thread_name) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogFormatter"><a href="#LogFormatter" class="headerlink" title="LogFormatter"></a>LogFormatter</h2><blockquote><p>LogFormatter用于将日志事件LogEvent格式化（模仿log4j日志框架）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志格式器，将日志事件格式化为字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogFormatter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogFormatter&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogFormatter</span>(<span class="type">const</span> std::string&amp; pattern = <span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ostream&amp; <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isError</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_error; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getPattern</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_pattern; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 抽象基类FormatItem，用于格式化某一项日志内容</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FormatItem</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FormatItem&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">FormatItem</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_pattern;</span><br><span class="line">    std::vector&lt;FormatItem::ptr&gt; m_items;</span><br><span class="line">    <span class="type">bool</span> m_error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h3><p>由于一个日志事件包括了很多的内容（参考LogEvent），但实际上用户并不希望每次输出日志时都将这些信息全部进行输出，而是希望可以自由地选择要输出的信息。并且，用户还可能需要在每条日志里增加一些指定的字符，比如在文件名和行号之间加上一个冒号的情况。</p><p>为了实现这项功能，LogFormatter使用了一个模板字符串来指定格式化的方式。模板字符串由普通字符和转义字符构成，<strong>转义字符以%开头</strong>，比如%m，%p等。除了转义字符，剩下的全部都是普通字符，包括空格，当前支持以下转义字符：</p><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%m 消息</span><br><span class="line">%p 日志级别</span><br><span class="line">%r 累计毫秒数</span><br><span class="line">%c 日志名称</span><br><span class="line">%t 线程id</span><br><span class="line">%n 换行</span><br><span class="line">%d 时间</span><br><span class="line">%f 文件名</span><br><span class="line">%l 行号</span><br><span class="line">%T 制表符</span><br><span class="line">%F 协程id</span><br><span class="line">%N 线程名称</span><br></pre></td></tr></table></figure><blockquote><p>默认格式</p><ul><li>默认格式： <code>&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n&quot;</code></li><li>描述：年-月-日 时:分:秒 [累计运行毫秒数] \t 线程id \t 线程名称 \t 协程id \t [日志级别] \t [日志器名称] \t 文件名:行号 \t 日志消息 换行符</li></ul></blockquote><h3 id="嵌套类FormatItem"><a href="#嵌套类FormatItem" class="headerlink" title="嵌套类FormatItem"></a>嵌套类FormatItem</h3><ul><li>FormatItem：日志内容格式化项，一个抽象基类，每个格式模板参数实现一个FormatItem的派生类<ul><li><code>void format(std::ostream os, LogEvent::ptr event)</code>：将event中对应模板参数的内容格式化后写入os</li></ul></li><li><p>具体的派生类如下：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// %m</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MessageFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getContent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %p</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LevelFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LevelFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; LogLevel::<span class="built_in">ToString</span>(event-&gt;<span class="built_in">getLevel</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %c</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggerNameFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoggerNameFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getLoggerName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %d</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateTimeFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DateTimeFormatItem</span>(<span class="type">const</span> std::string&amp; format = <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">    : <span class="built_in">m_format</span>(format)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_format.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            m_format = <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;    </span><br><span class="line">        <span class="type">time_t</span> time = event-&gt;<span class="built_in">getTime</span>();</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* tm = <span class="built_in">localtime</span>(&amp;time);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strftime</span>(buf, <span class="built_in">sizeof</span>(buf), m_format.<span class="built_in">c_str</span>(), tm);</span><br><span class="line">        os &lt;&lt; buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_format;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %r</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElapseFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ElapseFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getElapse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %f</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FilenameFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FilenameFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getFile</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %l</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LineFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getLine</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %t</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadIdFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadIdFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getThreadId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %f</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FiberIdFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FiberIdFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getFiberId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %N</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadNameFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadNameFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getThreadName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %%</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PercentSignFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PercentSignFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TabFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TabFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %n</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewLineFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewLineFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化模板参数外的字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>): <span class="built_in">m_string</span>(str)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; m_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_string;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>format使用多态，逐个调用FormatItem派生类的format方法，将日志信息写入os</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostream&amp; <span class="title">LogFormatter::format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; formatItem : m_items)&#123;</span><br><span class="line">        formatItem-&gt;format(os, event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote><p><code>init()</code>是LogFormatter的实现重点，其作用是将m_pattern解析为一个FormatItem::ptr数组，并存入m_item</p></blockquote><p>init的逻辑大致只有以下两步，但实现方式需要多琢磨</p><ol><li><p>使用一个简单的基于状态机的解析方案，解析模板字符串与常规字符</p><ul><li><p>支持解析上面列举的转义字符，并且支持将连续的普通字符合并成一个字符串</p><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">| 当前字符是否是%？</span><br><span class="line">    --&gt;是</span><br><span class="line">        --&gt;状态机状态为正在解析模板参数</span><br><span class="line">            - 当前字符为转义%，将模板参数记录到数组</span><br><span class="line">        --&gt;状态机状态为正在解析常规字符串</span><br><span class="line">            - 当前常规字符串解析完成，保存已解析的常规字符串</span><br><span class="line">            - 准备开始解析模板参数，状态机状态变为正在解析模板参数</span><br><span class="line">    --&gt;否</span><br><span class="line">        --&gt;状态机状态为正在解析模板参数</span><br><span class="line">            - 将模板参数记录到数组（对于日期格式(模板参数为d)，还需要进一步进行处理）</span><br><span class="line">            - 解析完模板参数，状态机状态变为正在解析常规字符串</span><br><span class="line">        --&gt;状态机状态为正在解析常规字符串</span><br><span class="line">            - 记录字符到字符串</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建模板参数对应的<code>FormatItem</code>对象（使用宏函数）</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogFormatter::init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// &lt;type, str&gt;</span></span><br><span class="line">    <span class="comment">// type: 为0时表示为普通字符串，为1时表示为需要解析的模板参数</span></span><br><span class="line">    <span class="comment">// str: 存储字符串内容（普通字符串 or 模板参数）</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板参数中只有%d（日期时间）需要额外存储模板字符串，所以使用一个单独的变量dataFormat来存储</span></span><br><span class="line">    std::string dateFormat;</span><br><span class="line">    <span class="comment">// 存储常规字符串</span></span><br><span class="line">    std::string normalString;</span><br><span class="line">    <span class="comment">// 状态机，true表示正在解析普通字符串，false表示正在解析模板参数或模板字符串</span></span><br><span class="line">    <span class="type">bool</span> parsing_string = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_pattern.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        std::string c = std::<span class="built_in">string</span>(<span class="number">1</span>, m_pattern[i]);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&quot;%&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parsing_string)&#123;</span><br><span class="line">                <span class="comment">// 解析常规字符串时碰到%，本段常规字符串的解析完成，状态机变为解析模板字符串模式</span></span><br><span class="line">                <span class="keyword">if</span>(!normalString.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, normalString));</span><br><span class="line">                    normalString.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                parsing_string = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 解析模板参数时碰到%，说明是转义%</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, c));</span><br><span class="line">                parsing_string = <span class="literal">true</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(parsing_string)&#123;</span><br><span class="line">                <span class="comment">// 解析常规字符串时，不断将当前字符加入normalString，直到遇到%</span></span><br><span class="line">                normalString += c;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 解析模板字符：直接将模板字符加入vec</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, c));   </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对日期时间（%d），还需要另外解析dateFormat</span></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&quot;d&quot;</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    <span class="keyword">if</span>(m_pattern[i] != <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">// %d后没有跟 &#123;&#125;，dateFormat为空，解析结果依赖DataFormatItem类的默认实现</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ++i;</span><br><span class="line">                        <span class="comment">// 将 &#123;&#125; 之间的所有字符都加入dateFormat</span></span><br><span class="line">                        <span class="keyword">while</span>(i &lt; m_pattern.<span class="built_in">size</span>() &amp;&amp; m_pattern[i] != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                            dateFormat.<span class="built_in">push_back</span>(m_pattern[i]);</span><br><span class="line">                            ++i;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果遍历到m_pattern尾部都没有遇到&#x27;&#125;&#x27;，说明大括号没有闭合，解析错误</span></span><br><span class="line">                        <span class="keyword">if</span>(i == m_pattern.<span class="built_in">size</span>() &amp;&amp; m_pattern[i - <span class="number">1</span>] != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                            <span class="comment">// log中加入错误信息</span></span><br><span class="line">                            vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;&lt;&lt;Pattern Error&gt;&gt;&quot;</span>));</span><br><span class="line">                            dateFormat.<span class="built_in">clear</span>();</span><br><span class="line">                            m_error = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 模板字符串解析完成，状态机转为默认状态（即解析常规字符串）</span></span><br><span class="line">                parsing_string = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将尾部的常规字符串也加入vec</span></span><br><span class="line">    <span class="keyword">if</span>(!normalString.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">pair</span>(<span class="number">0</span>, normalString));</span><br><span class="line">        normalString.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串到具体FormatItem类的映射，相当于一个简易工厂类</span></span><br><span class="line">    <span class="comment">// 利用宏函数初始化map的成员，两个宏参数：</span></span><br><span class="line">    <span class="comment">// str：通过#str将str的内容字符串化，指定std::function需要生成FormatItem的哪个派生类</span></span><br><span class="line">    <span class="comment">// std::function：接收一个字符串，用该字符串初始化指定的派生类</span></span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, std::function&lt;FormatItem::ptr(<span class="type">const</span> std::string&amp; str)&gt;&gt; s_format_items = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XX(str, C) &#123;#str, [](const std::string&amp; fmt)&#123; return FormatItem::ptr(new C(fmt)); &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">XX</span>(m, MessageFormatItem),       <span class="comment">// m: 消息</span></span><br><span class="line">        <span class="built_in">XX</span>(p, LevelFormatItem),         <span class="comment">// p: 日志级别</span></span><br><span class="line">        <span class="built_in">XX</span>(c, LoggerNameFormatItem),    <span class="comment">// c: 日志器名称</span></span><br><span class="line">        <span class="built_in">XX</span>(d, DateTimeFormatItem),      <span class="comment">// d: 日期时间</span></span><br><span class="line">        <span class="built_in">XX</span>(r, ElapseFormatItem),        <span class="comment">// r: 累计毫秒数</span></span><br><span class="line">        <span class="built_in">XX</span>(f, FilenameFormatItem),      <span class="comment">// f: 文件名</span></span><br><span class="line">        <span class="built_in">XX</span>(l, LineFormatItem),          <span class="comment">// l: 行号</span></span><br><span class="line">        <span class="built_in">XX</span>(t, ThreadIdFormatItem),      <span class="comment">// t: 线程号</span></span><br><span class="line">        <span class="built_in">XX</span>(F, FiberIdFormatItem),       <span class="comment">// F: 协程号</span></span><br><span class="line">        <span class="built_in">XX</span>(N, ThreadNameFormatItem),    <span class="comment">// N: 线程名称</span></span><br><span class="line">        <span class="built_in">XX</span>(%, PercentSignFormatItem),   <span class="comment">// %: 百分号</span></span><br><span class="line">        <span class="built_in">XX</span>(T, TabFormatItem),           <span class="comment">// T: 制表符</span></span><br><span class="line">        <span class="built_in">XX</span>(n, NewLineFormatItem),       <span class="comment">// n: 换行符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XX</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : vec)&#123;</span><br><span class="line">        <span class="comment">// 常规字符串</span></span><br><span class="line">        <span class="keyword">if</span>(item.first == <span class="number">0</span>)&#123;</span><br><span class="line">            m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">StringFormatItem</span>(item.second)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模板参数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 日期时间进行特殊处理，使用dateFormat初始化，其他模板参数使用item.second初始化</span></span><br><span class="line">            <span class="keyword">if</span>(item.second == <span class="string">&quot;d&quot;</span>)&#123;</span><br><span class="line">                m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">DateTimeFormatItem</span>(dateFormat)));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = s_format_items.<span class="built_in">find</span>(item.second);</span><br><span class="line">                <span class="keyword">if</span>(it != s_format_items.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(it-&gt;<span class="built_in">second</span>(item.second)));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不合法的模板参数，log记录错误信息</span></span><br><span class="line">                    m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">StringFormatItem</span>(<span class="string">&quot;&lt;&lt;error_format %&quot;</span> + item.second + <span class="string">&quot;&gt;&gt;&quot;</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogAppender"><a href="#LogAppender" class="headerlink" title="LogAppender"></a>LogAppender</h2><blockquote><p>LogAppender用于将一个日志事件输出到对应的输出地</p></blockquote><p>LogAppender是一个虚类，可以派生出不同的具体实现。不同类型的Appender通过重载log方法来实现往不同的目的地进行输出</p><p>基类指定了格式化器（LogFormatter），用户可以自定义格式化器，如果用户没有定义，则使用默认格式化器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志输出地</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogAppender</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogAppender&gt;;</span><br><span class="line">    <span class="keyword">using</span> MutexType = SpinLock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogAppender</span>(LogFormatter::ptr defaultFormatter)</span><br><span class="line">        : <span class="built_in">m_defaultFormatter</span>(defaultFormatter)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">LogAppender</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormatter</span><span class="params">(LogFormatter::ptr formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LogFormatter::ptr <span class="title">getFormatter</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Logger在调用Appender之前已经判断了日志级别，这里不需要再重复判断level</span></span><br><span class="line">    <span class="comment">// LogLevel::Level m_level;</span></span><br><span class="line">    LogFormatter::ptr m_formatter;          <span class="comment">// 自定义formatter</span></span><br><span class="line">    LogFormatter::ptr m_defaultFormatter;   <span class="comment">// 默认formatter</span></span><br><span class="line">    <span class="keyword">mutable</span> MutexType m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="基类的get-set方法"><a href="#基类的get-set方法" class="headerlink" title="基类的get/set方法"></a>基类的get/set方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogAppender::setFormatter</span><span class="params">(LogFormatter::ptr formatter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个MutexType的范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   </span><br><span class="line">    m_formatter = formatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LogFormatter::ptr <span class="title">LogAppender::getFormatter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个MutexType的范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> m_formatter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StdoutLogAppender——输出到终端"><a href="#StdoutLogAppender——输出到终端" class="headerlink" title="StdoutLogAppender——输出到终端"></a>StdoutLogAppender——输出到终端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StdoutLogAppender</span>: <span class="keyword">public</span> LogAppender&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StdoutLogAppender</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;StdoutLogAppender&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">StdoutLogAppender::<span class="built_in">StdoutLogAppender</span>()</span><br><span class="line">    : <span class="built_in">LogAppender</span>(LogFormatter::<span class="built_in">ptr</span>(<span class="keyword">new</span> LogFormatter))&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StdoutLogAppender::log</span><span class="params">(LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_formatter)&#123;</span><br><span class="line">        <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_formatter-&gt;format(std::cout, event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MutexType::Lock <span class="built_in">lock</span>(m_mutex);</span><br><span class="line">        m_defaultFormatter-&gt;format(std::cout, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileLogAppender——输出到文件"><a href="#FileLogAppender——输出到文件" class="headerlink" title="FileLogAppender——输出到文件"></a>FileLogAppender——输出到文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogAppender</span>: <span class="keyword">public</span> LogAppender&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;FileLogAppender&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FileLogAppender</span>(<span class="type">const</span> std::string&amp; filename);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重新打开文件（如果文件是打开状态，则先关闭它再打开）</span></span><br><span class="line">    <span class="comment">// 打开成功返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">reopen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_filename;         <span class="comment">// 输出目的地的文件名</span></span><br><span class="line">    std::ofstream m_filestream;     <span class="comment">// 输出目的地的文件流</span></span><br><span class="line">    <span class="type">uint64_t</span> m_lastTime;            <span class="comment">// 上次打开时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">FileLogAppender::<span class="built_in">FileLogAppender</span>(<span class="type">const</span> std::string&amp; filename)</span><br><span class="line">    : <span class="built_in">LogAppender</span>(LogFormatter::<span class="built_in">ptr</span>(<span class="keyword">new</span> LogFormatter))</span><br><span class="line">    , <span class="built_in">m_filename</span>(filename)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileLogAppender::log</span><span class="params">(LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定时reopen文件，防止因文件被其他线程删除等原因而log失败</span></span><br><span class="line">    <span class="type">uint64_t</span> now = event-&gt;<span class="built_in">getTime</span>();</span><br><span class="line">    <span class="keyword">if</span>(now &gt;= (m_lastTime + <span class="number">3</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">reopen</span>())&#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;reopen fail, file name=&quot;</span> &lt;&lt; m_filename &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        m_lastTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// log</span></span><br><span class="line">    <span class="keyword">if</span>(m_filestream)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_formatter)&#123;</span><br><span class="line">            m_formatter-&gt;format(m_filestream, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_defaultFormatter-&gt;format(m_filestream, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><blockquote><p>Logger负责进行日志输出</p><ul><li>Logger的多线程安全：因为log操作的阻塞时间较短，所以使用<strong>自旋锁</strong>来保证多线程安全</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> LogManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;Logger&gt;;</span><br><span class="line">    <span class="keyword">using</span> MutexType = SpinLock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAppender</span><span class="params">(LogAppender::ptr appender)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delAppender</span><span class="params">(LogAppender::ptr appender)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearAppenders</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LogLevel::Level <span class="title">getLevel</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_level; &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLevel</span><span class="params">(LogLevel::Level level)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 日志器的名称</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="comment">// 日志级别，只有高于该级别的日志事件才会被输出</span></span><br><span class="line">    LogLevel::Level m_level;</span><br><span class="line">    <span class="comment">// 日志输出地的集合</span></span><br><span class="line">    std::list&lt;LogAppender::ptr&gt; m_appenders;</span><br><span class="line">    <span class="comment">// 主日志器，当logger没有定义appender时，其行为与该主日志器一致</span></span><br><span class="line">    Logger::ptr m_root;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">mutable</span> MutexType m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>log接受一个日志事件，先判断该日志事件的级别是否大于本日志器的日志级别。如果日志级别满足条件，则调用appender的log方法将日志事件进行输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 仅输出大于m_level的日志事件</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">getLevel</span>() &gt;= m_level)&#123;</span><br><span class="line">        <span class="comment">// 上范围锁</span></span><br><span class="line">        <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 对所有appender进行log</span></span><br><span class="line">        <span class="keyword">if</span>(!m_appenders.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; appender: m_appenders)&#123;</span><br><span class="line">                appender-&gt;<span class="built_in">log</span>(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m_root) &#123;</span><br><span class="line">            <span class="comment">// 如果没有配置appender，就使用主日志器m_root的appenders进行log</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; appender : m_root-&gt;m_appenders)&#123;</span><br><span class="line">                appender-&gt;<span class="built_in">log</span>(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="appender操作"><a href="#appender操作" class="headerlink" title="appender操作"></a>appender操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::addAppender</span><span class="params">(LogAppender::ptr appender)</span></span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_appenders.<span class="built_in">push_back</span>(appender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::delAppender</span><span class="params">(LogAppender::ptr appender)</span></span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_appenders.<span class="built_in">begin</span>(); it != m_appenders.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == appender)&#123;</span><br><span class="line">            m_appenders.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::clearAppenders</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_appenders.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toYamlString"><a href="#toYamlString" class="headerlink" title="toYamlString"></a>toYamlString</h3><p>将Logger信息输出为Yaml格式的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">Logger::toYamlString</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">    node[<span class="string">&quot;name&quot;</span>] = m_name;</span><br><span class="line">    node[<span class="string">&quot;level&quot;</span>] = LogLevel::<span class="built_in">ToString</span>(m_level);</span><br><span class="line">    <span class="comment">// 读取m_appenders，上范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; a : m_appenders)&#123;</span><br><span class="line">        node[<span class="string">&quot;appenders&quot;</span>].<span class="built_in">push_back</span>(YAML::<span class="built_in">Load</span>(a-&gt;<span class="built_in">toYamlString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; node;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogEventWrap"><a href="#LogEventWrap" class="headerlink" title="LogEventWrap"></a>LogEventWrap</h2><blockquote><p>LogEventWrap是一个<strong>RAII类</strong>，它封装了一个Logger和LogEvent，在其析构时调用Logger的log方法提交日志事件</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogEventWrap</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogEventWrap</span>(Logger::ptr logger, LogEvent::ptr event);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LogEventWrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">LogEvent::ptr <span class="title">getEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_event; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::stringstream&amp; <span class="title">getSS</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Logger::ptr m_logger;</span><br><span class="line">    LogEvent::ptr m_event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line">LogEventWrap::<span class="built_in">LogEventWrap</span>(Logger::ptr logger, LogEvent::ptr event)</span><br><span class="line">    : <span class="built_in">m_logger</span>(logger)</span><br><span class="line">    , <span class="built_in">m_event</span>(event)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogEventWrap析构时对日志事件进行log</span></span><br><span class="line">LogEventWrap::~<span class="built_in">LogEventWrap</span>()&#123;</span><br><span class="line">    m_logger-&gt;<span class="built_in">log</span>(m_event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::stringstream&amp; <span class="title">LogEventWrap::getSS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_event-&gt;<span class="built_in">getSS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogManager"><a href="#LogManager" class="headerlink" title="LogManager"></a>LogManager</h2><blockquote><p>LogManager用于统一管理所有的日志器，提供日志器的创建与获取方法</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Logger的管理器，管理主日志器以及所有Logger</span></span><br><span class="line"><span class="comment">// LogManager是创建Logger的唯一方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogManager</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> Singleton&lt;LogManager&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> MutexType = SpinLock;</span><br><span class="line"></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">getLogger</span><span class="params">(std::string loggerName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo: init实现从配置文件中加载日志配置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">getRoot</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_root; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 单例模式，私有的构造函数</span></span><br><span class="line">    <span class="built_in">LogManager</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 主日志器</span></span><br><span class="line">    Logger::ptr m_root;</span><br><span class="line">    <span class="comment">// 管理包括m_root在内所有日志器的容器</span></span><br><span class="line">    std::map&lt;std::string, Logger::ptr&gt; m_loggers;</span><br><span class="line">    <span class="comment">// Mutex</span></span><br><span class="line">    <span class="keyword">mutable</span> MutexType m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单例模式管理LogManager</span></span><br><span class="line"><span class="keyword">using</span> LoggerMgr = Singleton&lt;LogManager&gt;;</span><br></pre></td></tr></table></figure><h3 id="Singleton单例类"><a href="#Singleton单例类" class="headerlink" title="Singleton单例类"></a>Singleton单例类</h3><p>基于单例模式的单例模板类，通过静态函数创建指定类的静态对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X = <span class="type">void</span>, <span class="type">int</span> N = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Singleton&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> T* <span class="built_in">GetInstance</span>()&#123;</span><br><span class="line">        <span class="type">static</span> T v;</span><br><span class="line">        <span class="keyword">return</span> &amp;v; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过类型别名为用户提供创建LogManager单例的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.h</span></span><br><span class="line"><span class="keyword">using</span> LoggerMgr = Singleton&lt;LogManager&gt;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造时默认创建一个root日志器，将日志信息输出到终端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LogManager::<span class="built_in">LogManager</span>()&#123;</span><br><span class="line">    m_root.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Logger</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">    m_root-&gt;<span class="built_in">addAppender</span>(std::<span class="built_in">make_shared</span>&lt;StdoutLogAppender&gt;());</span><br><span class="line">    m_loggers[m_root-&gt;<span class="built_in">getName</span>()] = m_root;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getLogger"><a href="#getLogger" class="headerlink" title="getLogger"></a>getLogger</h3><p>getLogger根据日志器名从管理的日志器中返回一个Logger，否则以该名字创建一个Logger</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Logger::ptr <span class="title">LogManager::getLogger</span><span class="params">(std::string loggerName)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要读取m_loggers，上范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = m_loggers.<span class="built_in">find</span>(loggerName);</span><br><span class="line">    <span class="comment">// 找到logger就返回该logger</span></span><br><span class="line">    <span class="keyword">if</span>(it != m_loggers.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则以该名字创建一个logger，其主日志器指向LogManager的主日志器</span></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">newLogger</span><span class="params">(std::make_shared&lt;Logger&gt;(loggerName))</span></span>;</span><br><span class="line">    newLogger-&gt;m_root = m_root;</span><br><span class="line">    m_loggers[loggerName] = newLogger;</span><br><span class="line">    <span class="keyword">return</span> newLogger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="toYamlString-1"><a href="#toYamlString-1" class="headerlink" title="toYamlString"></a>toYamlString</h3><p>将<code>LoggerManager</code>的信息输出为Yaml格式的字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">LogManager::toYamlString</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; l : m_loggers)&#123;</span><br><span class="line">        node[<span class="string">&quot;logs&quot;</span>].<span class="built_in">push_back</span>(YAML::<span class="built_in">Load</span>(l.second-&gt;<span class="built_in">toYamlString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; node;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实用辅助函数"><a href="#实用辅助函数" class="headerlink" title="实用辅助函数"></a>实用辅助函数</h2><h3 id="使用流式方式写入日志"><a href="#使用流式方式写入日志" class="headerlink" title="使用流式方式写入日志"></a>使用流式方式写入日志</h3><p>使用流式方式将日志级别level的日志写入logger</p><p>基于宏函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="comment">// 使用流式方式将日志级别level的日志写入logger</span></span><br><span class="line"><span class="comment">// 这里宏函数替换的是代码段，所以不能使用inline替代宏函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_LEVEL(logger, level) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(logger-&gt;getLevel() &lt;= level) \</span></span><br><span class="line"><span class="meta">        sylar::LogEventWrap(logger, std::make_shared<span class="string">&lt;sylar::LogEvent&gt;</span>(logger-&gt;getName(), level, __FILE__, __LINE__\</span></span><br><span class="line"><span class="meta">                            , 0, sylar::GetThreadId(), sylar::GetFiberId(), time(0), sylar::GetThreadName())).getSS()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_DEBUG(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::DEBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_INFO(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::INFO)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_WARN(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::WARN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_ERROR(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ERROR)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_FATAL(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::FATAL)</span></span><br></pre></td></tr></table></figure><h3 id="使用格式化方式写入日志"><a href="#使用格式化方式写入日志" class="headerlink" title="使用格式化方式写入日志"></a>使用格式化方式写入日志</h3><p>基于inline实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用格式化方式将日志级别level的日志写入logger</span></span><br><span class="line"><span class="comment">// 使用可变参数模板+inline替代宏函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_LEVEL</span><span class="params">(sylar::Logger::ptr logger, sylar::LogLevel::Level level, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(logger-&gt;<span class="built_in">getLevel</span>() &lt;= level)&#123;</span><br><span class="line">        sylar::<span class="built_in">LogEventWrap</span>(logger, std::<span class="built_in">make_shared</span>&lt;sylar::LogEvent&gt;(logger-&gt;<span class="built_in">getName</span>(), level, __FILE__, __LINE__</span><br><span class="line">                            , <span class="number">0</span>, sylar::<span class="built_in">GetThreadId</span>(), <span class="number">42</span>, <span class="built_in">time</span>(<span class="number">0</span>), <span class="string">&quot;Thread&quot;</span>)).<span class="built_in">getEvent</span>()-&gt;format(fmt, args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_DEBUG</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::DEBUG, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_INFO</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::INFO, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_WARN</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::WARN, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_ERROR</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::ERROR, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_FATAL</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::FATAL, fmt, args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取日志器"><a href="#获取日志器" class="headerlink" title="获取日志器"></a>获取日志器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取LogManager中的主日志器（root）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_ROOT() sylar::LoggerMgr::GetInstance()-&gt;getRoot()</span></span><br><span class="line"><span class="comment">// 根据名字获取logger</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_NAME(name) sylar::LoggerMgr::GetInstance()-&gt;getLogger(name)</span></span><br></pre></td></tr></table></figure><h1 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h1><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义输出地与输出格式</span></span><br><span class="line">    sylar::<span class="function">FileLogAppender::ptr <span class="title">file_appender</span><span class="params">(<span class="keyword">new</span> sylar::FileLogAppender(<span class="string">&quot;./log.txt&quot;</span>))</span></span>;</span><br><span class="line">    sylar::<span class="function">LogFormatter::ptr <span class="title">fmt</span><span class="params">(<span class="keyword">new</span> sylar::LogFormatter(<span class="string">&quot;%d%T%p%T%m%n&quot;</span>))</span></span>;</span><br><span class="line">    file_appender-&gt;<span class="built_in">setFormatter</span>(fmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LogerManager单例</span></span><br><span class="line">    <span class="keyword">auto</span> mgr = sylar::LoggerMgr::<span class="built_in">GetInstance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根日志器新增appender</span></span><br><span class="line">    mgr-&gt;<span class="built_in">getRoot</span>()-&gt;<span class="built_in">addAppender</span>(file_appender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据LogManager单例创建Logger</span></span><br><span class="line">    <span class="keyword">auto</span> logger = mgr-&gt;<span class="built_in">getLogger</span>(<span class="string">&quot;Logger01&quot;</span>);</span><br><span class="line">    logger-&gt;<span class="built_in">addAppender</span>(std::<span class="built_in">make_shared</span>&lt;sylar::StdoutLogAppender&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用宏函数流式输出日志信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;LoggerManager&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_ERROR</span>(mgr-&gt;<span class="built_in">getRoot</span>()) &lt;&lt; <span class="string">&quot;test &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; Error&quot;</span>;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_INFO</span>(logger) &lt;&lt; <span class="string">&quot;test logger01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实用格式化方式输出日志信息</span></span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_DEBUG</span>(mgr-&gt;<span class="built_in">getRoot</span>(), <span class="string">&quot;test %s Debug &lt;%s&gt;&quot;</span>, str.<span class="built_in">c_str</span>(), <span class="string">&quot;using inline and template&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取system日志器</span></span><br><span class="line"><span class="type">static</span> sylar::Logger::ptr g_logger1 = <span class="built_in">SYLAR_LOG_NAME</span>(<span class="string">&quot;system&quot;</span>);</span><br><span class="line"><span class="comment">// 使用system日志器流式打印INFO级别的日志</span></span><br><span class="line"><span class="built_in">SYLAR_LOG_INFO</span>(g_logger1) &lt;&lt; <span class="string">&quot;test logger01&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取root日志器</span></span><br><span class="line"><span class="type">static</span> sylar::Logger::ptr g_logger2 = <span class="built_in">SYLAR_LOG_ROOT</span>();</span><br><span class="line"><span class="comment">// 使用root日志器流式打印INFO级别的日志</span></span><br><span class="line"><span class="built_in">SYLAR_LOG_INFO</span>(g_logger2) &lt;&lt; <span class="string">&quot;test logger02&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块概述&quot;&gt;&lt;a href=&quot;#模块概述&quot; class=&quot;headerlink&quot; title=&quot;模块概述&quot;&gt;&lt;/a&gt;模块概述&lt;/h1&gt;&lt;p&gt;模仿log4j日志框架实现一个的日志模块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难点：Logformatter的init()，将一个字符</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://atelieryu.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="后端" scheme="https://atelieryu.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="C++" scheme="https://atelieryu.site/tags/C/"/>
    
    <category term="日志库" scheme="https://atelieryu.site/tags/%E6%97%A5%E5%BF%97%E5%BA%93/"/>
    
    <category term="服务器框架" scheme="https://atelieryu.site/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++实现轻量级RPC分布式网络通信框架</title>
    <link href="https://atelieryu.site/posts/ccad8bf.html"/>
    <id>https://atelieryu.site/posts/ccad8bf.html</id>
    <published>2025-03-18T12:38:00.000Z</published>
    <updated>2025-03-25T03:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><p>RPC（Remote Procedure Call）是一种使程序能够像调用本地函数一样调用远程服务的方法。它屏蔽了底层的通信细节，使得<strong>开发人员无需关注远程调用的复杂性，只需像操作本地方法一样调用远程方法</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/T_Solotov/article/details/124107667?spm=1001.2014.3001.5501">参考博客</a></li><li><a href="https://github.com/youngyangyang04/Krpc">参考项目</a></li></ul><h2 id="项目仓库"><a href="#项目仓库" class="headerlink" title="项目仓库"></a>项目仓库</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/YVollerei/RPC"><img src="https://github-readme-stats.vercel.app/api/pin/?username=YVollerei&repo=RPC&show_owner=true"/></a><h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><h2 id="框架流程图"><a href="#框架流程图" class="headerlink" title="框架流程图"></a>框架流程图</h2><p><img src="https://atelieryu.xyz/elog/202503/658296c43b32f9ef93f5847831247355.png" alt="image.png"></p><h2 id="代码调用流程"><a href="#代码调用流程" class="headerlink" title="代码调用流程"></a>代码调用流程</h2><p><img src="https://atelieryu.xyz/elog/202503/25f25fec56e09f89f5fd76fd8d2bcc2e.png" alt="image.png"></p><h3 id="三个主体"><a href="#三个主体" class="headerlink" title="三个主体"></a>三个主体</h3><ul><li><p><strong>zookeeper服务端</strong></p><ul><li>zooKeeper在这里作为服务方法的管理配置中心，负责管理服务方法提供者对外提供的服务方法</li><li>Rpc服务端与客户端的身份都是zookeeper客户端</li><li><p>zookeeper存储服务对象与服务方法的方式：</p><p><img src="https://atelieryu.xyz/elog/202503/d9567a2a7c46ad22233b0c41cef598ff.png" alt="image.png"></p></li></ul></li><li><p><strong>Rpc服务端</strong></p><ul><li>Rpc服务端需要向zookeeper注册服务对象与服务方法，注册的内容是本机上提供该服务的ip+端口</li><li>注册完服务后，启动epoll监听客户端的远端调用请求</li><li>接收到Rpc客户端的远端调用后，先对调用参数进行反序列化，再调用本地方法处理该调用，最后将处理结果包装为响应，序列化后发出</li></ul></li><li><strong>Rpc客户端</strong><ul><li>Rpc客户端需要先从zookeeper中查询提供目标服务的Rpc服务端ip与端口</li><li>查询到Rpc服务端的ip与端口向目标端口发起连接，之后就是send - recv的流程，区别是send前需要对请求内容进行序列化，recv后需要对响应内容进行反序列化</li></ul></li></ul><h1 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h1><p>定义了两个proto文件</p><h2 id="Krpcheader-proto"><a href="#Krpcheader-proto" class="headerlink" title="Krpcheader.proto"></a>Krpcheader.proto</h2><p>该文件定义了<strong>RPC调用的元数据头部</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Krpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RpcHeader</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> service_name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> method_name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint32</span> args_size = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>service_name：用于标识目标服务（如 <code>UserServiceRpc</code>）</li><li>method_name：用于标识目标方法（如 <code>Login</code>）</li><li>args_size：表示后续参数数据的字节长度，避免粘包问题</li></ul><p>服务端接收到请求后，通过service_name和method_name找到对应的服务</p><h2 id="user-proto"><a href="#user-proto" class="headerlink" title="user.proto"></a>user.proto</h2><p>该文件定义了<code>UserServiceRpc</code>服务，以及它的两个方法<code>Login</code>和<code>Register</code></p><p>可以根据具体需求改动<code>LoginRequest</code>和<code>RegisterRequest</code>中的参数</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Kuser;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制生成基于protobuf的通用RPC服务基类</span></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterRequest</span> &#123;</span><br><span class="line">    <span class="type">uint32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Register(RegisterRequest) <span class="keyword">returns</span>(RegisterResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Login和Register"><a href="#Login和Register" class="headerlink" title="Login和Register"></a>Login和Register</h3><ul><li>定义Login方法接收两个参数：name和pwd</li><li>定义Register方法接收三个参数：id、name、pwd</li></ul><h3 id="cc-generic-services"><a href="#cc-generic-services" class="headerlink" title="cc_generic_services"></a>cc_generic_services</h3><p>启用<code>cc_generic_services</code>后，proto会生成两个C++类</p><ul><li><code>UserServiceRpc</code>：callee需要继承此类并实现 <code>Login</code> 和 <code>Register</code> 方法</li><li><code>UserServiceRpc_Stub</code>：客户端存根类，由caller继承，通过 <code>RpcChannel</code> 发起调用</li></ul><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>调用以下命令生成proto文件对应的C++代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc user.proto -I ./ --cpp_out=./user</span><br></pre></td></tr></table></figure><p>生成的 user.h 和 user.cc 会被保存到 ./user 文件夹中</p><h1 id="RPC服务端"><a href="#RPC服务端" class="headerlink" title="RPC服务端"></a>RPC服务端</h1><h2 id="服务端主文件Kserver-cpp"><a href="#服务端主文件Kserver-cpp" class="headerlink" title="服务端主文件Kserver.cpp"></a>服务端主文件Kserver.cpp</h2><p>主文件由UserService和main函数两部分组成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcProvider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端上的自定义UserService，继承自proto生成的UserServiceRpc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span>: <span class="keyword">public</span> Kuser::UserServiceRpc&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个版本执行Login的本地任务 </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd=&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写UserServiceRpc的虚函数</span></span><br><span class="line">    <span class="comment">// 这个版本的Login执行：接收远端调用 - 调用执行本地任务 - 写入响应 - 执行回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ::Kuser::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::Kuser::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Closure* done)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 接收远端调用的参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用重载版本，执行本地任务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入响应，参考user.proto中的定义</span></span><br><span class="line">        Kuser::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调（执行响应对象数据的序列化和网络发送，交给框架来完成）</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    KrpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider将UserService发布到rpc节点上</span></span><br><span class="line">    KrpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务发布节点。Run以后进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h3><p>UserService继承自proto文件生成的UserServiceRpc，为具体服务，其中定义了服务中Login方法的两个具体实现：</p><ul><li>一个版本的Login负责执行本地任务</li><li>一个版本的Login负责接收远端调用，之后调用重载版本执行本地任务，最后将执行结果写入响应，并阻塞等待回调</li></ul><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>main函数主要执行以下工作：</p><ol><li>调用框架的初始化操作，从配置文件中读取必要的配置信息</li><li>将上面定义的UserService发布到Rpc节点上</li><li>启动Rpc服务发布节点，阻塞等待远端客户端调用该服务</li></ol><h2 id="为服务端提供服务的类"><a href="#为服务端提供服务的类" class="headerlink" title="为服务端提供服务的类"></a>为服务端提供服务的类</h2><h3 id="KrpcApplication"><a href="#KrpcApplication" class="headerlink" title="KrpcApplication"></a>KrpcApplication</h3><p>KrpcApplication主要负责框架的初始化操作，有以下几个注意点：</p><ul><li>KrpcApplication为一个单例类</li><li>初始化操作具体为：从命令行中解析出配置文件路径 → 调用KrpcConfig类载入配置文件，完成各参数的初始化</li><li>初始化的配置项包括zookeeper服务器的ip和端口，以及Rpc服务端自己的ip和端口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcChannel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Krpc基础类，负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化框架</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式，返回单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KrpcApplication&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 删除单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KrpcConfig&amp; <span class="title">GetConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 单例模式，私有的构造函数</span></span><br><span class="line">    <span class="built_in">KrpcApplication</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">KrpcApplication</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝与移动构造</span></span><br><span class="line">    <span class="built_in">KrpcApplication</span>(<span class="type">const</span> KrpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">KrpcApplication</span>(KrpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="type">static</span> KrpcConfig m_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="type">static</span> KrpcApplication* m_application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥量</span></span><br><span class="line">    <span class="type">static</span> std::mutex m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次声明静态变量</span></span><br><span class="line">KrpcConfig KrpcApplication::m_config;</span><br><span class="line">std::mutex KrpcApplication::m_mutex;</span><br><span class="line"><span class="comment">// 懒汉模式初始化单例对象</span></span><br><span class="line">KrpcApplication* KrpcApplication::m_application = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;KrpcApplication::Init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// -i后必须有配置文件路径，文件中记录zookeeper服务器的ip和端口，以及服务器的ip和端口</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="comment">// getopt用于解析命令行字符，第三个参数表示接收的参数，这里只指定i</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;KrpcApplication: case -i&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// -i表示指定配置文件路径</span></span><br><span class="line">                <span class="comment">// optarg为命令行参数对应的值，这里即为指定的配置文件路径</span></span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 不接受i以外的命令行参数</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 出现了i但后面没有对应的值</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从配置文件中载入配置项</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式，返回单例对象</span></span><br><span class="line"><span class="function">KrpcApplication&amp; <span class="title">KrpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例时上锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!m_application)&#123;</span><br><span class="line">        m_application = <span class="keyword">new</span> <span class="built_in">KrpcApplication</span>();</span><br><span class="line">        <span class="comment">// 设置程序退出时自动销毁单例对象</span></span><br><span class="line">        <span class="built_in">atexit</span>(DeleteInstance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *m_application;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcApplication::DeleteInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_application)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_application;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置</span></span><br><span class="line"><span class="function">KrpcConfig&amp; <span class="title">KrpcApplication::GetConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KrpcConfig"><a href="#KrpcConfig" class="headerlink" title="KrpcConfig"></a>KrpcConfig</h3><p>KrpcConfig主要负责实际的配置项初始化操作，具体就是从配置文件中逐行读入配置项，逻辑比较简单</p><p>值得学习的点有使用智能指针管理文件指针，这样可以在初始化结束后自动关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* config_file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找配置项对应的值</span></span><br><span class="line">    <span class="function">std::string <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 辅助函数，用于去除字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string&amp; read_buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存放配置项的容器</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcConfig::LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* config_file)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理文件指针，并指定删除器为fclose</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">pf</span><span class="params">(fopen(config_file, <span class="string">&quot;r&quot;</span>), fclose)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐行读取配置项</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="number">1024</span>, pf.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line">        <span class="comment">// 跳过空行与注释行</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf.<span class="built_in">empty</span>() || read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#x27;=&#x27;前为配置名，后为配置值</span></span><br><span class="line">        <span class="type">int</span> ind = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ind == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析key</span></span><br><span class="line">        std::string key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, ind);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="comment">// 解析value</span></span><br><span class="line">        <span class="type">int</span> endInd = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, ind);</span><br><span class="line">        std::string value = read_buf.<span class="built_in">substr</span>(ind + <span class="number">1</span>, endInd - ind - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入配置项</span></span><br><span class="line">        m_configs[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找配置项对应的值</span></span><br><span class="line"><span class="function">std::string <span class="title">KrpcConfig::Load</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configs.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configs.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于去除字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcConfig::Trim</span><span class="params">(std::string&amp; read_buf)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 去除前导空格</span></span><br><span class="line">    <span class="type">int</span> ind = read_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ind != <span class="number">-1</span>)&#123;</span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(ind, read_buf.<span class="built_in">size</span>() - ind);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除尾部空格</span></span><br><span class="line">    ind = read_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ind != <span class="number">-1</span>)&#123;</span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, ind + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KrpcProvider"><a href="#KrpcProvider" class="headerlink" title="KrpcProvider"></a>KrpcProvider</h2><div class="note info modern"><p>Rpc服务端的核心函数类，提供发布Rpc方法、启动Rpc服务节点等功能</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">KrpcProvider</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给外部使用，用于发布rpc方法</span></span><br><span class="line">    <span class="comment">// 多态：所有服务都继承自google::protobuf::Service</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service* service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动Rpc服务节点，开始提供Rpc远程调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务结构体，用于保存具体的服务对象和它的方法</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service* service;</span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; method_map;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理新连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已有连接上发来的消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buffer, muduo::Timestamp receive_time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送Rpc响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    muduo::net::EventLoop m_eventloop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存服务对象的容器</span></span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_services;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>KrpcProvider如何管理服务对象与其方法？</p></blockquote><ul><li>使用unordered_map存放ServiceInfo，管理所有服务</li><li>每个ServiceInfo也使用一个unordered_map存放method描述符，管理该服务下的所有方法</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KrpcProvider::~<span class="built_in">KrpcProvider</span>()&#123;</span><br><span class="line">    <span class="comment">// 析构函数，停止Event Loop</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~KrpcProvider()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_eventloop.<span class="built_in">quit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NotifyService"><a href="#NotifyService" class="headerlink" title="NotifyService"></a>NotifyService</h3><p><code>NotifyService</code>提供给外部使用，用于<strong>在Rpc服务端上注册RPC服务</strong>：</p><ul><li>将传入的服务保存到<code>m_services</code>中，等待之后调用Run时发布到zookeeper服务器上</li></ul><p>多态思想的利用：</p><ul><li>所有服务都继承自<code>google::protobuf::Service</code>，所以<code>NotifyService</code>能接受任何类型的服务</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::NotifyService</span><span class="params">(google::protobuf::Service* service)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 存放服务对象及其方法的结构体</span></span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用多态返回服务类的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor* psd = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务对象的方法都存入service_info</span></span><br><span class="line">    <span class="type">int</span> method_cnt = psd-&gt;<span class="built_in">method_count</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; method_cnt; ++i)&#123;</span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor* pmd = psd-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        service_info.method_map.<span class="built_in">emplace</span>(pmd-&gt;<span class="built_in">name</span>(), pmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务对象放入容器进行管理</span></span><br><span class="line">    m_services.<span class="built_in">emplace</span>(psd-&gt;<span class="built_in">name</span>(), service_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p><code>Run</code>的主要工作：</p><ol><li>从配置文件中读取Rpc服务器的ip和端口</li><li>调用muduo库接口创建TcpServer对象，并分别绑定连接事件和消息事件，实现网络连接业务和消息处理业务的分离</li><li>将<code>m_services</code>中<strong>注册的服务全部发布到zookeeper服务器上</strong>，让Rpc客户端可以从zookeeper上发现Rpc服务端提供的服务</li><li>所有服务都完成发布后，<strong>启动muduo库网络服务</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中读取Rpc服务端的ip和端口</span></span><br><span class="line">    std::string ip = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建地址</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    <span class="keyword">auto</span> server = std::<span class="built_in">make_shared</span>&lt;muduo::net::TcpServer&gt;(&amp;m_eventloop, address, <span class="string">&quot;KrpcProvider&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别绑定连接事件和消息事件</span></span><br><span class="line">    server-&gt;<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server-&gt;<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程数量为4</span></span><br><span class="line">    server-&gt;<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前Rpc服务端的服务全部注册到zookeeper上，使得Rpc客户端能够从zookeeper上发现服务</span></span><br><span class="line">    ZkClient zkclient;</span><br><span class="line">    zkclient.<span class="built_in">Start</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;KrpcProvider: zkclient Start success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// service_name为永久节点，method_name为临时节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; service: m_services)&#123;</span><br><span class="line">        <span class="comment">// service_name的路径: /service_name</span></span><br><span class="line">        std::string service_path = <span class="string">&quot;/&quot;</span> + service.first;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;KrpcProvider: zkclient Create znode: &quot;</span> &lt;&lt; service_path &lt;&lt; std::endl;</span><br><span class="line">        zkclient.<span class="built_in">Create</span>(service_path.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建method_name节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; method: service.second.method_map)&#123;</span><br><span class="line">            std::string method_path = service_path + <span class="string">&quot;/&quot;</span> + method.first;</span><br><span class="line">            <span class="type">char</span> method_path_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">// 写入节点内容：ip + 端口</span></span><br><span class="line">            <span class="built_in">sprintf</span>(method_path_data, <span class="string">&quot;%s:%d&quot;</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">            <span class="comment">// zookeeper上创建临时节点</span></span><br><span class="line">            zkclient.<span class="built_in">Create</span>(method_path.<span class="built_in">c_str</span>(), method_path_data, <span class="built_in">strlen</span>(method_path_data), ZOO_EPHEMERAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rpc服务端准备启动</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动muduo网络服务</span></span><br><span class="line">    server-&gt;<span class="built_in">start</span>();</span><br><span class="line">    m_eventloop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnConnection"><a href="#OnConnection" class="headerlink" title="OnConnection"></a>OnConnection</h3><p>如果连接失效，则调用shutdown断开连接，除此不对连接事件做特殊处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不做特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnMessage"><a href="#OnMessage" class="headerlink" title="OnMessage"></a>OnMessage</h3><p><code>OnMessage</code>的主要工作：</p><ol><li>处理Tcp粘包问题，反序列化从字节流中解析出参数</li><li>根据参数找到对应的服务与方法</li><li>生成Rpc方法调用的请求和响应，调用本地的方法，并通过回调函数发送响应</li></ol><blockquote><p>如何处理Tcp粘包问题?</p></blockquote><p>将字节流分割为以下几部分：</p><ul><li><code>header_size</code>: 固定4字节，记录header_str的长度</li><li><code>header_str</code>: 记录服务名、方法名、参数长度（KrpcHeader.proto中定义）</li><li><code>arg_str</code>: 用于调用方法的参数</li></ul><blockquote><p>什么是<code>NewCallback</code>？</p></blockquote><p><code>NewCallback</code>函数会返回一个google::protobuf::Closure类的对象，可以理解为定义了一个<strong>回调函数</strong></p><p>Closure类对象相当于一个闭包，它捕获了以下内容：</p><ul><li>一个成员对象的成员函数（这里为<code>SendRpcResponse</code>）</li><li>以及这个成员函数需要的参数（这里为<code>conn</code>、<code>response</code>）</li></ul><blockquote><p>什么是<code>CallMethod</code> ？</p></blockquote><p>CallMethod在<code>UserServiceRpc</code>中实现（proto自动生成），功能为<strong>根据远端Rpc请求，调用当前Rpc节点上发布的方法</strong></p><p><code>request</code>与<code>response</code>中包含了调用method的参数，<code>done</code>是执行完method后的回调函数，这里指定了<code>SendRpcResponse</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buffer, muduo::Timestamp receive_time)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;OnMessage&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收远端调用的字节流</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">    <span class="comment">// ArrayInputStream: 将字节流包装为一个可读取的输入溜</span></span><br><span class="line">    google::protobuf::<span class="function">io::ArrayInputStream <span class="title">raw_input</span><span class="params">(recv_buf.data(), recv_buf.size())</span></span>;</span><br><span class="line">    <span class="comment">// CodedInputStream: 提供高效的二进制流解析工具</span></span><br><span class="line">    google::protobuf::<span class="function">io::CodedInputStream <span class="title">coded_input</span><span class="params">(&amp;raw_input)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取4字节的header_size</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size&#123;&#125;;</span><br><span class="line">    coded_input.<span class="built_in">ReadVarint32</span>(&amp;header_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size的值读取header_str，并对其反序列化，得到Rpc请求的详细信息（既服务名、方法名、参数大小）</span></span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    Krpc::RpcHeader krpcHeader;</span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line">    <span class="comment">// 设置读取规则，读取header_str</span></span><br><span class="line">    google::protobuf::io::CodedInputStream::Limit msg_limit = coded_input.<span class="built_in">PushLimit</span>(header_size);</span><br><span class="line">    coded_input.<span class="built_in">ReadString</span>(&amp;rpc_header_str, header_size);</span><br><span class="line">    <span class="comment">// 恢复规则，便于之后安全地读取其他数据</span></span><br><span class="line">    coded_input.<span class="built_in">PopLimit</span>(msg_limit);</span><br><span class="line">    <span class="comment">// 反序列化，解析KrpcHeader</span></span><br><span class="line">    <span class="keyword">if</span>(krpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        service_name = krpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = krpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = krpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: krpcHeader parse error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于调用Rpc方法的参数</span></span><br><span class="line">    std::string args_str;</span><br><span class="line">    <span class="comment">// 读取args_size长度的字符串</span></span><br><span class="line">    <span class="keyword">if</span>(!coded_input.<span class="built_in">ReadString</span>(&amp;args_str, args_size))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: read args error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Rpc服务端中搜索service对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> sit = m_services.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="keyword">if</span>(sit == m_services.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&quot; is no exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mit = sit-&gt;second.method_map.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == sit-&gt;second.method_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is no exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取服务对象与方法对象</span></span><br><span class="line">    google::protobuf::Service* service = sit-&gt;second.service;</span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor* method = mit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成Rpc方法调用的请求（request）和响应（response）</span></span><br><span class="line">    <span class="comment">// 通过 GetRequestPrototype，可以根据方法描述符动态获取对应的请求消息类型，并New（）实例化该类型的对象</span></span><br><span class="line">    google::protobuf::Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NewCallback函数会返回一个google::protobuf::Closure类的对象</span></span><br><span class="line">    <span class="comment">// Closure类对象相当于一个闭包，它捕获了一个成员对象的成员函数(SendRpcResponse)，以及这个成员函数需要的参数(conn、response)）</span></span><br><span class="line">    google::protobuf::Closure* done = google::protobuf::<span class="built_in">NewCallback</span>&lt;KrpcProvider,</span><br><span class="line">                                                                    <span class="type">const</span> muduo::net::TcpConnectionPtr&amp;,</span><br><span class="line">                                                                    google::protobuf::Message*&gt;(<span class="keyword">this</span>, &amp;KrpcProvider::SendRpcResponse,</span><br><span class="line">                                                                                                conn,</span><br><span class="line">                                                                                                response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CallMethod在UserServiceRpc实现，功能为根据远端Rpc请求，调用当前Rpc节点上发布的方法</span></span><br><span class="line">    <span class="comment">// request与response中包含了调用method的参数，done是执行完method后的回调函数，这里指定了SendRpcResponse</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SendRpcResponse"><a href="#SendRpcResponse" class="headerlink" title="SendRpcResponse"></a>SendRpcResponse</h3><p>SendRpcResponse作为OnMessage中CallMethod的回调函数，在执行完远端Rpc调用的方法后调用。其功能是<strong>序列化响应信息，并通过send发送给Rpc客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 序列化响应字符串，并将其发送给Rpc调用方</span></span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Serialize Error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zookeeperutil"><a href="#zookeeperutil" class="headerlink" title="zookeeperutil"></a>zookeeperutil</h2><p><code>zookeeperutil</code>主要对zookeeper提供的一些api进行封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zookeeper/zookeeper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// zookeeper客户端，主要封装一些zookeeper相关的api</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZkClient</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZkClient</span>();</span><br><span class="line">    ~<span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zk客户端启动，连接zk服务器。封装zookeeper_init</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在zk服务器中根据path新建一个节点。封装zoo_create</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datalen, <span class="type">int</span> state = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的路径，获取znode节点值。封装zoo_get</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// zk客户端的句柄</span></span><br><span class="line">    <span class="type">zhandle_t</span>* m_zhandle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="global-watcher"><a href="#global-watcher" class="headerlink" title="global_watcher"></a>global_watcher</h3><blockquote><p>watcher机制</p></blockquote><p>global_watcher定义了一个全局的watcher观察器，当znode节点发生变化时，zk服务端会通过该回调函数通知zk客户端</p><p>这里的global_watcher只处理 type==ZOO_SESSION_EVENT &amp;&amp; state==ZOO_CONNECTED_STATE 的watcher事件。目的是<strong>保证Start()调用完成后zk客户端（即Rpc服务端）与zk服务器的连接已经建立完成了</strong></p><blockquote><p>为什么需要watcher机制提供保证？</p></blockquote><p>因为<strong>zk客户端与zk服务器的连接建立过程是异步的</strong>。zookeeper_mt库的zookeeper客户端使用了以下三个线程：</p><ul><li>主线程：用户调用API的线程。</li><li>IO线程：负责网络通信的线程。</li><li>completion线程：对于异步请求（Zookeeper中提供的异步API，一般都是以zoo_a开头的api）以及<strong>watcher的响应回调</strong>，io线程会发送给completion线程完成处理。</li></ul><p>主线程在zk客户端调用api后返回zk句柄，而此时IO线程可能还没有完成连接的建立。所以需要watcher机制配合条件变量来保证Start()调用结束前连接的建立。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局锁</span></span><br><span class="line">std::mutex cv_mutex;</span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="comment">// 标记zk客户端是否已经连接到zk服务器</span></span><br><span class="line"><span class="type">bool</span> isConnected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的watcher观察器，当节点发生变化时，zk服务端会通过该回调函数通知zk客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">global_watcher</span><span class="params">(<span class="type">zhandle_t</span>* zh, <span class="type">int</span> type, <span class="type">int</span> state, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">void</span>* watcher_ctx)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只处理 type==ZOO_SESSION_EVENT &amp;&amp; state==ZOO_CONNECTED_STATE 的watcher事件</span></span><br><span class="line">    <span class="keyword">if</span>(type == ZOO_SESSION_EVENT)&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == ZOO_CONNECTED_STATE)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;</span><br><span class="line">            <span class="comment">// 标记zk客户端已经与zk服务端建立连接</span></span><br><span class="line">            isConnected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒条件变量</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，初始化zk客户端句柄</span></span><br><span class="line">ZkClient::<span class="built_in">ZkClient</span>(): <span class="built_in">m_zhandle</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，关闭zk客户端句柄</span></span><br><span class="line">ZkClient::~<span class="built_in">ZkClient</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_zhandle != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">zookeeper_close</span>(m_zhandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zk客户端启动，连接zk服务器。封装zookeeper_init</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZkClient::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中获取zookeeper服务器的ip和端口</span></span><br><span class="line">    std::string host = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperip&quot;</span>);</span><br><span class="line">    std::string port = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperport&quot;</span>);</span><br><span class="line">    <span class="comment">// 拼接 ip + port</span></span><br><span class="line">    std::string conn_str = host + port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化zk对象，异步建立zk客户端（即Rpc服务端）与zk服务器的连接</span></span><br><span class="line">    m_zhandle = <span class="built_in">zookeeper_init</span>(conn_str.<span class="built_in">c_str</span>(), global_watcher, <span class="number">6000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_zhandle)&#123;</span><br><span class="line">        <span class="comment">// 初始化失败</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zookeeper_init error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待global_watcher回调通知连接已经建立完成(isConnected == true)</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 第二个参数用于防止虚假唤醒</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, []&#123;<span class="keyword">return</span> isConnected;&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeper_init success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在zk服务器中根据path新建一个节点。封装zoo_create</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZkClient::Create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datalen, <span class="type">int</span> state = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建znode节点，可以选择永久性节点还是临时性节点</span></span><br><span class="line">    <span class="type">char</span> path_buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(path_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指定的节点是否存在，只有不存在时才创建节点</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_exists</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == ZNONODE)&#123;</span><br><span class="line">        <span class="comment">// 创建指定path的znode节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, state, path_buffer, bufferlen);</span><br><span class="line">        <span class="keyword">if</span>(flag == ZOK)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;znode create success, path=&quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;znode create fail, path=&quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的路径，获取znode节点值。封装zoo_get</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(buffer);</span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_get</span>(m_zhandle, path, <span class="number">0</span>, buffer, &amp;bufferlen, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == ZOK)&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zoo_get error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KrpcController"><a href="#KrpcController" class="headerlink" title="KrpcController"></a>KrpcController</h2><p>KrpcController的主要作用是跟踪RPC方法调用的状态、错误信息并提供控制功能（如取消调用）。这里只实现了其最基本的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述Rpc调用的控制器，主要作用是跟踪RPC方法调用的状态、错误信息并提供控制功能（如取消调用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcController</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KrpcController</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置状态与错误信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前状态是否为错误</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_failed; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回错误信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="type">const</span> </span>&#123; m_errmsg; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态与错误信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFailed</span><span class="params">(<span class="type">const</span> std::string&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是一些还未实现的功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartCancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// RPC方法执行过程中的状态</span></span><br><span class="line">    <span class="type">bool</span> m_failed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC方法执行过程中的错误信息</span></span><br><span class="line">    std::string m_errmsg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">KrpcController::<span class="built_in">KrpcController</span>()</span><br><span class="line">    : <span class="built_in">m_failed</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_errmsg</span>(<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置状态与错误信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::Reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errmsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态与错误信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::SetFailed</span><span class="params">(<span class="type">const</span> std::string&amp; reason)</span></span>&#123;</span><br><span class="line">    m_failed = <span class="literal">true</span>;</span><br><span class="line">    m_errmsg = reason;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一些还未实现的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::StartCancel</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KrpcController::IsCanceled</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RPC客户端"><a href="#RPC客户端" class="headerlink" title="RPC客户端"></a>RPC客户端</h1><h2 id="KrpcChannel"><a href="#KrpcChannel" class="headerlink" title="KrpcChannel"></a>KrpcChannel</h2><blockquote><p>多态的应用</p></blockquote><p><code>UserServiceRpc_Stub</code>的构造函数必须传入一个<code>google::protobuf::RpcChannel</code>。所以我们必须自己实现一个<code>KrpcChannel</code>继承自<code>google::protobuf::RpcChannel</code> ，并实现它的<code>CallMethod</code>方法</p><blockquote><p><code>CallMethod</code>如何理解？</p></blockquote><ul><li><p><strong>客户端视角</strong>：<code>CallMethod</code> 是客户端存根（Stub）类调用的入口，负责将本地方法调用（如这里的<code>Login</code>）的参数序列化为网络传输格式，并通过网络发送给服务端（简单理解就是<strong>将本地方法调用转换为远程过程调用</strong>）</p><ul><li><p>客户端所有服务方法的调用最终都会转变为对<code>CallMethod</code>的调用，如Login：</p><p><img src="https://atelieryu.xyz/elog/202503/1234ff92ae5a0fac62f2656fddd6f9d0.png" alt="UserServiceRpc_stub::Login源码"></p></li></ul></li><li><p><strong>服务端视角</strong>：服务端通过 <code>CallMethod</code> 接收请求后，根据消息头中的服务名和方法名路由到具体的服务实现，并触发本地方法执行</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自google::protobuf::RpcChannel</span></span><br><span class="line"><span class="comment">// 目的是为了给客户端进行方法调用的时候，统一接收的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcChannel</span>: <span class="keyword">public</span> google::protobuf::RpcChannel&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">KrpcChannel</span>(<span class="type">bool</span> connectNow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">KrpcChannel</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写继承的CallMethod</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CallMethod</span><span class="params">(<span class="type">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::RpcController* controller, </span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Message* response, </span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Closure* done)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 建立与Rpc服务端的连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">newConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">uint16_t</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向zookeeper服务器查询服务方法对应的Rpc服务端ip和端口</span></span><br><span class="line">    <span class="function">std::string <span class="title">QueryServiceHost</span><span class="params">(ZkClient* zkclient, <span class="type">const</span> std::string&amp; service_name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> std::string&amp; method_name, <span class="type">int</span>&amp; idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 客户端通信的socket</span></span><br><span class="line">    <span class="type">int</span> m_clientSock;</span><br><span class="line">    <span class="comment">// 服务名</span></span><br><span class="line">    std::string m_service_name; </span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    std::string m_method_name;</span><br><span class="line">    <span class="comment">// Rpc服务端的ip和端口</span></span><br><span class="line">    std::string m_ip;</span><br><span class="line">    <span class="type">uint16_t</span> m_port;</span><br><span class="line">    <span class="comment">// 划分服务器ip和端口的下标</span></span><br><span class="line">    <span class="type">int</span> m_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果已经处于连接状态（connectNow == True），则尝试与Rpc服务端进行连接</p><ul><li><strong>重试机制</strong>：当连接失败时，可以重试3次</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KrpcChannel::<span class="built_in">KrpcChannel</span>(<span class="type">bool</span> connectNow)</span><br><span class="line">    : <span class="built_in">m_clientSock</span>(<span class="number">-1</span>)</span><br><span class="line">    , <span class="built_in">m_idx</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!connectNow)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试与Rpc服务端进行连接，可以重试3次</span></span><br><span class="line">    <span class="keyword">auto</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(!rt &amp;&amp; cnt--)&#123;</span><br><span class="line">        rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CallMethod"><a href="#CallMethod" class="headerlink" title="CallMethod"></a>CallMethod</h3><p>CallMethod的主要工作：</p><ol><li>连接Rpc服务器 ：查询zookeeper服务器获取ip和端口 → 调用<code>newConnect</code>连接服务端</li><li>序列化请求：打包header_size、header_str、args_size、args_str</li><li>发送请求：<code>send</code></li><li>接受响应：<code>recv</code></li><li>解析响应数据</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcChannel::CallMethod</span><span class="params">(<span class="type">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::RpcController* controller, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::Message* response, </span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::Closure* done)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立与Rpc服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span>(m_clientSock == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 获取服务对象名和方法名</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::ServiceDescriptor* sd = method-&gt;<span class="built_in">service</span>();</span><br><span class="line">        m_service_name = sd-&gt;<span class="built_in">name</span>();</span><br><span class="line">        m_method_name = method-&gt;<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向zookeeper服务器查询服务对象和方法对应的服务端host</span></span><br><span class="line">        ZkClient zkCli;</span><br><span class="line">        zkCli.<span class="built_in">Start</span>();</span><br><span class="line">        std::string server_host = <span class="built_in">QueryServiceHost</span>(&amp;zkCli, m_service_name, m_method_name, m_idx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析host</span></span><br><span class="line">        m_ip = server_host.<span class="built_in">substr</span>(<span class="number">0</span>, m_idx);</span><br><span class="line">        m_port = <span class="built_in">atoi</span>(server_host.<span class="built_in">substr</span>(m_idx + <span class="number">1</span>, server_host.<span class="built_in">size</span>() - m_idx).<span class="built_in">c_str</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server ip: &quot;</span> &lt;&lt; m_ip &lt;&lt; <span class="string">&quot;, port: &quot;</span> &lt;&lt; m_port &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        <span class="type">bool</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">        <span class="keyword">if</span>(rt) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect server success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect server error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 连接建立失败时返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装KrpcHeader</span></span><br><span class="line">    Krpc::RpcHeader krpcHeader;</span><br><span class="line">    <span class="comment">// - service_name</span></span><br><span class="line">    krpcHeader.<span class="built_in">set_service_name</span>(m_service_name);</span><br><span class="line">    <span class="comment">// - method_name</span></span><br><span class="line">    krpcHeader.<span class="built_in">set_method_name</span>(m_method_name);</span><br><span class="line">    <span class="comment">// - args_size</span></span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line">    std::string args_str;</span><br><span class="line">    <span class="comment">// 序列化参数到字符串</span></span><br><span class="line">    <span class="keyword">if</span>(request-&gt;<span class="built_in">SerializeToString</span>(&amp;args_str))&#123;</span><br><span class="line">        args_size = args_str.<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置KrpcController的错误信息</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize request fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    krpcHeader.<span class="built_in">set_args_size</span>(args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将(header_size、header_str、args_size、args_str)打包到send_rpc_str</span></span><br><span class="line">    std::string send_rpc_str;</span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="comment">// 序列化KrpcHeader到字符串</span></span><br><span class="line">    <span class="keyword">if</span>(krpcHeader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str))&#123;</span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize rpc header fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流式写入send_rpc_str</span></span><br><span class="line">    &#123;</span><br><span class="line">        google::protobuf::<span class="function">io::StringOutputStream <span class="title">string_output</span><span class="params">(&amp;send_rpc_str)</span></span>;</span><br><span class="line">        google::protobuf::<span class="function">io::CodedOutputStream <span class="title">coded_output</span><span class="params">(&amp;string_output)</span></span>;</span><br><span class="line">        coded_output.<span class="built_in">WriteVarint32</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header_size));</span><br><span class="line">        coded_output.<span class="built_in">WriteString</span>(rpc_header_str);</span><br><span class="line">    &#125;</span><br><span class="line">    send_rpc_str += args_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送Rpc请求</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">send</span>(m_clientSock, send_rpc_str.<span class="built_in">c_str</span>(), send_rpc_str.<span class="built_in">size</span>(), <span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 发送请求失败</span></span><br><span class="line">        <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受Rpc请求的响应</span></span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="built_in">recv</span>(m_clientSock, recv_buf, <span class="built_in">sizeof</span>(recv_buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_size == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化解析响应数据</span></span><br><span class="line">    <span class="keyword">if</span>(!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size))&#123;</span><br><span class="line">        <span class="comment">// 解析失败</span></span><br><span class="line">        <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;parse&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;parse error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求-响应完毕，关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newConnect"><a href="#newConnect" class="headerlink" title="newConnect"></a>newConnect</h3><p>获得服务端的ip和port后，建立与Rpc服务端的TCP连接。常规的socket编程客户端connect流程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KrpcChannel::newConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">uint16_t</span> port)</span></span>&#123;</span><br><span class="line">    <span class="comment">// socket编程的客户端connect流程</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(clientfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;KrpcChannel::newConnect: connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_clientSock = clientfd;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QueryServiceHost"><a href="#QueryServiceHost" class="headerlink" title="QueryServiceHost"></a>QueryServiceHost</h3><p>向zookeeper服务器查询服务方法对应的Rpc服务端的host</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">KrpcChannel::QueryServiceHost</span><span class="params">(ZkClient* zkclient, <span class="type">const</span> std::string&amp; service_name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::string&amp; method_name, <span class="type">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">    std::string method_path = <span class="string">&#x27;/&#x27;</span> + service_name + <span class="string">&#x27;/&#x27;</span> + method_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上锁从zookeeper获取Rpc服务器host，保证多线程情况下每一个线程都能拿到信息</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    std::string server_host = zkclient-&gt;<span class="built_in">GetData</span>(method_path.<span class="built_in">c_str</span>());</span><br><span class="line">    lock.<span class="built_in">unlock</span>();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断host合法性</span></span><br><span class="line">    <span class="keyword">if</span>(server_host == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; method_path &lt;&lt; <span class="string">&quot; is no exist! \n&quot;</span>;</span><br><span class="line">        <span class="comment">// 不能返回空字符串，否则后续substr会出错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以&quot;:&quot;为分隔符分隔ip和port</span></span><br><span class="line">    idx = server_host.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; method_path &lt;&lt; <span class="string">&quot; address is invalid! \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端主函数"><a href="#客户端主函数" class="headerlink" title="客户端主函数"></a>客户端主函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcChannel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rpc客户端远端调用Rpc服务端的服务方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_request</span><span class="params">(<span class="type">int</span> thread_id, std::atomic&lt;<span class="type">int</span>&gt;&amp; success_cnt, std::atomic&lt;<span class="type">int</span>&gt;&amp; fail_cnt)</span></span>&#123;</span><br><span class="line">    <span class="function">Kuser::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(<span class="keyword">new</span> KrpcChannel(<span class="literal">false</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Rpc请求参数</span></span><br><span class="line">    Kuser::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">    request.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建Rpc响应参数</span></span><br><span class="line">    Kuser::LoginResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程调用Login方法</span></span><br><span class="line">    KrpcController controller;</span><br><span class="line">    <span class="comment">// 这里Login实际就是通过KrpcChannel::CallMethod间接调用的</span></span><br><span class="line">    stub.<span class="built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 读取响应</span></span><br><span class="line">    <span class="keyword">if</span>(controller.Failed)&#123;</span><br><span class="line">        <span class="comment">// 调用失败</span></span><br><span class="line">        std::cout &lt;&lt; controller.<span class="built_in">ErrorText</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(response.<span class="built_in">result</span>().<span class="built_in">errcode</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Rpc login response success: &quot;</span> &lt;&lt; response.<span class="built_in">success</span>() &lt;&lt; std::endl;</span><br><span class="line">            ++success_cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Rpc login response success: &quot;</span> &lt;&lt; response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>() &lt;&lt; std::endl;</span><br><span class="line">            ++fail_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 程序启动后，调用KrpcApplication类进行初始化</span></span><br><span class="line">    KrpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程配置属性</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> thread_cnt = <span class="number">1000</span>;        <span class="comment">// 并发线程数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> request_per_thread = <span class="number">10</span>;  <span class="comment">// 每个线程发送的请求数</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">success_cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">fail_cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序开始时间</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多线程并发测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_cnt; ++i)&#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([argc, argv, i, &amp;success_cnt, &amp; fail_cnt]()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; request_per_thread; ++j)&#123;</span><br><span class="line">                <span class="built_in">send_request</span>(i, success_cnt, fail_cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序结束时间，并计算程序执行时间</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; elapsed = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出统计结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total requests: &quot;</span> &lt;&lt; thread_cnt * request_per_thread &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success count: &quot;</span> &lt;&lt; success_cnt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fail count: &quot;</span> &lt;&lt; fail_cnt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time: &quot;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::end;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;QPS: &quot;</span> &lt;&lt; (thread_cnt * request_per_thread) / elapsed.<span class="built_in">count</span>() &lt;&lt; std::endl;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="send-request"><a href="#send-request" class="headerlink" title="send_request"></a>send_request</h3><p>客户端通过<code>send_request</code> 远端调用<code>Login</code>方法</p><h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><p>进行Rpc框架的多线程并发测试</p><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>分别运行服务端、客户端即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.在example文件夹和src文件夹中为proto文件生成.h和.cc文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.回到项目根目录，使用以下命令编译生成可执行文件</span></span><br><span class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j$&#123;nproc&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.进入bin文件夹，在不同会话中分别运行server和client</span></span><br><span class="line">./server -i ./test.conf</span><br><span class="line">./client -i ./test.conf</span><br></pre></td></tr></table></figure><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul><li>测试平台：阿里云服务器</li><li>操作系统：Ubuntu 22.04</li><li>CPU：2核</li><li>内存：2G</li><li>硬盘：40G</li></ul><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ul><li><p>并发线程数<code>200</code>，每个线程发送的请求数<code>10</code>：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Total requests: 2000</span><br><span class="line">Success count: 2000</span><br><span class="line">Fail count: 0</span><br><span class="line">Elapsed time: 10.4225 seconds</span><br><span class="line">QPS: 191.892</span><br></pre></td></tr></table></figure></li><li><p>并发线程数<code>1000</code>，每个线程发送的请求数<code>10</code>：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Total requests: 10000</span><br><span class="line">Success count: 10000</span><br><span class="line">Fail count: 0</span><br><span class="line">Elapsed time: 79.2326 seconds</span><br><span class="line">QPS: 126.21</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;RPC简介&quot;&gt;&lt;a href=&quot;#RPC简介&quot; class=&quot;headerlink&quot; title=&quot;RPC简介&quot;&gt;&lt;/a&gt;RPC简</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://atelieryu.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="后端" scheme="https://atelieryu.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="RPC" scheme="https://atelieryu.site/tags/RPC/"/>
    
    <category term="Protobuf" scheme="https://atelieryu.site/tags/Protobuf/"/>
    
    <category term="C++" scheme="https://atelieryu.site/tags/C/"/>
    
    <category term="分布式" scheme="https://atelieryu.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf简易使用</title>
    <link href="https://atelieryu.site/posts/522b2664.html"/>
    <id>https://atelieryu.site/posts/522b2664.html</id>
    <published>2025-03-17T01:48:00.000Z</published>
    <updated>2025-03-19T02:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info modern"><p>ProtoBuf提供对数据的序列化和反序列化，ProtoBuf可以用于结构化数据的串行序列化，并且以Key-Value格式存储数据，因为采用二进制格式，所以序列化出来的数据比较少，作为网络传输的载体效率很高</p></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://protobuf.com.cn/programming-guides/proto3/">proto3官方教程</a></li><li><a href="https://subingwen.cn/cpp/protobuf/">参考博客</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="源码下载与安装"><a href="#源码下载与安装" class="headerlink" title="源码下载与安装"></a>源码下载与安装</h2><ul><li><a href="https://github.com/protocolbuffers/protobuf/releases">github源代码下载地址</a></li><li><a href="https://github.com/protocolbuffers/protobuf/releases">3.21.12版本安装较为简单</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 protobuf 3.21.12 为例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自行下载源码包, 解压缩</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf protobuf-cpp-3.21.12.tar.gz</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到解压目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-3.21.12/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建并安装</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure         <span class="comment"># 检查安装环境, 生成 makefile</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make                <span class="comment"># 编译</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> make install   <span class="comment"># 安装</span></span></span><br></pre></td></tr></table></figure><h3 id="动态库链接失败处理"><a href="#动态库链接失败处理" class="headerlink" title="动态库链接失败处理"></a>动态库链接失败处理</h3><p>可以使用<code>$ protoc --version</code>测试是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试时发现动态库链接失败</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --version</span></span><br><span class="line">protoc: error while loading shared libraries: libprotoc.so.32: cannot open shared object file: No such file or directory</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法1：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find指令查找动态库路径</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> find /usr/local/ -name libprotoc.so</span>     </span><br><span class="line">/usr/local/lib/libprotoc.so</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将查找到的目录添加到/etc/ld.so.conf配置文件中：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> vim /etc/ld.so.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尾部追加/usr/local/lib/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接使用ldconfig指令</span></span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处理完成后：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --version</span></span><br><span class="line">libprotoc 3.21.12</span><br></pre></td></tr></table></figure><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ol><li><p>确定数据格式，数据可简单可复杂，比如：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要序列化的数据</span></span><br><span class="line"><span class="comment">// 第一种: 单一数据类型</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种: 复合数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>创建一个新的文件, 文件名随意指定, 文件后缀为 .proto</p></li><li>根据protobuf的语法, 编辑.proto文件</li><li>使用 protoc 命令将 .proto 文件转化为相应的 C++ 文件<ul><li>源文件: xxx.pb.cc –&gt; xxx对应的名字和 .proto文件名相同</li><li>头文件: xxx.pb.h –&gt; xxx对应的名字和 .proto文件名相同</li></ul></li><li>需要将生成的c++文件添加到项目中, 通过文件中提供的类 API 实现数据的序列化/反序列化<blockquote><p>Protobuf与C++的类型对照</p></blockquote></li></ol><ul><li>几个主要注意点：<ul><li>C++中的string到Protobuf中统一使用bytes比较好</li><li>C++中的整型到Protobuf中为 int+size，如int→int32</li><li>C++中的结构体与类对应到Protobuf中为message（消息体）<ul><li>Protobuf中其他类型最终也都要封装到消息体里</li></ul></li></ul></li></ul><p><img src="https://atelieryu.xyz/elog/202503/406ba403b533f2b5dadcd79db8664f31.png" alt="image.png"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生成对应的.h和.c文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protoc &lt;proto文件路径&gt; --cpp_out=&lt;输出路径&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc Person.proto --cpp_out=./</span></span><br></pre></td></tr></table></figure><h3 id="repeated关键字"><a href="#repeated关键字" class="headerlink" title="repeated关键字"></a>repeated关键字</h3><ul><li>repeated标志对应的成员是动态数组</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>proto3 中的<strong>第一个枚举值必须为 0</strong>，第一个元素以外的元素值可以随意指定</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类型</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">0</span>;</span><br><span class="line">    Green = <span class="number">3</span>;<span class="comment">// 第一个元素以外的元素值可以随意指定</span></span><br><span class="line">    Yellow = <span class="number">6</span>;</span><br><span class="line">    Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在该文件中对要序列化的结构体进行描述</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 枚举类型</span></span><br><span class="line">    Color color = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proto文件的导入"><a href="#proto文件的导入" class="headerlink" title="proto文件的导入"></a>proto文件的导入</h3><ul><li>使用<code>import</code>语句在当前.ptoto中导入其它的.proto文件。这样就可以在一个.proto文件中引用并使用其它文件中定义的消息类型和枚举类型。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 使用另外一个proto文件中的数类型, 需要导入这个文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;Address.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在该文件中对要序列化的结构体进行描述</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加地址信息, 使用的是外部proto文件中定义的数据类型</span></span><br><span class="line">    Address addr = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><ul><li>在 Protobuf 中，可以使用package关键字来定义一个消息所属的包（package）。包是用于组织和命名消息类型的一种机制，<strong>类似于命名空间的概念</strong></li><li>在一个.proto文件中，可以通过在顶层使用package关键字来定义包：</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 添加命名空间 Dabing</span></span><br><span class="line"><span class="keyword">package</span> Dabing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址信息, 这个Address类属于命名空间: Dabing</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Address</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bytes</span> addr = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> number = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他.proto文件导入以上文件后，可以通过<code>Dabing.Address</code>使用该文件定义的消息体Address</li><li>.c文件使用该proto文件生成的对象时，通过<code>Dabing::Address</code>使用该文件定义的消息体</li></ul><h2 id="Protobuf-API"><a href="#Protobuf-API" class="headerlink" title="Protobuf API"></a>Protobuf API</h2><p>通过对象调用Protobuf API</p><h3 id="成员操作"><a href="#成员操作" class="headerlink" title="成员操作"></a>成员操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员的const版本（数组成员需要传入索引）</span></span><br><span class="line">&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员的可修改版本（数组成员需要传入索引）</span></span><br><span class="line"><span class="built_in">mutable_</span>&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置成员（数组成员需要传入索引）</span></span><br><span class="line"><span class="built_in">set_</span>&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空成员</span></span><br><span class="line"><span class="built_in">clear_</span>&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组成员的size</span></span><br><span class="line">&lt;成员名&gt;_size()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中添加成员</span></span><br><span class="line"><span class="built_in">add_</span>&lt;成员名&gt;()</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件目录: google\protobuf\message_lite.h</span></span><br><span class="line"><span class="comment">// --- 将序列化的数据 数据保存到内存中</span></span><br><span class="line"><span class="comment">// 将类对象中的数据序列化为字符串: C++风格的字符串, 参数是一个传出参数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToString</span><span class="params">(std::string* output)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将类对象中的数据序列化为字符串: C风格的字符串, 参数 data 是一个传出参数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToArray</span><span class="params">(<span class="type">void</span>* data, <span class="type">int</span> size)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 写磁盘文件, 只需要调用这个函数, 数据自动被写入到磁盘文件中</span></span><br><span class="line"><span class="comment">// -- 需要提供流对象/文件描述符关联一个磁盘文件</span></span><br><span class="line"><span class="comment">// 将数据序列化写入到磁盘文件中, c++ 风格</span></span><br><span class="line"><span class="comment">// ostream 子类 ofstream -&gt; 写文件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToOstream</span><span class="params">(std::ostream* output)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将数据序列化写入到磁盘文件中, c 风格</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToFileDescriptor</span><span class="params">(<span class="type">int</span> file_descriptor)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件目录: google\protobuf\message_lite.h</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromString</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromArray</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// istream -&gt; 子类 ifstream -&gt; 读操作</span></span><br><span class="line"><span class="comment">// wo ri</span></span><br><span class="line"><span class="comment">// w-&gt;写 o: ofstream , r-&gt;读 i: ifstream</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromIstream</span><span class="params">(std::istream* input)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromFileDescriptor</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info modern&quot;&gt;&lt;p&gt;ProtoBuf提供对数据的序列化和反序列化，ProtoBuf可以用于结构化数据的串行序列化，并且以Key-Value格式存储数据，因为采用二进制格式，所以序列化出来的数据比较少，作为网络传输的载体效率很高&lt;/p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://atelieryu.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="后端" scheme="https://atelieryu.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="RPC" scheme="https://atelieryu.site/tags/RPC/"/>
    
    <category term="Protobuf" scheme="https://atelieryu.site/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>2025一月番追番记录</title>
    <link href="https://atelieryu.site/posts/bb92517d.html"/>
    <id>https://atelieryu.site/posts/bb92517d.html</id>
    <published>2025-03-16T09:24:00.000Z</published>
    <updated>2025-03-30T04:09:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info modern"><p>食用说明</p></div><ol><li>本文更偏向追番体验的记录，可能与补番体验略有不同</li><li>本文评分体系近似bangumi，以下为分数区间参考含义<ul><li>>9：全人类都应该来看</li><li>>8：必看神作</li><li>>7：值得一看</li><li>>6：闲的没事可以看</li><li>>5：平平无奇</li><li>&lt;5：献给小众赤石爱好者的一封情书</li></ul></li><li>本文完全由个人主观构成，没有客观</li></ol><h1 id="2025一月番简评"><a href="#2025一月番简评" class="headerlink" title="2025一月番简评"></a>2025一月番简评</h1><h2 id="8分段"><a href="#8分段" class="headerlink" title="8分段"></a>8分段</h2><h3 id="金牌得主"><a href="#金牌得主" class="headerlink" title="金牌得主"></a>金牌得主</h3><p><img src="https://atelieryu.xyz/elog/202503/dbe4984261187c28c97afa31519a9d10.jpg" alt="金牌得主"></p><blockquote><p>“花滑是见证奇迹的运动”</p></blockquote><p><del>没想到小女孩滑冰这么好看。</del>看一半没忍住把漫画全补完了，原作质量过于硬了（<del>原作得了mvp，engi就是躺赢狗，全人类都应该看这部漫画</del>），动画制作虽然还是差一些（比如部分文戏），但花滑部分是真用心做了。原作花滑的分镜固然震撼，但动画里能看到角色流畅地完成一个个花滑动作也是一种别样的享受。这部番的魅力很难用三言两语描述出来，总之都给我去看呀（</p><ul><li><strong>对于花滑的刻画</strong>：花滑真是优雅而又残酷啊。看了几集甚至主动去了解了一些花滑的规则，教练，我想学花滑！（</li><li><strong>对于人物的刻画</strong>：无论是主角还是每一位配角都有比较立体的刻画。尤其是主角的小祈和司教练，对过去的遗憾，对金牌的执着……，各种复杂的感情混杂在一起构成了人物。</li><li><strong>女女关系性</strong>：<del>小女孩也能有女女关系性？</del>漫画后期关系性发力后是真的美味啊（</li><li><strong>制作组对作品的热情</strong>：你是说，原作者厨的声优喜欢花滑，于是画了花滑为主题的漫画 → 八爷厨漫画主动请缨给漫画唱op → 花滑顶尖运动员羽生结弦欣赏八爷的才华同意合拍op的mv？就连平时和p9坐一桌的engi都开始发力了</li></ul><blockquote><p>综合打分——8</p><ul><li>剧情：8.5</li><li>人设：8</li><li>动画制作：7.6</li></ul></blockquote><h2 id="7分段"><a href="#7分段" class="headerlink" title="7分段"></a>7分段</h2><h3 id="喜欢的冲绳妹说方言"><a href="#喜欢的冲绳妹说方言" class="headerlink" title="喜欢的冲绳妹说方言"></a><strong>喜欢的冲绳妹说方言</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/7f4a23f11ed367ec74ef117ee2aeac12.jpg" alt="喜欢的冲绳妹说方言"></p><blockquote><p>人文纪录片 + 恋爱喜剧</p></blockquote><p>近几年还挺流行通过动漫来进行地区宣传的，虽然好看的也有一些（比如佐贺偶像是传奇），但看完真正让我产生“好想去这里旅游啊”的想法的这还是第一部。人文纪录片和恋爱喜剧两个都是我比较喜欢的类型，本季个人最佳大脑按摩番。</p><ul><li><strong>人文纪录片</strong>：剧中把各种因为文化、自然环境等因素产生的习俗差异，自然地融入了角色的日常交流中。与其说是在地区宣传中加入角色互动，不如说是通过角色互动中自然产生的交流gap来科普地区特色，加上段子情节设计的也都挺有趣，看的乐呵的同时还能学到不少异域豆知识。</li><li><strong>恋爱喜剧</strong>：<del>女二好可爱呀好可爱呀。本来我对于黑皮是拒绝的，但女二真的好可爱啊（本季第二喜欢的女角色）</del>。男主喜欢女主，女二喜欢男主，看起来扭曲的设定实际却异常清爽（因为女二一个人贡献了全片90%以上的恋爱桥段），看女二一直自我拉扯还是挺有趣的（听漫画党说后面女二有望反杀女主，希望是真的）。</li></ul><blockquote><p>综合打分——7.6</p><ul><li><del>剧情</del>有趣度：7.7</li><li>人设：7.7（7.2 女二再加0.5）</li><li>动画制作：7.2</li></ul></blockquote><h3 id="群花绽放，彷如修罗"><a href="#群花绽放，彷如修罗" class="headerlink" title="群花绽放，彷如修罗"></a><strong>群花绽放，彷如修罗</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/e73e378e85ae3f374b5a816e84a46b0e.jpg" alt="群花绽放，彷如修罗"></p><blockquote><p>青春+社团活动+苦呀西</p><ul><li><strong>有点尬的朗读演出</strong>：说实在朗读这个题材是真不太能get到，平时没接触过这个领域，单纯听也听不出名堂（毕竟天天听各种专业声优的配音）。制作组选择用领域展开这种方式表现朗读在我看来是有点尬的，所以朗读方面对我来讲是减分项。</li><li><strong>意外的文戏水平</strong>：这番在文戏上的刻画倒是渐入佳境，特别是在三四集左右进入各个部员的个人回，每集都看的挺舒服的。每个人都有各自的追求和心结，但又不拧巴。第九集的重女登场更是为我提供了不少乐子。</li><li><strong>可爱的女主</strong>：本番还贡献了本季度我最喜欢的女主（<del>花奈像只小动物一样，真的好可爱呀好可爱呀好可爱呀</del>）</li></ul></blockquote><p><img src="https://atelieryu.xyz/elog/202503/1c1b2dc84f2e71b63751487b5e3a18fa.png" alt="花奈可爱捏"></p><blockquote><p>综合打分——7.6</p><ul><li>剧情：7.5</li><li>人设：8（7.5女主再加0.5）</li><li>动画制作：7.5</li></ul></blockquote><h3 id="一杆青空"><a href="#一杆青空" class="headerlink" title="一杆青空"></a>一杆青空</h3><p><img src="https://atelieryu.xyz/elog/202503/84b2ab9241b002fe2da88dea8091d697.jpg" alt="一杆青空"></p><blockquote><p>你们三个把日子过好比啥都重要</p></blockquote><p>本来对高尔夫也没啥兴趣（刻板印象：中年有钱大叔们谈生意的娱乐活动），结果看着看着居然能get到一点乐趣了。</p><p>算向山进发/摇曳露营类型片？看着比较空气系但却并不无聊。主角团三人关系的文戏刻画意外地出色（跟一家三口似的）。看美少女们开开心心做点啥真是治愈啊，没有任何阴暗的东西，大家都只是纯粹地享受这个运动，享受朋友间共度的时光，每集看完都心里暖暖的。本季第二大脑按摩番，最后完结看着特殊ed是真不舍啊。</p><p>此外女主也挺可爱的</p><p><img src="https://atelieryu.xyz/elog/202503/821b49634dc4ee2008d20f7ec8eed59e.png" alt="美波可爱捏"></p><blockquote><p>综合评分——7.4</p><ul><li>日常感：7.4</li><li>人设：7.4</li><li>动画制作：7</li></ul></blockquote><h3 id="中年大叔转生恶役大小姐"><a href="#中年大叔转生恶役大小姐" class="headerlink" title="中年大叔转生恶役大小姐"></a>中年大叔转生恶役大小姐</h3><p><img src="https://atelieryu.xyz/elog/202503/76d5a1d2eae80ad8a1b8bd91951e84cb.jpg" alt="中年大叔转生恶役大小姐"></p><blockquote><p>体制内老干部的优雅与从容</p></blockquote><p>恶役系除了第一部猴王其他都没看完，几乎都是一个模板套出来的，导致越看越觉得土。这部倒是有点特色，中年大叔转生，利用多年体制内混出来的情商俘获一群人心。段子设计的也挺好（怀疑作者真是中年体制内老干部），甚至设定里还有一丝悬疑味。每周打开前都觉得好土，但最后又都是开心地看完一集（</p><blockquote><p>综合打分——7.2</p><ul><li>有趣度：7.5</li><li>人设：6.8</li><li>动画制作：6.9</li></ul></blockquote><h2 id="6分段"><a href="#6分段" class="headerlink" title="6分段"></a>6分段</h2><h3 id="不想加班的公会柜台小姐单挑BOSS"><a href="#不想加班的公会柜台小姐单挑BOSS" class="headerlink" title="不想加班的公会柜台小姐单挑BOSS"></a>不想加班的公会柜台小姐单挑BOSS</h3><p><img src="https://atelieryu.xyz/elog/202503/f4bab2b9a92c88c3ffe0efd5ef15dc84.jpg" alt="不想加班的公会柜台小姐单挑BOSS"></p><blockquote><p>她太喜欢当公务员了</p></blockquote><p>女主实在是太爱国了，明明随手打一个boss的报酬就够躺平好久，但她还是选择了天天加班当公务员，除了爱国想不出别的理由（</p><p>经典凤傲天番，看点是同类型中不错的制作水平（cw你有空做这个不如早点凑齐人手把我孤独摇滚第二季吐出来）和无处不在的女主大腿特写（上面的宣传图就能看出端倪了吧）。总之不带大脑1.5倍速看还算能看</p><blockquote><p>综合评分——6.2</p><ul><li>剧情：5.2</li><li>人设：6.5</li><li>动画制作：7</li></ul></blockquote><h2 id="4分段"><a href="#4分段" class="headerlink" title="4分段"></a>4分段</h2><h3 id="颂乐人偶（BanG-Dream-Ave-Mujica）"><a href="#颂乐人偶（BanG-Dream-Ave-Mujica）" class="headerlink" title="颂乐人偶（BanG Dream! Ave Mujica）"></a>颂乐人偶（BanG Dream! Ave Mujica）</h3><p><img src="https://atelieryu.xyz/elog/202503/04ea7b35fd43ab92229f73fcea9b1a18.jpg" alt="Mujica"></p><blockquote><p>唉，人偶</p></blockquote><p>虽然想到大概率会翻车，但能烂到这种程度是真没想到。<del>我又幻想了，幻想独角兽老师归来重置母鸡卡，负责全部集数的脚本，所有爆点都处理的酣畅淋漓，剧本完成度甚至超越前作MyGo，一举拿下2025年度动画</del></p><ul><li><strong>逻辑混乱的剧情</strong>：团炸的莫名其妙，重组的也莫名其妙，角色性格转变的也莫名其妙。能看出很多地方剧情大纲是没大问题了，但具体实施到细节就充满了随意与混乱。</li><li><strong>崩坏无常的人设</strong>：角色没一个是人：只对熟人哈气的多重人格大祥，真多重人格的精神病睦、让30个乐队倒大霉的信用复读机海玲、强制soulmate的喵梦、地上狗爬的初华。编剧未免过于不爱惜自己笔下的角色了</li><li><strong>毫无底线的炒作</strong>：制作组没那实力又想炒波大的。前几集每集结尾都在炒，然后下一集开头又轻轻放下；中间几集围绕一个多重人格的烂活硬炒几集，还把前作角色的人设给整崩了；最后几集没活了又炒出个二次元雷雨。更过分的是这些炒作设定对剧情推进和人物塑造几乎没有贡献。评价是为了热度连🐎都不要了。</li></ul><p>（为什么13集的live又做的这么出色，不敢想要是能忘记前面的抽象剧情这集得看的多爽。欧内该，ob一串字母大人，让我忘记一切吧😭）</p><p><img src="https://atelieryu.xyz/elog/202503/bd8b81f3b85440da67c280b05d586cbb.png" alt="让我忘记一切吧"></p><blockquote><p>综合评分——4.2</p><ul><li>剧情：3</li><li>人设：3</li><li>动画制作：7.3</li></ul></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://atelieryu.xyz/elog/202503/5bc14bd1a2dea71b40ea2ff3f912f073.png" alt="2025冬季番"></p><p>以为只是个过渡季，没想到黑马还挺多的，追番体验大概如上吧，比其往年平淡的一月，这季度看的还是比较开心的，有几部番甚至让我找回了那种完结时心里空落落的感觉</p><p>还有几部续作，比如百人女友、异修罗、石纪元，准备之后再补。上季度看一半搁置的甘神家和青之箱有空可能也会补回来。</p><p>（唉，mujica带给我的失望是真的，可追番过程每周磕假药溜二创带给我的快乐也是真的。或许这回它烂了，但下次碰到这类原创番我肯定还会追的，毕竟长颈鹿渴望的永远是无法预测的命运之舞台呀。）</p><p><img src="https://atelieryu.xyz/elog/202503/065352e21308516717b70d2f5f16cec5.png" alt="欧内该"></p><p><img src="https://atelieryu.xyz/elog/202503/3be78d9b2545dc33c7dfe5c8e1bf24ed.png" alt="瓦塔西"></p><p>（什么？还有续作？豪赤！再来一份！）</p><h1 id="2025四月番前瞻"><a href="#2025四月番前瞻" class="headerlink" title="2025四月番前瞻"></a>2025四月番前瞻</h1><p>度过了较为平淡的一月，四月就热闹起来了。数了数感兴趣的居然有16部</p><h3 id="夏日口袋"><a href="#夏日口袋" class="headerlink" title="夏日口袋"></a>夏日口袋</h3><p><img src="https://atelieryu.xyz/elog/202503/b750ead19b9bb7a15fc51e8d9a5f1302.jpg" alt="夏日口袋"></p><p>夏季是我最喜欢的季节，暑假是一年中我最喜欢的时期，而Summer Pocket则是我认为对暑期感描写的最好的作品之一。原作是我最喜欢的Gal之一，希望feel能给点劲把它做好吧。重振Gal改荣光（</p><h3 id="机动战士高达GQuuuuuuX"><a href="#机动战士高达GQuuuuuuX" class="headerlink" title="机动战士高达GQuuuuuuX"></a><strong>机动战士高达GQuuuuuuX</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/441462356fded410db4427fc91d5dbe3.jpg" alt="机动战士高达GQuuuuuuX"></p><p>庵野秀明编剧 + 吉翁反杀联邦if线 + 过于标新立异的机设，反正噱头是已经拉满了，看肯定是会看的，但感觉翻车率拉满（得有个70%+的翻车率吧）。是时候把之前坑的Z高达补完了</p><h3 id="LAZARUS"><a href="#LAZARUS" class="headerlink" title="LAZARUS"></a><strong>LAZARUS</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/d58312a81eb7f7be7e9c31a239ec864f.jpg" alt="LAZARUS"></p><p>渡边信一郎导演的新作 + 近年来稳定高质量的Mappa + 听说已经完成制作的超充裕工期，同样噱头拉满，但感觉比GQuuuX稳多了（至少能保住下限吧？）。</p><h3 id="赛马娘-芦毛灰姑娘"><a href="#赛马娘-芦毛灰姑娘" class="headerlink" title="赛马娘 芦毛灰姑娘"></a><strong>赛马娘 芦毛灰姑娘</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/eb1f0a3356127d4947278ebc864b88d8.jpg" alt="赛马娘 芦毛灰姑娘"></p><p>听漫画原作党说是赛马娘系列最优秀的作品，小栗帽也是日本人气断层领先的赛马，Cy应该会拿出全力做吧，顶尖之路和新时代之扉做的都挺好的，还是值得一看的（虽然看制作人员好像有点危险）</p><h3 id="魔女与使魔"><a href="#魔女与使魔" class="headerlink" title="魔女与使魔"></a>魔女与使魔</h3><p><img src="https://atelieryu.xyz/elog/202503/f7514468c2e15d5167a4124b69faf28b.jpg" alt="魔女与使魔"></p><p>原作是jump中坚之一，看pv表现挺好的，制作不错，pv里都有不少笑点，校园恋爱喜剧一直是我比较喜欢的类型，应该是会追下去的（希望别是鹿乃子ver2）</p><h3 id="mono女孩"><a href="#mono女孩" class="headerlink" title="mono女孩"></a>mono女孩</h3><p><img src="https://atelieryu.xyz/elog/202503/87704935c7a772bc38b7da56d34fa0af.jpg" alt="mono女孩"></p><p>摇曳露营代餐其一，摇曳露营原作者的另一部作品，好像是摄影为主题的。没啥好说的，先追着</p><h3 id="杂旅"><a href="#杂旅" class="headerlink" title="杂旅"></a>杂旅</h3><p><img src="https://atelieryu.xyz/elog/202503/edda6f86ef1858c336da8a41b8c8a766.jpg" alt="杂旅"></p><p>摇曳露营代餐其二，以旅行为主题的作品，可能成为日本旅游guidebook，没啥好说的，先追着</p><h3 id="时光流逝-饭菜依旧美味"><a href="#时光流逝-饭菜依旧美味" class="headerlink" title="时光流逝 饭菜依旧美味"></a>时光流逝 饭菜依旧美味</h3><p><img src="https://atelieryu.xyz/elog/202503/efbc9571de508608f09524eb2076b0f6.jpg" alt="时光流逝 饭菜依旧美味"></p><p>PA的原创，以美食为主题，PA制作的下限一直都挺高，感觉是每一部都在认真做，但之前几部作品总是看着看着就觉得无聊弃坑了。这部也准备先追几集看看吧，毕竟PA的美少女画的都挺可爱的（</p><h3 id="忍者与杀手二人组的日常生活"><a href="#忍者与杀手二人组的日常生活" class="headerlink" title="忍者与杀手二人组的日常生活"></a>忍者与杀手二人组的日常生活</h3><p><img src="https://atelieryu.xyz/elog/202503/09116b1547639eceacb0964139a146cd.jpg" alt="忍者与杀手二人组的日常生活"></p><p><del>我超忍杀二</del>看pv女角色都蛮可爱的，但好像是主打反差的（指可爱的妹子下一集就惨死，<del>这也是末世之法的一个侧面</del>），看多了轻松日常番来点这类番调节一下也挺好？</p><h3 id="摇滚乐是淑女的嗜好"><a href="#摇滚乐是淑女的嗜好" class="headerlink" title="摇滚乐是淑女的嗜好"></a>摇滚乐是淑女的嗜好</h3><p><img src="https://atelieryu.xyz/elog/202503/5f397b019511285d4744731e99cddc39.jpg" alt="摇滚乐是淑女的嗜好"></p><p>最新的少女乐队番，看点好像是少女们边摇滚边颜艺彪垃圾话，emmm，这就是摇滚吗，总之先看几集吧</p><h3 id="启示录酒店"><a href="#启示录酒店" class="headerlink" title="启示录酒店"></a>启示录酒店</h3><p><img src="https://atelieryu.xyz/elog/202503/bfd937ede8da9855f132a7f05fb2cb40.jpg" alt="启示录酒店"></p><p>Cy的一部原创番，看设定有点像几年前的星之梦，但看pv2又有点闹腾，可能会是那种欢乐日常中带点刀的单元剧？制作看起来不错，期待表现（Cy主力不会在这吧）</p><h3 id="搞笑漫画日和-第5期"><a href="#搞笑漫画日和-第5期" class="headerlink" title="搞笑漫画日和 第5期"></a>搞笑漫画日和 第5期</h3><p><img src="https://atelieryu.xyz/elog/202503/9fca3b749d3f31e6217e171e45f373a0.jpg" alt="搞笑漫画日和 第5期"></p><p>这是真童年了啊，入动画坑前就看过的作品，产出的不少梗到今天还有生命力。不知道隔了这么久的动画化还是不是内味（也有可能我的口味变了，导致看不进去了，唉）</p><h3 id="乡下大叔成为剑圣"><a href="#乡下大叔成为剑圣" class="headerlink" title="乡下大叔成为剑圣"></a>乡下大叔成为剑圣</h3><p><img src="https://atelieryu.xyz/elog/202503/beb32691702746a2cd938a72a367afdb.jpg" alt="乡下大叔成为剑圣"></p><p>之前吃安利看过原作，剧情比较平庸，但画的分镜和动作相当出色，角色的动作真的能让人感受到武术的美感。动画不知道能不能体现好</p><h3 id="阳光马达棒球场"><a href="#阳光马达棒球场" class="headerlink" title="阳光马达棒球场"></a>阳光马达棒球场</h3><p><img src="https://atelieryu.xyz/elog/202503/2b670f8bceef549d680cc1f41ada8f37.jpg" alt="阳光马达棒球场"></p><p>好像讲的不是棒球，而是围绕棒球的各类人群（看客、售货员、解说等）的群像剧。有点兴趣，感觉有成为泛鸽鸽每周六直播间下播番的潜力</p><h3 id="拜托请穿上-鹰峰同学"><a href="#拜托请穿上-鹰峰同学" class="headerlink" title="拜托请穿上 鹰峰同学"></a>拜托请穿上 鹰峰同学</h3><p><img src="https://atelieryu.xyz/elog/202503/eca1c2b813c2442060670f8deb5a0181.jpg" alt="拜托请穿上 鹰峰同学"></p><p>福利番一号，还有表里版。十年前我还觉得看这种卖肉番不如去看里番，而在现在里番业界不断走下坡，真得表番来当里番代餐了。这部人设还挺好看的，可能会看？</p><h3 id="快藏起来-玛琪娜同学"><a href="#快藏起来-玛琪娜同学" class="headerlink" title="快藏起来 玛琪娜同学"></a>快藏起来 玛琪娜同学</h3><p><img src="https://atelieryu.xyz/elog/202503/a9e3bbafe2b4048dd06161a3c16fca65.jpg" alt="快藏起来 玛琪娜同学"></p><p>福利番二号，性x机器人，总觉得能看到未来（</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info modern&quot;&gt;&lt;p&gt;食用说明&lt;/p&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;本文更偏向追番体验的记录，可能与补番体验略有不同&lt;/li&gt;
&lt;li&gt;本文评分体系近似bangumi，以下为分数区间参考含义&lt;ul&gt;
&lt;li&gt;&gt;9：全人类都应该来看&lt;</summary>
      
    
    
    
    <category term="ACGN" scheme="https://atelieryu.site/categories/ACGN/"/>
    
    
    <category term="追番记录" scheme="https://atelieryu.site/tags/%E8%BF%BD%E7%95%AA%E8%AE%B0%E5%BD%95/"/>
    
    <category term="动画" scheme="https://atelieryu.site/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>基于Elog的 Notion-hexo 同步方案</title>
    <link href="https://atelieryu.site/posts/3bcc203.html"/>
    <id>https://atelieryu.site/posts/3bcc203.html</id>
    <published>2025-03-16T03:37:00.000Z</published>
    <updated>2025-03-31T03:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客工具"><a href="#博客工具" class="headerlink" title="博客工具"></a>博客工具</h1><ul><li>写作平台：<a href="https://www.notion.so/">Notion</a></li><li>博客平台：<a href="https://hexo.io/">Hexo</a></li><li>博客主题：<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></li><li>博客文档同步：<a href="https://github.com/LetTTGACO/elog">Elog</a></li><li>原项目仓库：<a href="https://github.com/elog-x/notion-hexo">https://github.com/elog-x/notion-hexo</a></li></ul><h1 id="博客搭建指南"><a href="#博客搭建指南" class="headerlink" title="博客搭建指南"></a>博客搭建指南</h1><h2 id="Fork模板仓库"><a href="#Fork模板仓库" class="headerlink" title="Fork模板仓库"></a>Fork模板仓库</h2><p>将<a href="https://github.com/elog-x/notion-hexo">模板仓库</a> clone 到本地</p><h3 id="之前已经有博客的情况"><a href="#之前已经有博客的情况" class="headerlink" title="之前已经有博客的情况"></a>之前已经有博客的情况</h3><ol><li>使用旧博客文件<strong>覆盖</strong>博客仓库</li><li><p>修改<code>package.json</code>中的依赖：</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class="line">    &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line"><span class="addition">+   &quot;server&quot;: &quot;hexo clean &amp;&amp; hexo server&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;sync:local&quot;: &quot;elog sync -e .elog.env&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;elog:init&quot;: &quot;elog init&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;sync&quot;: &quot;elog sync&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;elog:clean&quot;: &quot;elog clean&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;7.3.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;@elog/cli&quot;: &quot;^0.14.0&quot;,</span></span><br><span class="line">    &quot;hexo&quot;: &quot;^7.0.0&quot;,</span><br><span class="line">    &quot;hexo-abbrlink&quot;: &quot;^2.2.1&quot;,</span><br><span class="line">    &quot;hexo-bilibili-bangumi&quot;: &quot;^1.10.8&quot;,</span><br><span class="line">    &quot;hexo-butterfly-categories-card&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-butterfly-clock-anzhiyu&quot;: &quot;^1.1.8&quot;,</span><br><span class="line">    &quot;hexo-butterfly-envelope&quot;: &quot;^1.0.15&quot;,</span><br><span class="line">    &quot;hexo-butterfly-footer-beautify&quot;: &quot;^1.0.6&quot;,</span><br><span class="line">    &quot;hexo-butterfly-tag-plugins-plus&quot;: &quot;^1.0.18&quot;,</span><br><span class="line">    &quot;hexo-butterfly-wowjs&quot;: &quot;^1.0.5&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-feed&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-search&quot;: &quot;^2.4.3&quot;,</span><br><span class="line">    &quot;hexo-generator-sitemap&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-kramed&quot;: &quot;^0.1.4&quot;,</span><br><span class="line"><span class="addition">+   &quot;hexo-renderer-marked&quot;: &quot;^6.0.0&quot;,</span></span><br><span class="line">    &quot;hexo-renderer-pug&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-tag-aplayer&quot;: &quot;^3.0.4&quot;,</span><br><span class="line">    &quot;hexo-theme-landscape&quot;: &quot;^1.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.9&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续后续操作</p></li></ol><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>在项目根目录下运行命令安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="新建-Elog-本地调试文件"><a href="#新建-Elog-本地调试文件" class="headerlink" title="新建 Elog 本地调试文件"></a><strong>新建 Elog 本地调试文件</strong></h2><ol><li>将<code>.elog.example.env</code>文件重命名为<code>.elog.env</code>，此文件将用于本地同步Notion 文档</li></ol><h2 id="配置-Notion-关键信息"><a href="#配置-Notion-关键信息" class="headerlink" title="配置 Notion 关键信息"></a>配置 Notion 关键信息</h2><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>使用 <a href="https://1874.notion.site/09ff9e1e141744c6af0a1f69d2a3d834?v=a09065f9266446afa745b475044daca6"><strong>Database 模板</strong></a> 创建数据库副本或增加必要属性到已有 Notion 数据库<ul><li>博客平台为Hexo时，可参考<a href="https://1874.notion.site/867486af567f4a8897427b15ffd10b3c?v=a25aec8e27d5415e8605e43034f822bd"><strong>elog-hexo-template</strong></a> 创建数据库副本或增加必要属性到已有 Notion 数据库</li></ul></li><li>创建 Integration Token，具体请参考 <a href="https://developers.notion.com/docs/create-a-notion-integration#create-your-integration-in-notion"><strong>Notion 官方教程</strong></a></li><li>将复制的数据库连接到刚创建的 Integration，具体请参考 <a href="https://developers.notion.com/docs/create-a-notion-integration#give-your-integration-page-permissions"><strong>Notion 官方教程</strong></a></li><li>获取数据库 DatabaseId</li></ol><p>按照<a href="https://elog.1874.cool/notion/gvnxobqogetukays#notion">文档提示</a>配置 Notion 并获取 <code>token</code> 和 <code>databaseId</code>，在本地<code>.elog.env</code>中写入</p><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOTION_TOKEN=获取的token</span><br><span class="line">NOTION_DATABASE_ID=获取的databaseId</span><br></pre></td></tr></table></figure><h3 id="配置Notion-Database"><a href="#配置Notion-Database" class="headerlink" title="配置Notion Database"></a>配置Notion Database</h3><p>示例：</p><p><img src="https://atelieryu.xyz/elog/202503/a2be76ee2e6a013e213586a7e524b722.png" alt="image.png"></p><p>Database字段：</p><ul><li><code>permalink</code>为文档的永久链接，例如<code>https://notion-hexo.vercel.app/notion-hexo/</code>，注意记得在结尾加上<code>/</code></li><li><code>categories</code>为文档的分类</li><li><code>tags</code> 为文档的标签</li><li><code>description</code>为主题配置中可选的文档描述</li></ul><h3 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h3><ol><li><p>登录Notion 网页版 =&gt;访问<a href="https://www.notion.so/my-integrations">My integrations</a> =&gt;New Integration =&gt; 生成 Internal Integration Token</p><p> <img src="https://atelieryu.xyz/elog/202503/2a01b8634fd5897a79a9fa367d6502c2.png" alt="image.png"></p></li><li><p>Internal Intergration Secret即为token</p><p> <img src="https://atelieryu.xyz/elog/202503/35735ef273abc3537dad0072dec232f5.png" alt="image.png"></p></li><li><p>在使用的Notion Database页面点击右上角设置→Connections，选择刚才创建的Integration</p><p> <img src="https://atelieryu.xyz/elog/202503/bc53f185657c5009ec62d22aafdb14ed.png" alt="image.png"></p></li></ol><p>其他注意事项：</p><ul><li>notion文章必须有封面（cover），否则同步会失败</li></ul><h3 id="获取DatabaseId"><a href="#获取DatabaseId" class="headerlink" title="获取DatabaseId"></a>获取DatabaseId</h3><p>图中url中红框部分（1b8a0f24b32980ca9c66cbc557236562）即为DatabaseId</p><p><img src="https://atelieryu.xyz/elog/202503/3ec5b264fea657120d4bf98a8801b77c.png" alt="029401505f8359601294e9d4af319792.png"></p><h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><p>在项目根目录运行同步命令，Notion Database中的文章就会被全部同步值本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run sync:local</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">elog sync -e .elog.env</span><br></pre></td></tr></table></figure><h1 id="Elog配置CloudFlare-R2图床"><a href="#Elog配置CloudFlare-R2图床" class="headerlink" title="Elog配置CloudFlare R2图床"></a>Elog配置CloudFlare R2图床</h1><p><a href="https://github.com/LetTTGACO/elog/tree/master/plugins/plugin-img-r2#readme">官方插件文档</a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a><strong>安装插件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @elog/plugin-img-r2</span><br></pre></td></tr></table></figure><h2 id="配置-elog-config-js"><a href="#配置-elog-config-js" class="headerlink" title="配置 elog.config.js"></a><strong>配置 elog.config.js</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elog.config.js</span></span><br><span class="line"><span class="keyword">const</span> r2 = <span class="built_in">require</span>(<span class="string">&#x27;@elog/plugin-img-r2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="attr">image</span>: &#123;</span><br><span class="line">    <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">plugin</span>: r2,</span><br><span class="line">    <span class="attr">r2</span>: &#123;</span><br><span class="line">      <span class="attr">accessKeyId</span>: process.<span class="property">env</span>.<span class="property">R2_ACCESSKEYID</span>,</span><br><span class="line">      <span class="attr">secretAccessKey</span>: process.<span class="property">env</span>.<span class="property">R2_SECRET_ACCESSKEY</span>,</span><br><span class="line">      <span class="attr">bucket</span>: process.<span class="property">env</span>.<span class="property">R2_BUCKET</span>,</span><br><span class="line">      <span class="attr">endpoint</span>: process.<span class="property">env</span>.<span class="property">R2_ENDPOINT</span>,</span><br><span class="line">      <span class="attr">host</span>: process.<span class="property">env</span>.<span class="property">R2_HOST</span>,</span><br><span class="line">      <span class="attr">prefixKey</span>: <span class="string">&#x27;elog-image-plugin-test&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置-elog-env文件"><a href="#配置-elog-env文件" class="headerlink" title="配置 .elog.env文件"></a>配置 .elog.env文件</h2><p>在 .elog.env 中插入以下信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .elog.env 配置R2 相关账号参数</span></span><br><span class="line"><span class="comment">#R2</span></span><br><span class="line"><span class="comment"># 访问密钥 ID</span></span><br><span class="line"><span class="string">R2_ACCESSKEYID=</span></span><br><span class="line"><span class="comment"># 机密访问密钥</span></span><br><span class="line"><span class="string">R2_SECRET_ACCESSKEY=</span></span><br><span class="line"><span class="string">R2_ENDPOINT=</span></span><br><span class="line"><span class="comment"># R2 需要使r2.dev子域供网络访问或者绑定自己的域名</span></span><br><span class="line"><span class="string">R2_HOST=</span></span><br><span class="line"><span class="string">R2_BUCKET=</span></span><br></pre></td></tr></table></figure><ul><li>R2_ACCESSKEYID、R2_SECRET_ACCESSKEY、R2_ENDPOINT：API令牌中查看</li><li>R2_HOST：生成的R2.dev子域 或 自己的域名</li><li>R2_BUCKET：存储桶的名称</li></ul><p><img src="https://atelieryu.xyz/elog/202503/cb3779952158c30a0a2591b0797040e9.png" alt="image.png"></p><p>令牌信息仅在创建令牌时显示一次，之后无法再次查看，如需查看只能选择轮转重新生成令牌信息。</p><p><img src="https://atelieryu.xyz/elog/202503/76cd80a3e9d22864fee2c756afaea01f.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客工具&quot;&gt;&lt;a href=&quot;#博客工具&quot; class=&quot;headerlink&quot; title=&quot;博客工具&quot;&gt;&lt;/a&gt;博客工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;写作平台：&lt;a href=&quot;https://www.notion.so/&quot;&gt;Notion&lt;/a&gt;&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="技术随记" scheme="https://atelieryu.site/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="elog" scheme="https://atelieryu.site/tags/elog/"/>
    
    <category term="notion" scheme="https://atelieryu.site/tags/notion/"/>
    
    <category term="hexo" scheme="https://atelieryu.site/tags/hexo/"/>
    
  </entry>
  
</feed>
