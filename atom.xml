<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yu的炼金工房</title>
  
  
  <link href="https://atelieryu.site/atom.xml" rel="self"/>
  
  <link href="https://atelieryu.site/"/>
  <updated>2025-03-25T03:23:00.000Z</updated>
  <id>https://atelieryu.site/</id>
  
  <author>
    <name>Yu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++实现轻量级RPC分布式网络通信框架</title>
    <link href="https://atelieryu.site/posts/ccad8bf.html"/>
    <id>https://atelieryu.site/posts/ccad8bf.html</id>
    <published>2025-03-18T12:38:00.000Z</published>
    <updated>2025-03-25T03:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><p>RPC（Remote Procedure Call）是一种使程序能够像调用本地函数一样调用远程服务的方法。它屏蔽了底层的通信细节，使得<strong>开发人员无需关注远程调用的复杂性，只需像操作本地方法一样调用远程方法</strong>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/T_Solotov/article/details/124107667?spm=1001.2014.3001.5501">参考博客</a></li><li><a href="https://github.com/youngyangyang04/Krpc">参考项目</a></li></ul><h2 id="项目仓库"><a href="#项目仓库" class="headerlink" title="项目仓库"></a>项目仓库</h2><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/YVollerei/RPC"><img src="https://github-readme-stats.vercel.app/api/pin/?username=YVollerei&repo=RPC&show_owner=true"/></a><h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><h2 id="框架流程图"><a href="#框架流程图" class="headerlink" title="框架流程图"></a>框架流程图</h2><p><img src="https://atelieryu.xyz/elog/202503/658296c43b32f9ef93f5847831247355.png" alt="image.png"></p><h2 id="代码调用流程"><a href="#代码调用流程" class="headerlink" title="代码调用流程"></a>代码调用流程</h2><p><img src="https://atelieryu.xyz/elog/202503/25f25fec56e09f89f5fd76fd8d2bcc2e.png" alt="image.png"></p><h3 id="三个主体"><a href="#三个主体" class="headerlink" title="三个主体"></a>三个主体</h3><ul><li><p><strong>zookeeper服务端</strong></p><ul><li>zooKeeper在这里作为服务方法的管理配置中心，负责管理服务方法提供者对外提供的服务方法</li><li>Rpc服务端与客户端的身份都是zookeeper客户端</li><li>zookeeper存储服务对象与服务方法的方式：</li></ul><p>  <img src="https://atelieryu.xyz/elog/202503/d9567a2a7c46ad22233b0c41cef598ff.png" alt="image.png"></p></li><li><p><strong>Rpc服务端</strong></p><ul><li>Rpc服务端需要向zookeeper注册服务对象与服务方法，注册的内容是本机上提供该服务的ip+端口</li><li>注册完服务后，启动epoll监听客户端的远端调用请求</li><li>接收到Rpc客户端的远端调用后，先对调用参数进行反序列化，再调用本地方法处理该调用，最后将处理结果包装为响应，序列化后发出</li></ul></li><li><p><strong>Rpc客户端</strong></p><ul><li>Rpc客户端需要先从zookeeper中查询提供目标服务的Rpc服务端ip与端口</li><li>查询到Rpc服务端的ip与端口向目标端口发起连接，之后就是send - recv的流程，区别是send前需要对请求内容进行序列化，recv后需要对响应内容进行反序列化</li></ul></li></ul><h1 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h1><p>定义了两个proto文件</p><h2 id="Krpcheader-proto"><a href="#Krpcheader-proto" class="headerlink" title="Krpcheader.proto"></a>Krpcheader.proto</h2><p>该文件定义了<strong>RPC调用的元数据头部</strong></p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Krpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RpcHeader</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> service_name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> method_name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint32</span> args_size = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>service_name：用于标识目标服务（如 <code>UserServiceRpc</code>）</li><li>method_name：用于标识目标方法（如 <code>Login</code>）</li><li>args_size：表示后续参数数据的字节长度，避免粘包问题</li></ul><p>服务端接收到请求后，通过service_name和method_name找到对应的服务</p><h2 id="user-proto"><a href="#user-proto" class="headerlink" title="user.proto"></a>user.proto</h2><p>该文件定义了<code>UserServiceRpc</code>服务，以及它的两个方法<code>Login</code>和<code>Register</code></p><p>可以根据具体需求改动<code>LoginRequest</code>和<code>RegisterRequest</code>中的参数</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Kuser;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制生成基于protobuf的通用RPC服务基类</span></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterRequest</span> &#123;</span><br><span class="line">    <span class="type">uint32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Register(RegisterRequest) <span class="keyword">returns</span>(RegisterResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Login和Register"><a href="#Login和Register" class="headerlink" title="Login和Register"></a>Login和Register</h3><ul><li>定义Login方法接收两个参数：name和pwd</li><li>定义Register方法接收三个参数：id、name、pwd</li></ul><h3 id="cc-generic-services"><a href="#cc-generic-services" class="headerlink" title="cc_generic_services"></a>cc_generic_services</h3><p>启用<code>cc_generic_services</code>后，proto会生成两个C++类</p><ul><li><code>UserServiceRpc</code>：callee需要继承此类并实现 <code>Login</code> 和 <code>Register</code> 方法</li><li><code>UserServiceRpc_Stub</code>：客户端存根类，由caller继承，通过 <code>RpcChannel</code> 发起调用</li></ul><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>调用以下命令生成proto文件对应的C++代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc user.proto -I ./ --cpp_out=./user</span><br></pre></td></tr></table></figure><p>生成的 user.h 和 user.cc 会被保存到 .&#x2F;user 文件夹中</p><h1 id="RPC服务端"><a href="#RPC服务端" class="headerlink" title="RPC服务端"></a>RPC服务端</h1><h2 id="服务端主文件Kserver-cpp"><a href="#服务端主文件Kserver-cpp" class="headerlink" title="服务端主文件Kserver.cpp"></a>服务端主文件Kserver.cpp</h2><p>主文件由UserService和main函数两部分组成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcProvider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端上的自定义UserService，继承自proto生成的UserServiceRpc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span>: <span class="keyword">public</span> Kuser::UserServiceRpc&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个版本执行Login的本地任务 </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd=&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写UserServiceRpc的虚函数</span></span><br><span class="line">    <span class="comment">// 这个版本的Login执行：接收远端调用 - 调用执行本地任务 - 写入响应 - 执行回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ::Kuser::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::Kuser::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Closure* done)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 接收远端调用的参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用重载版本，执行本地任务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入响应，参考user.proto中的定义</span></span><br><span class="line">        Kuser::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调（执行响应对象数据的序列化和网络发送，交给框架来完成）</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    KrpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider将UserService发布到rpc节点上</span></span><br><span class="line">    KrpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务发布节点。Run以后进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h3><p>UserService继承自proto文件生成的UserServiceRpc，为具体服务，其中定义了服务中Login方法的两个具体实现：</p><ul><li>一个版本的Login负责执行本地任务</li><li>一个版本的Login负责接收远端调用，之后调用重载版本执行本地任务，最后将执行结果写入响应，并阻塞等待回调</li></ul><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>main函数主要执行以下工作：</p><ol><li>调用框架的初始化操作，从配置文件中读取必要的配置信息</li><li>将上面定义的UserService发布到Rpc节点上</li><li>启动Rpc服务发布节点，阻塞等待远端客户端调用该服务</li></ol><h2 id="为服务端提供服务的类"><a href="#为服务端提供服务的类" class="headerlink" title="为服务端提供服务的类"></a>为服务端提供服务的类</h2><h3 id="KrpcApplication"><a href="#KrpcApplication" class="headerlink" title="KrpcApplication"></a>KrpcApplication</h3><p>KrpcApplication主要负责框架的初始化操作，有以下几个注意点：</p><ul><li>KrpcApplication为一个单例类</li><li>初始化操作具体为：从命令行中解析出配置文件路径 → 调用KrpcConfig类载入配置文件，完成各参数的初始化</li><li>初始化的配置项包括zookeeper服务器的ip和端口，以及Rpc服务端自己的ip和端口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcChannel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Krpc基础类，负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化框架</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式，返回单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KrpcApplication&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 删除单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KrpcConfig&amp; <span class="title">GetConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 单例模式，私有的构造函数</span></span><br><span class="line">    <span class="built_in">KrpcApplication</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">KrpcApplication</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝与移动构造</span></span><br><span class="line">    <span class="built_in">KrpcApplication</span>(<span class="type">const</span> KrpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">KrpcApplication</span>(KrpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="type">static</span> KrpcConfig m_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="type">static</span> KrpcApplication* m_application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥量</span></span><br><span class="line">    <span class="type">static</span> std::mutex m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次声明静态变量</span></span><br><span class="line">KrpcConfig KrpcApplication::m_config;</span><br><span class="line">std::mutex KrpcApplication::m_mutex;</span><br><span class="line"><span class="comment">// 懒汉模式初始化单例对象</span></span><br><span class="line">KrpcApplication* KrpcApplication::m_application = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;KrpcApplication::Init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// -i后必须有配置文件路径，文件中记录zookeeper服务器的ip和端口，以及服务器的ip和端口</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="comment">// getopt用于解析命令行字符，第三个参数表示接收的参数，这里只指定i</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;KrpcApplication: case -i&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// -i表示指定配置文件路径</span></span><br><span class="line">                <span class="comment">// optarg为命令行参数对应的值，这里即为指定的配置文件路径</span></span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 不接受i以外的命令行参数</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 出现了i但后面没有对应的值</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从配置文件中载入配置项</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式，返回单例对象</span></span><br><span class="line"><span class="function">KrpcApplication&amp; <span class="title">KrpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例时上锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!m_application)&#123;</span><br><span class="line">        m_application = <span class="keyword">new</span> <span class="built_in">KrpcApplication</span>();</span><br><span class="line">        <span class="comment">// 设置程序退出时自动销毁单例对象</span></span><br><span class="line">        <span class="built_in">atexit</span>(DeleteInstance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *m_application;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcApplication::DeleteInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_application)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_application;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置</span></span><br><span class="line"><span class="function">KrpcConfig&amp; <span class="title">KrpcApplication::GetConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KrpcConfig"><a href="#KrpcConfig" class="headerlink" title="KrpcConfig"></a>KrpcConfig</h3><p>KrpcConfig主要负责实际的配置项初始化操作，具体就是从配置文件中逐行读入配置项，逻辑比较简单</p><p>值得学习的点有使用智能指针管理文件指针，这样可以在初始化结束后自动关闭文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* config_file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找配置项对应的值</span></span><br><span class="line">    <span class="function">std::string <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 辅助函数，用于去除字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string&amp; read_buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存放配置项的容器</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcConfig::LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* config_file)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理文件指针，并指定删除器为fclose</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">pf</span><span class="params">(fopen(config_file, <span class="string">&quot;r&quot;</span>), fclose)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐行读取配置项</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="number">1024</span>, pf.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line">        <span class="comment">// 跳过空行与注释行</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf.<span class="built_in">empty</span>() || read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#x27;=&#x27;前为配置名，后为配置值</span></span><br><span class="line">        <span class="type">int</span> ind = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ind == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析key</span></span><br><span class="line">        std::string key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, ind);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="comment">// 解析value</span></span><br><span class="line">        <span class="type">int</span> endInd = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, ind);</span><br><span class="line">        std::string value = read_buf.<span class="built_in">substr</span>(ind + <span class="number">1</span>, endInd - ind - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入配置项</span></span><br><span class="line">        m_configs[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找配置项对应的值</span></span><br><span class="line"><span class="function">std::string <span class="title">KrpcConfig::Load</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configs.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configs.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于去除字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcConfig::Trim</span><span class="params">(std::string&amp; read_buf)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 去除前导空格</span></span><br><span class="line">    <span class="type">int</span> ind = read_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ind != <span class="number">-1</span>)&#123;</span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(ind, read_buf.<span class="built_in">size</span>() - ind);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除尾部空格</span></span><br><span class="line">    ind = read_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ind != <span class="number">-1</span>)&#123;</span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, ind + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KrpcProvider"><a href="#KrpcProvider" class="headerlink" title="KrpcProvider"></a>KrpcProvider</h2><div class="note info modern"><p>Rpc服务端的核心函数类，提供发布Rpc方法、启动Rpc服务节点等功能</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">KrpcProvider</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给外部使用，用于发布rpc方法</span></span><br><span class="line">    <span class="comment">// 多态：所有服务都继承自google::protobuf::Service</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service* service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动Rpc服务节点，开始提供Rpc远程调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务结构体，用于保存具体的服务对象和它的方法</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service* service;</span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; method_map;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理新连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已有连接上发来的消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buffer, muduo::Timestamp receive_time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送Rpc响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    muduo::net::EventLoop m_eventloop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存服务对象的容器</span></span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_services;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>KrpcProvider如何管理服务对象与其方法？</p></blockquote><ul><li>使用unordered_map存放ServiceInfo，管理所有服务</li><li>每个ServiceInfo也使用一个unordered_map存放method描述符，管理该服务下的所有方法</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KrpcProvider::~<span class="built_in">KrpcProvider</span>()&#123;</span><br><span class="line">    <span class="comment">// 析构函数，停止Event Loop</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~KrpcProvider()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_eventloop.<span class="built_in">quit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NotifyService"><a href="#NotifyService" class="headerlink" title="NotifyService"></a>NotifyService</h3><p><code>NotifyService</code>提供给外部使用，用于<strong>在Rpc服务端上注册RPC服务</strong>：</p><ul><li>将传入的服务保存到<code>m_services</code>中，等待之后调用Run时发布到zookeeper服务器上</li></ul><p>多态思想的利用：</p><ul><li>所有服务都继承自<code>google::protobuf::Service</code>，所以<code>NotifyService</code>能接受任何类型的服务</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::NotifyService</span><span class="params">(google::protobuf::Service* service)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 存放服务对象及其方法的结构体</span></span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用多态返回服务类的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor* psd = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务对象的方法都存入service_info</span></span><br><span class="line">    <span class="type">int</span> method_cnt = psd-&gt;<span class="built_in">method_count</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; method_cnt; ++i)&#123;</span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor* pmd = psd-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        service_info.method_map.<span class="built_in">emplace</span>(pmd-&gt;<span class="built_in">name</span>(), pmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务对象放入容器进行管理</span></span><br><span class="line">    m_services.<span class="built_in">emplace</span>(psd-&gt;<span class="built_in">name</span>(), service_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p><code>Run</code>的主要工作：</p><ol><li>从配置文件中读取Rpc服务器的ip和端口</li><li>调用muduo库接口创建TcpServer对象，并分别绑定连接事件和消息事件，实现网络连接业务和消息处理业务的分离</li><li>将<code>m_services</code>中<strong>注册的服务全部发布到zookeeper服务器上</strong>，让Rpc客户端可以从zookeeper上发现Rpc服务端提供的服务</li><li>所有服务都完成发布后，<strong>启动muduo库网络服务</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中读取Rpc服务端的ip和端口</span></span><br><span class="line">    std::string ip = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建地址</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    <span class="keyword">auto</span> server = std::<span class="built_in">make_shared</span>&lt;muduo::net::TcpServer&gt;(&amp;m_eventloop, address, <span class="string">&quot;KrpcProvider&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别绑定连接事件和消息事件</span></span><br><span class="line">    server-&gt;<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server-&gt;<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程数量为4</span></span><br><span class="line">    server-&gt;<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前Rpc服务端的服务全部注册到zookeeper上，使得Rpc客户端能够从zookeeper上发现服务</span></span><br><span class="line">    ZkClient zkclient;</span><br><span class="line">    zkclient.<span class="built_in">Start</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;KrpcProvider: zkclient Start success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// service_name为永久节点，method_name为临时节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; service: m_services)&#123;</span><br><span class="line">        <span class="comment">// service_name的路径: /service_name</span></span><br><span class="line">        std::string service_path = <span class="string">&quot;/&quot;</span> + service.first;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;KrpcProvider: zkclient Create znode: &quot;</span> &lt;&lt; service_path &lt;&lt; std::endl;</span><br><span class="line">        zkclient.<span class="built_in">Create</span>(service_path.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建method_name节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; method: service.second.method_map)&#123;</span><br><span class="line">            std::string method_path = service_path + <span class="string">&quot;/&quot;</span> + method.first;</span><br><span class="line">            <span class="type">char</span> method_path_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">// 写入节点内容：ip + 端口</span></span><br><span class="line">            <span class="built_in">sprintf</span>(method_path_data, <span class="string">&quot;%s:%d&quot;</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">            <span class="comment">// zookeeper上创建临时节点</span></span><br><span class="line">            zkclient.<span class="built_in">Create</span>(method_path.<span class="built_in">c_str</span>(), method_path_data, <span class="built_in">strlen</span>(method_path_data), ZOO_EPHEMERAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rpc服务端准备启动</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动muduo网络服务</span></span><br><span class="line">    server-&gt;<span class="built_in">start</span>();</span><br><span class="line">    m_eventloop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnConnection"><a href="#OnConnection" class="headerlink" title="OnConnection"></a>OnConnection</h3><p>如果连接失效，则调用shutdown断开连接，除此不对连接事件做特殊处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不做特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnMessage"><a href="#OnMessage" class="headerlink" title="OnMessage"></a>OnMessage</h3><p><code>OnMessage</code>的主要工作：</p><ol><li>处理Tcp粘包问题，反序列化从字节流中解析出参数</li><li>根据参数找到对应的服务与方法</li><li>生成Rpc方法调用的请求和响应，调用本地的方法，并通过回调函数发送响应</li></ol><blockquote><p>如何处理Tcp粘包问题?</p></blockquote><p>将字节流分割为以下几部分：</p><ul><li><code>header_size</code>: 固定4字节，记录header_str的长度</li><li><code>header_str</code>: 记录服务名、方法名、参数长度（KrpcHeader.proto中定义）</li><li><code>arg_str</code>: 用于调用方法的参数</li></ul><blockquote><p>什么是<code>NewCallback</code>？</p></blockquote><p><code>NewCallback</code>函数会返回一个google::protobuf::Closure类的对象，可以理解为定义了一个<strong>回调函数</strong></p><p>Closure类对象相当于一个闭包，它捕获了以下内容：</p><ul><li>一个成员对象的成员函数（这里为<code>SendRpcResponse</code>）</li><li>以及这个成员函数需要的参数（这里为<code>conn</code>、<code>response</code>）</li></ul><blockquote><p>什么是<code>CallMethod</code> ？</p></blockquote><p>CallMethod在<code>UserServiceRpc</code>中实现（proto自动生成），功能为<strong>根据远端Rpc请求，调用当前Rpc节点上发布的方法</strong></p><p><code>request</code>与<code>response</code>中包含了调用method的参数，<code>done</code>是执行完method后的回调函数，这里指定了<code>SendRpcResponse</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buffer, muduo::Timestamp receive_time)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;OnMessage&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收远端调用的字节流</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">    <span class="comment">// ArrayInputStream: 将字节流包装为一个可读取的输入溜</span></span><br><span class="line">    google::protobuf::<span class="function">io::ArrayInputStream <span class="title">raw_input</span><span class="params">(recv_buf.data(), recv_buf.size())</span></span>;</span><br><span class="line">    <span class="comment">// CodedInputStream: 提供高效的二进制流解析工具</span></span><br><span class="line">    google::protobuf::<span class="function">io::CodedInputStream <span class="title">coded_input</span><span class="params">(&amp;raw_input)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取4字节的header_size</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size&#123;&#125;;</span><br><span class="line">    coded_input.<span class="built_in">ReadVarint32</span>(&amp;header_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size的值读取header_str，并对其反序列化，得到Rpc请求的详细信息（既服务名、方法名、参数大小）</span></span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    Krpc::RpcHeader krpcHeader;</span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line">    <span class="comment">// 设置读取规则，读取header_str</span></span><br><span class="line">    google::protobuf::io::CodedInputStream::Limit msg_limit = coded_input.<span class="built_in">PushLimit</span>(header_size);</span><br><span class="line">    coded_input.<span class="built_in">ReadString</span>(&amp;rpc_header_str, header_size);</span><br><span class="line">    <span class="comment">// 恢复规则，便于之后安全地读取其他数据</span></span><br><span class="line">    coded_input.<span class="built_in">PopLimit</span>(msg_limit);</span><br><span class="line">    <span class="comment">// 反序列化，解析KrpcHeader</span></span><br><span class="line">    <span class="keyword">if</span>(krpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        service_name = krpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = krpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = krpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: krpcHeader parse error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于调用Rpc方法的参数</span></span><br><span class="line">    std::string args_str;</span><br><span class="line">    <span class="comment">// 读取args_size长度的字符串</span></span><br><span class="line">    <span class="keyword">if</span>(!coded_input.<span class="built_in">ReadString</span>(&amp;args_str, args_size))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: read args error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Rpc服务端中搜索service对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> sit = m_services.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="keyword">if</span>(sit == m_services.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&quot; is no exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mit = sit-&gt;second.method_map.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == sit-&gt;second.method_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is no exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取服务对象与方法对象</span></span><br><span class="line">    google::protobuf::Service* service = sit-&gt;second.service;</span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor* method = mit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成Rpc方法调用的请求（request）和响应（response）</span></span><br><span class="line">    <span class="comment">// 通过 GetRequestPrototype，可以根据方法描述符动态获取对应的请求消息类型，并New（）实例化该类型的对象</span></span><br><span class="line">    google::protobuf::Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NewCallback函数会返回一个google::protobuf::Closure类的对象</span></span><br><span class="line">    <span class="comment">// Closure类对象相当于一个闭包，它捕获了一个成员对象的成员函数(SendRpcResponse)，以及这个成员函数需要的参数(conn、response)）</span></span><br><span class="line">    google::protobuf::Closure* done = google::protobuf::<span class="built_in">NewCallback</span>&lt;KrpcProvider,</span><br><span class="line">                                                                    <span class="type">const</span> muduo::net::TcpConnectionPtr&amp;,</span><br><span class="line">                                                                    google::protobuf::Message*&gt;(<span class="keyword">this</span>, &amp;KrpcProvider::SendRpcResponse,</span><br><span class="line">                                                                                                conn,</span><br><span class="line">                                                                                                response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CallMethod在UserServiceRpc实现，功能为根据远端Rpc请求，调用当前Rpc节点上发布的方法</span></span><br><span class="line">    <span class="comment">// request与response中包含了调用method的参数，done是执行完method后的回调函数，这里指定了SendRpcResponse</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SendRpcResponse"><a href="#SendRpcResponse" class="headerlink" title="SendRpcResponse"></a>SendRpcResponse</h3><p>SendRpcResponse作为OnMessage中CallMethod的回调函数，在执行完远端Rpc调用的方法后调用。其功能是<strong>序列化响应信息，并通过send发送给Rpc客户端</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 序列化响应字符串，并将其发送给Rpc调用方</span></span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Serialize Error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zookeeperutil"><a href="#zookeeperutil" class="headerlink" title="zookeeperutil"></a>zookeeperutil</h2><p><code>zookeeperutil</code>主要对zookeeper提供的一些api进行封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zookeeper/zookeeper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// zookeeper客户端，主要封装一些zookeeper相关的api</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZkClient</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZkClient</span>();</span><br><span class="line">    ~<span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zk客户端启动，连接zk服务器。封装zookeeper_init</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在zk服务器中根据path新建一个节点。封装zoo_create</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datalen, <span class="type">int</span> state = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的路径，获取znode节点值。封装zoo_get</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// zk客户端的句柄</span></span><br><span class="line">    <span class="type">zhandle_t</span>* m_zhandle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="global-watcher"><a href="#global-watcher" class="headerlink" title="global_watcher"></a>global_watcher</h3><blockquote><p>watcher机制</p></blockquote><p>global_watcher定义了一个全局的watcher观察器，当znode节点发生变化时，zk服务端会通过该回调函数通知zk客户端</p><p>这里的global_watcher只处理 type&#x3D;&#x3D;ZOO_SESSION_EVENT &amp;&amp; state&#x3D;&#x3D;ZOO_CONNECTED_STATE 的watcher事件。目的是<strong>保证Start()调用完成后zk客户端（即Rpc服务端）与zk服务器的连接已经建立完成了</strong></p><blockquote><p>为什么需要watcher机制提供保证？</p></blockquote><p>因为<strong>zk客户端与zk服务器的连接建立过程是异步的</strong>。zookeeper_mt库的zookeeper客户端使用了以下三个线程：</p><ul><li>主线程：用户调用API的线程。</li><li>IO线程：负责网络通信的线程。</li><li>completion线程：对于异步请求（Zookeeper中提供的异步API，一般都是以zoo_a开头的api）以及<strong>watcher的响应回调</strong>，io线程会发送给completion线程完成处理。</li></ul><p>主线程在zk客户端调用api后返回zk句柄，而此时IO线程可能还没有完成连接的建立。所以需要watcher机制配合条件变量来保证Start()调用结束前连接的建立。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局锁</span></span><br><span class="line">std::mutex cv_mutex;</span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="comment">// 标记zk客户端是否已经连接到zk服务器</span></span><br><span class="line"><span class="type">bool</span> isConnected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的watcher观察器，当节点发生变化时，zk服务端会通过该回调函数通知zk客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">global_watcher</span><span class="params">(<span class="type">zhandle_t</span>* zh, <span class="type">int</span> type, <span class="type">int</span> state, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">void</span>* watcher_ctx)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只处理 type==ZOO_SESSION_EVENT &amp;&amp; state==ZOO_CONNECTED_STATE 的watcher事件</span></span><br><span class="line">    <span class="keyword">if</span>(type == ZOO_SESSION_EVENT)&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == ZOO_CONNECTED_STATE)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;</span><br><span class="line">            <span class="comment">// 标记zk客户端已经与zk服务端建立连接</span></span><br><span class="line">            isConnected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒条件变量</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，初始化zk客户端句柄</span></span><br><span class="line">ZkClient::<span class="built_in">ZkClient</span>(): <span class="built_in">m_zhandle</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，关闭zk客户端句柄</span></span><br><span class="line">ZkClient::~<span class="built_in">ZkClient</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_zhandle != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">zookeeper_close</span>(m_zhandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zk客户端启动，连接zk服务器。封装zookeeper_init</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZkClient::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中获取zookeeper服务器的ip和端口</span></span><br><span class="line">    std::string host = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperip&quot;</span>);</span><br><span class="line">    std::string port = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperport&quot;</span>);</span><br><span class="line">    <span class="comment">// 拼接 ip + port</span></span><br><span class="line">    std::string conn_str = host + port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化zk对象，异步建立zk客户端（即Rpc服务端）与zk服务器的连接</span></span><br><span class="line">    m_zhandle = <span class="built_in">zookeeper_init</span>(conn_str.<span class="built_in">c_str</span>(), global_watcher, <span class="number">6000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_zhandle)&#123;</span><br><span class="line">        <span class="comment">// 初始化失败</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zookeeper_init error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待global_watcher回调通知连接已经建立完成(isConnected == true)</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 第二个参数用于防止虚假唤醒</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, []&#123;<span class="keyword">return</span> isConnected;&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeper_init success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在zk服务器中根据path新建一个节点。封装zoo_create</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZkClient::Create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datalen, <span class="type">int</span> state = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建znode节点，可以选择永久性节点还是临时性节点</span></span><br><span class="line">    <span class="type">char</span> path_buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(path_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指定的节点是否存在，只有不存在时才创建节点</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_exists</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == ZNONODE)&#123;</span><br><span class="line">        <span class="comment">// 创建指定path的znode节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, state, path_buffer, bufferlen);</span><br><span class="line">        <span class="keyword">if</span>(flag == ZOK)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;znode create success, path=&quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;znode create fail, path=&quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的路径，获取znode节点值。封装zoo_get</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(buffer);</span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_get</span>(m_zhandle, path, <span class="number">0</span>, buffer, &amp;bufferlen, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == ZOK)&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zoo_get error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KrpcController"><a href="#KrpcController" class="headerlink" title="KrpcController"></a>KrpcController</h2><p>KrpcController的主要作用是跟踪RPC方法调用的状态、错误信息并提供控制功能（如取消调用）。这里只实现了其最基本的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述Rpc调用的控制器，主要作用是跟踪RPC方法调用的状态、错误信息并提供控制功能（如取消调用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcController</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KrpcController</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置状态与错误信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前状态是否为错误</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_failed; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回错误信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="type">const</span> </span>&#123; m_errmsg; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态与错误信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFailed</span><span class="params">(<span class="type">const</span> std::string&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是一些还未实现的功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartCancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// RPC方法执行过程中的状态</span></span><br><span class="line">    <span class="type">bool</span> m_failed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC方法执行过程中的错误信息</span></span><br><span class="line">    std::string m_errmsg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">KrpcController::<span class="built_in">KrpcController</span>()</span><br><span class="line">    : <span class="built_in">m_failed</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_errmsg</span>(<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置状态与错误信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::Reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errmsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态与错误信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::SetFailed</span><span class="params">(<span class="type">const</span> std::string&amp; reason)</span></span>&#123;</span><br><span class="line">    m_failed = <span class="literal">true</span>;</span><br><span class="line">    m_errmsg = reason;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一些还未实现的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::StartCancel</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KrpcController::IsCanceled</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="RPC客户端"><a href="#RPC客户端" class="headerlink" title="RPC客户端"></a>RPC客户端</h1><h2 id="KrpcChannel"><a href="#KrpcChannel" class="headerlink" title="KrpcChannel"></a>KrpcChannel</h2><blockquote><p>多态的应用</p></blockquote><p><code>UserServiceRpc_Stub</code>的构造函数必须传入一个<code>google::protobuf::RpcChannel</code>。所以我们必须自己实现一个<code>KrpcChannel</code>继承自<code>google::protobuf::RpcChannel</code> ，并实现它的<code>CallMethod</code>方法</p><blockquote><p><code>CallMethod</code>如何理解？</p></blockquote><ul><li><p><strong>客户端视角</strong>：<code>CallMethod</code> 是客户端存根（Stub）类调用的入口，负责将本地方法调用（如这里的<code>Login</code>）的参数序列化为网络传输格式，并通过网络发送给服务端（简单理解就是<strong>将本地方法调用转换为远程过程调用</strong>）</p><ul><li>客户端所有服务方法的调用最终都会转变为对<code>CallMethod</code>的调用，如Login：</li></ul><p>  <img src="https://atelieryu.xyz/elog/202503/1234ff92ae5a0fac62f2656fddd6f9d0.png" alt="UserServiceRpc_stub::Login源码"></p></li><li><p><strong>服务端视角</strong>：服务端通过 <code>CallMethod</code> 接收请求后，根据消息头中的服务名和方法名路由到具体的服务实现，并触发本地方法执行</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自google::protobuf::RpcChannel</span></span><br><span class="line"><span class="comment">// 目的是为了给客户端进行方法调用的时候，统一接收的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcChannel</span>: <span class="keyword">public</span> google::protobuf::RpcChannel&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">KrpcChannel</span>(<span class="type">bool</span> connectNow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">KrpcChannel</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写继承的CallMethod</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CallMethod</span><span class="params">(<span class="type">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::RpcController* controller, </span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Message* response, </span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Closure* done)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 建立与Rpc服务端的连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">newConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">uint16_t</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向zookeeper服务器查询服务方法对应的Rpc服务端ip和端口</span></span><br><span class="line">    <span class="function">std::string <span class="title">QueryServiceHost</span><span class="params">(ZkClient* zkclient, <span class="type">const</span> std::string&amp; service_name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> std::string&amp; method_name, <span class="type">int</span>&amp; idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 客户端通信的socket</span></span><br><span class="line">    <span class="type">int</span> m_clientSock;</span><br><span class="line">    <span class="comment">// 服务名</span></span><br><span class="line">    std::string m_service_name; </span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    std::string m_method_name;</span><br><span class="line">    <span class="comment">// Rpc服务端的ip和端口</span></span><br><span class="line">    std::string m_ip;</span><br><span class="line">    <span class="type">uint16_t</span> m_port;</span><br><span class="line">    <span class="comment">// 划分服务器ip和端口的下标</span></span><br><span class="line">    <span class="type">int</span> m_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果已经处于连接状态（connectNow &#x3D;&#x3D; True），则尝试与Rpc服务端进行连接</p><ul><li><strong>重试机制</strong>：当连接失败时，可以重试3次</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KrpcChannel::<span class="built_in">KrpcChannel</span>(<span class="type">bool</span> connectNow)</span><br><span class="line">    : <span class="built_in">m_clientSock</span>(<span class="number">-1</span>)</span><br><span class="line">    , <span class="built_in">m_idx</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!connectNow)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试与Rpc服务端进行连接，可以重试3次</span></span><br><span class="line">    <span class="keyword">auto</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(!rt &amp;&amp; cnt--)&#123;</span><br><span class="line">        rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CallMethod"><a href="#CallMethod" class="headerlink" title="CallMethod"></a>CallMethod</h3><p>CallMethod的主要工作：</p><ol><li>连接Rpc服务器 ：查询zookeeper服务器获取ip和端口 → 调用<code>newConnect</code>连接服务端</li><li>序列化请求：打包header_size、header_str、args_size、args_str</li><li>发送请求：<code>send</code></li><li>接受响应：<code>recv</code></li><li>解析响应数据</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcChannel::CallMethod</span><span class="params">(<span class="type">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::RpcController* controller, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::Message* response, </span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::Closure* done)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立与Rpc服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span>(m_clientSock == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 获取服务对象名和方法名</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::ServiceDescriptor* sd = method-&gt;<span class="built_in">service</span>();</span><br><span class="line">        m_service_name = sd-&gt;<span class="built_in">name</span>();</span><br><span class="line">        m_method_name = method-&gt;<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向zookeeper服务器查询服务对象和方法对应的服务端host</span></span><br><span class="line">        ZkClient zkCli;</span><br><span class="line">        zkCli.<span class="built_in">Start</span>();</span><br><span class="line">        std::string server_host = <span class="built_in">QueryServiceHost</span>(&amp;zkCli, m_service_name, m_method_name, m_idx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析host</span></span><br><span class="line">        m_ip = server_host.<span class="built_in">substr</span>(<span class="number">0</span>, m_idx);</span><br><span class="line">        m_port = <span class="built_in">atoi</span>(server_host.<span class="built_in">substr</span>(m_idx + <span class="number">1</span>, server_host.<span class="built_in">size</span>() - m_idx).<span class="built_in">c_str</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server ip: &quot;</span> &lt;&lt; m_ip &lt;&lt; <span class="string">&quot;, port: &quot;</span> &lt;&lt; m_port &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        <span class="type">bool</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">        <span class="keyword">if</span>(rt) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect server success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect server error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 连接建立失败时返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装KrpcHeader</span></span><br><span class="line">    Krpc::RpcHeader krpcHeader;</span><br><span class="line">    <span class="comment">// - service_name</span></span><br><span class="line">    krpcHeader.<span class="built_in">set_service_name</span>(m_service_name);</span><br><span class="line">    <span class="comment">// - method_name</span></span><br><span class="line">    krpcHeader.<span class="built_in">set_method_name</span>(m_method_name);</span><br><span class="line">    <span class="comment">// - args_size</span></span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line">    std::string args_str;</span><br><span class="line">    <span class="comment">// 序列化参数到字符串</span></span><br><span class="line">    <span class="keyword">if</span>(request-&gt;<span class="built_in">SerializeToString</span>(&amp;args_str))&#123;</span><br><span class="line">        args_size = args_str.<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置KrpcController的错误信息</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize request fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    krpcHeader.<span class="built_in">set_args_size</span>(args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将(header_size、header_str、args_size、args_str)打包到send_rpc_str</span></span><br><span class="line">    std::string send_rpc_str;</span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="comment">// 序列化KrpcHeader到字符串</span></span><br><span class="line">    <span class="keyword">if</span>(krpcHeader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str))&#123;</span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize rpc header fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流式写入send_rpc_str</span></span><br><span class="line">    &#123;</span><br><span class="line">        google::protobuf::<span class="function">io::StringOutputStream <span class="title">string_output</span><span class="params">(&amp;send_rpc_str)</span></span>;</span><br><span class="line">        google::protobuf::<span class="function">io::CodedOutputStream <span class="title">coded_output</span><span class="params">(&amp;string_output)</span></span>;</span><br><span class="line">        coded_output.<span class="built_in">WriteVarint32</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header_size));</span><br><span class="line">        coded_output.<span class="built_in">WriteString</span>(rpc_header_str);</span><br><span class="line">    &#125;</span><br><span class="line">    send_rpc_str += args_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送Rpc请求</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">send</span>(m_clientSock, send_rpc_str.<span class="built_in">c_str</span>(), send_rpc_str.<span class="built_in">size</span>(), <span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 发送请求失败</span></span><br><span class="line">        <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受Rpc请求的响应</span></span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="built_in">recv</span>(m_clientSock, recv_buf, <span class="built_in">sizeof</span>(recv_buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_size == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化解析响应数据</span></span><br><span class="line">    <span class="keyword">if</span>(!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size))&#123;</span><br><span class="line">        <span class="comment">// 解析失败</span></span><br><span class="line">        <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;parse&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;parse error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求-响应完毕，关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newConnect"><a href="#newConnect" class="headerlink" title="newConnect"></a>newConnect</h3><p>获得服务端的ip和port后，建立与Rpc服务端的TCP连接。常规的socket编程客户端connect流程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KrpcChannel::newConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">uint16_t</span> port)</span></span>&#123;</span><br><span class="line">    <span class="comment">// socket编程的客户端connect流程</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(clientfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;KrpcChannel::newConnect: connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_clientSock = clientfd;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QueryServiceHost"><a href="#QueryServiceHost" class="headerlink" title="QueryServiceHost"></a>QueryServiceHost</h3><p>向zookeeper服务器查询服务方法对应的Rpc服务端的host</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">KrpcChannel::QueryServiceHost</span><span class="params">(ZkClient* zkclient, <span class="type">const</span> std::string&amp; service_name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::string&amp; method_name, <span class="type">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">    std::string method_path = <span class="string">&#x27;/&#x27;</span> + service_name + <span class="string">&#x27;/&#x27;</span> + method_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上锁从zookeeper获取Rpc服务器host，保证多线程情况下每一个线程都能拿到信息</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    std::string server_host = zkclient-&gt;<span class="built_in">GetData</span>(method_path.<span class="built_in">c_str</span>());</span><br><span class="line">    lock.<span class="built_in">unlock</span>();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断host合法性</span></span><br><span class="line">    <span class="keyword">if</span>(server_host == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; method_path &lt;&lt; <span class="string">&quot; is no exist! \n&quot;</span>;</span><br><span class="line">        <span class="comment">// 不能返回空字符串，否则后续substr会出错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以&quot;:&quot;为分隔符分隔ip和port</span></span><br><span class="line">    idx = server_host.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; method_path &lt;&lt; <span class="string">&quot; address is invalid! \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端主函数"><a href="#客户端主函数" class="headerlink" title="客户端主函数"></a>客户端主函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcChannel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rpc客户端远端调用Rpc服务端的服务方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_request</span><span class="params">(<span class="type">int</span> thread_id, std::atomic&lt;<span class="type">int</span>&gt;&amp; success_cnt, std::atomic&lt;<span class="type">int</span>&gt;&amp; fail_cnt)</span></span>&#123;</span><br><span class="line">    <span class="function">Kuser::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(<span class="keyword">new</span> KrpcChannel(<span class="literal">false</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Rpc请求参数</span></span><br><span class="line">    Kuser::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">    request.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建Rpc响应参数</span></span><br><span class="line">    Kuser::LoginResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程调用Login方法</span></span><br><span class="line">    KrpcController controller;</span><br><span class="line">    <span class="comment">// 这里Login实际就是通过KrpcChannel::CallMethod间接调用的</span></span><br><span class="line">    stub.<span class="built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 读取响应</span></span><br><span class="line">    <span class="keyword">if</span>(controller.Failed)&#123;</span><br><span class="line">        <span class="comment">// 调用失败</span></span><br><span class="line">        std::cout &lt;&lt; controller.<span class="built_in">ErrorText</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(response.<span class="built_in">result</span>().<span class="built_in">errcode</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Rpc login response success: &quot;</span> &lt;&lt; response.<span class="built_in">success</span>() &lt;&lt; std::endl;</span><br><span class="line">            ++success_cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Rpc login response success: &quot;</span> &lt;&lt; response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>() &lt;&lt; std::endl;</span><br><span class="line">            ++fail_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 程序启动后，调用KrpcApplication类进行初始化</span></span><br><span class="line">    KrpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程配置属性</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> thread_cnt = <span class="number">1000</span>;        <span class="comment">// 并发线程数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> request_per_thread = <span class="number">10</span>;  <span class="comment">// 每个线程发送的请求数</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">success_cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">fail_cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序开始时间</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多线程并发测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_cnt; ++i)&#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([argc, argv, i, &amp;success_cnt, &amp; fail_cnt]()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; request_per_thread; ++j)&#123;</span><br><span class="line">                <span class="built_in">send_request</span>(i, success_cnt, fail_cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序结束时间，并计算程序执行时间</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; elapsed = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出统计结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total requests: &quot;</span> &lt;&lt; thread_cnt * request_per_thread &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success count: &quot;</span> &lt;&lt; success_cnt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fail count: &quot;</span> &lt;&lt; fail_cnt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time: &quot;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::end;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;QPS: &quot;</span> &lt;&lt; (thread_cnt * request_per_thread) / elapsed.<span class="built_in">count</span>() &lt;&lt; std::endl;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="send-request"><a href="#send-request" class="headerlink" title="send_request"></a>send_request</h3><p>客户端通过<code>send_request</code> 远端调用<code>Login</code>方法</p><h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><p>进行Rpc框架的多线程并发测试</p><h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>分别运行服务端、客户端即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.在example文件夹和src文件夹中为proto文件生成.h和.cc文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.回到项目根目录，使用以下命令编译生成可执行文件</span></span><br><span class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j$&#123;nproc&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.进入bin文件夹，在不同会话中分别运行server和client</span></span><br><span class="line">./server -i ./test.conf</span><br><span class="line">./client -i ./test.conf</span><br></pre></td></tr></table></figure><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul><li>测试平台：阿里云服务器</li><li>操作系统：Ubuntu 22.04</li><li>CPU：2核</li><li>内存：2G</li><li>硬盘：40G</li></ul><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ul><li><p>并发线程数<code>200</code>，每个线程发送的请求数<code>10</code>：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Total requests: 2000</span><br><span class="line">Success count: 2000</span><br><span class="line">Fail count: 0</span><br><span class="line">Elapsed time: 10.4225 seconds</span><br><span class="line">QPS: 191.892</span><br></pre></td></tr></table></figure></li><li><p>并发线程数<code>1000</code>，每个线程发送的请求数<code>10</code>：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Total requests: 10000</span><br><span class="line">Success count: 10000</span><br><span class="line">Fail count: 0</span><br><span class="line">Elapsed time: 79.2326 seconds</span><br><span class="line">QPS: 126.21</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;RPC简介&quot;&gt;&lt;a href=&quot;#RPC简介&quot; class=&quot;headerlink&quot; title=&quot;RPC简介&quot;&gt;&lt;/a&gt;RPC简</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://atelieryu.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="后端" scheme="https://atelieryu.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="RPC" scheme="https://atelieryu.site/tags/RPC/"/>
    
    <category term="Protobuf" scheme="https://atelieryu.site/tags/Protobuf/"/>
    
    <category term="C++" scheme="https://atelieryu.site/tags/C/"/>
    
    <category term="分布式" scheme="https://atelieryu.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Protobuf简易使用</title>
    <link href="https://atelieryu.site/posts/522b2664.html"/>
    <id>https://atelieryu.site/posts/522b2664.html</id>
    <published>2025-03-17T01:48:00.000Z</published>
    <updated>2025-03-19T02:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info modern"><p>ProtoBuf提供对数据的序列化和反序列化，ProtoBuf可以用于结构化数据的串行序列化，并且以Key-Value格式存储数据，因为采用二进制格式，所以序列化出来的数据比较少，作为网络传输的载体效率很高</p></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://protobuf.com.cn/programming-guides/proto3/">proto3官方教程</a></li><li><a href="https://subingwen.cn/cpp/protobuf/">参考博客</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="源码下载与安装"><a href="#源码下载与安装" class="headerlink" title="源码下载与安装"></a>源码下载与安装</h2><ul><li><a href="https://github.com/protocolbuffers/protobuf/releases">github源代码下载地址</a></li><li><a href="https://github.com/protocolbuffers/protobuf/releases">3.21.12版本安装较为简单</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以 protobuf 3.21.12 为例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自行下载源码包, 解压缩</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar zxvf protobuf-cpp-3.21.12.tar.gz</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到解压目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> protobuf-3.21.12/</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建并安装</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./configure         <span class="comment"># 检查安装环境, 生成 makefile</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make                <span class="comment"># 编译</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> make install   <span class="comment"># 安装</span></span></span><br></pre></td></tr></table></figure><h3 id="动态库链接失败处理"><a href="#动态库链接失败处理" class="headerlink" title="动态库链接失败处理"></a>动态库链接失败处理</h3><p>可以使用<code>$ protoc --version</code>测试是否安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试时发现动态库链接失败</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --version</span></span><br><span class="line">protoc: error while loading shared libraries: libprotoc.so.32: cannot open shared object file: No such file or directory</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法1：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find指令查找动态库路径</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> find /usr/local/ -name libprotoc.so</span>     </span><br><span class="line">/usr/local/lib/libprotoc.so</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将查找到的目录添加到/etc/ld.so.conf配置文件中：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> vim /etc/ld.so.conf</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尾部追加/usr/local/lib/</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接使用ldconfig指令</span></span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处理完成后：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc --version</span></span><br><span class="line">libprotoc 3.21.12</span><br></pre></td></tr></table></figure><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><ol><li><p>确定数据格式，数据可简单可复杂，比如：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要序列化的数据</span></span><br><span class="line"><span class="comment">// 第一种: 单一数据类型</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种: 复合数据类型</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    string sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>创建一个新的文件, 文件名随意指定, 文件后缀为 .proto</p></li><li><p>根据protobuf的语法, 编辑.proto文件</p></li><li><p>使用 protoc 命令将 .proto 文件转化为相应的 C++ 文件</p><ul><li>源文件: xxx.pb.cc –&gt; xxx对应的名字和 .proto文件名相同</li><li>头文件: xxx.pb.h –&gt; xxx对应的名字和 .proto文件名相同</li></ul></li><li><p>需要将生成的c++文件添加到项目中, 通过文件中提供的类 API 实现数据的序列化&#x2F;反序列化</p><blockquote><p>Protobuf与C++的类型对照</p></blockquote></li></ol><ul><li>几个主要注意点：<ul><li>C++中的string到Protobuf中统一使用bytes比较好</li><li>C++中的整型到Protobuf中为 int+size，如int→int32</li><li>C++中的结构体与类对应到Protobuf中为message（消息体）<ul><li>Protobuf中其他类型最终也都要封装到消息体里</li></ul></li></ul></li></ul><p><img src="https://atelieryu.xyz/elog/202503/406ba403b533f2b5dadcd79db8664f31.png" alt="image.png"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生成对应的.h和.c文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">protoc &lt;proto文件路径&gt; --cpp_out=&lt;输出路径&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">protoc Person.proto --cpp_out=./</span></span><br></pre></td></tr></table></figure><h3 id="repeated关键字"><a href="#repeated关键字" class="headerlink" title="repeated关键字"></a>repeated关键字</h3><ul><li>repeated标志对应的成员是动态数组</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>proto3 中的<strong>第一个枚举值必须为 0</strong>，第一个元素以外的元素值可以随意指定</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类型</span></span><br><span class="line"><span class="keyword">enum </span><span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">0</span>;</span><br><span class="line">    Green = <span class="number">3</span>;<span class="comment">// 第一个元素以外的元素值可以随意指定</span></span><br><span class="line">    Yellow = <span class="number">6</span>;</span><br><span class="line">    Blue = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在该文件中对要序列化的结构体进行描述</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 枚举类型</span></span><br><span class="line">    Color color = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proto文件的导入"><a href="#proto文件的导入" class="headerlink" title="proto文件的导入"></a>proto文件的导入</h3><ul><li>使用<code>import</code>语句在当前.ptoto中导入其它的.proto文件。这样就可以在一个.proto文件中引用并使用其它文件中定义的消息类型和枚举类型。</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 使用另外一个proto文件中的数类型, 需要导入这个文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;Address.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在该文件中对要序列化的结构体进行描述</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> sex = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加地址信息, 使用的是外部proto文件中定义的数据类型</span></span><br><span class="line">    Address addr = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h3><ul><li>在 Protobuf 中，可以使用package关键字来定义一个消息所属的包（package）。包是用于组织和命名消息类型的一种机制，<strong>类似于命名空间的概念</strong></li><li>在一个.proto文件中，可以通过在顶层使用package关键字来定义包：</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="comment">// 添加命名空间 Dabing</span></span><br><span class="line"><span class="keyword">package</span> Dabing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址信息, 这个Address类属于命名空间: Dabing</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Address</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bytes</span> addr = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> number = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他.proto文件导入以上文件后，可以通过<code>Dabing.Address</code>使用该文件定义的消息体Address</li><li>.c文件使用该proto文件生成的对象时，通过<code>Dabing::Address</code>使用该文件定义的消息体</li></ul><h2 id="Protobuf-API"><a href="#Protobuf-API" class="headerlink" title="Protobuf API"></a>Protobuf API</h2><p>通过对象调用Protobuf API</p><h3 id="成员操作"><a href="#成员操作" class="headerlink" title="成员操作"></a>成员操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员的const版本（数组成员需要传入索引）</span></span><br><span class="line">&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员的可修改版本（数组成员需要传入索引）</span></span><br><span class="line"><span class="built_in">mutable_</span>&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置成员（数组成员需要传入索引）</span></span><br><span class="line"><span class="built_in">set_</span>&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空成员</span></span><br><span class="line"><span class="built_in">clear_</span>&lt;成员名&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组成员的size</span></span><br><span class="line">&lt;成员名&gt;_size()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组中添加成员</span></span><br><span class="line"><span class="built_in">add_</span>&lt;成员名&gt;()</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件目录: google\protobuf\message_lite.h</span></span><br><span class="line"><span class="comment">// --- 将序列化的数据 数据保存到内存中</span></span><br><span class="line"><span class="comment">// 将类对象中的数据序列化为字符串: C++风格的字符串, 参数是一个传出参数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToString</span><span class="params">(std::string* output)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将类对象中的数据序列化为字符串: C风格的字符串, 参数 data 是一个传出参数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToArray</span><span class="params">(<span class="type">void</span>* data, <span class="type">int</span> size)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------ 写磁盘文件, 只需要调用这个函数, 数据自动被写入到磁盘文件中</span></span><br><span class="line"><span class="comment">// -- 需要提供流对象/文件描述符关联一个磁盘文件</span></span><br><span class="line"><span class="comment">// 将数据序列化写入到磁盘文件中, c++ 风格</span></span><br><span class="line"><span class="comment">// ostream 子类 ofstream -&gt; 写文件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToOstream</span><span class="params">(std::ostream* output)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="comment">// 将数据序列化写入到磁盘文件中, c 风格</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SerializeToFileDescriptor</span><span class="params">(<span class="type">int</span> file_descriptor)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件目录: google\protobuf\message_lite.h</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromString</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromArray</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// istream -&gt; 子类 ifstream -&gt; 读操作</span></span><br><span class="line"><span class="comment">// wo ri</span></span><br><span class="line"><span class="comment">// w-&gt;写 o: ofstream , r-&gt;读 i: ifstream</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromIstream</span><span class="params">(std::istream* input)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ParseFromFileDescriptor</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info modern&quot;&gt;&lt;p&gt;ProtoBuf提供对数据的序列化和反序列化，ProtoBuf可以用于结构化数据的串行序列化，并且以Key-Value格式存储数据，因为采用二进制格式，所以序列化出来的数据比较少，作为网络传输的载体效率很高&lt;/p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://atelieryu.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="后端" scheme="https://atelieryu.site/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="RPC" scheme="https://atelieryu.site/tags/RPC/"/>
    
    <category term="Protobuf" scheme="https://atelieryu.site/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>2025一月番追番记录</title>
    <link href="https://atelieryu.site/posts/bb92517d.html"/>
    <id>https://atelieryu.site/posts/bb92517d.html</id>
    <published>2025-03-16T09:24:00.000Z</published>
    <updated>2025-03-23T03:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info modern"><p>食用说明</p></div><ol><li>本文更偏向追番体验的记录，可能与补番体验略有不同</li><li>本文评分体系近似bangumi，以下为分数区间参考含义<ul><li>&gt;9：全人类都应该来看</li><li>&gt;8：必看神作</li><li>&gt;7：值得一看</li><li>&gt;6：闲的没事可以看</li><li>&gt;5：平平无奇</li><li>&lt;5：献给小众赤石爱好者的一封情书</li></ul></li><li>本文完全由主观构成，没有客观</li></ol><h1 id="2025一月番简评"><a href="#2025一月番简评" class="headerlink" title="2025一月番简评"></a>2025一月番简评</h1><h2 id="8分段"><a href="#8分段" class="headerlink" title="8分段"></a>8分段</h2><h3 id="金牌得主"><a href="#金牌得主" class="headerlink" title="金牌得主"></a>金牌得主</h3><p><img src="https://atelieryu.xyz/elog/202503/dbe4984261187c28c97afa31519a9d10.jpg" alt="金牌得主"></p><blockquote><p>“花滑是见证奇迹的运动”</p></blockquote><p><del>没想到小女孩滑冰这么好看。</del>看一半没忍住把漫画全补完了，原作质量过于硬了（<del>原作得了mvp，engi就是躺赢狗，全人类都应该看这部漫画</del>），动画制作虽然还是差一些（比如部分文戏），但花滑部分是真用心做了。原作花滑的分镜固然震撼，但动画里能看到角色流畅地完成一个个花滑动作也是一种别样的享受。这部番的魅力很难用三言两语描述出来，总之都给我去看呀（</p><ul><li><strong>对于花滑的刻画</strong>：看完感觉花滑真是优雅而又残酷啊。教练，我想学花滑！（</li><li><strong>对于人物的刻画</strong>：无论是主角和几乎每一位配角都有比较立体的刻画。尤其是主角的小祈和司教练。</li><li><strong>女女关系性</strong>：<del>小女孩也能有女女关系性？</del>虽然到漫画后期关系性才开始发力</li><li><strong>制作组对作品的热情</strong>：你是说，原作者厨的声优喜欢花滑，于是画了花滑为主题的漫画 → 八爷厨漫画主动请缨给漫画唱op → 花滑顶尖运动员羽生结弦欣赏八爷的才华同意合拍op的mv？就连平时和p9坐一桌的engi都开始发力了</li></ul><blockquote><p>综合打分——8</p></blockquote><ul><li>剧情：8.5</li><li>人设：8</li><li>动画制作：7.6</li></ul><h2 id="7分段"><a href="#7分段" class="headerlink" title="7分段"></a>7分段</h2><h3 id="喜欢的冲绳妹说方言"><a href="#喜欢的冲绳妹说方言" class="headerlink" title="喜欢的冲绳妹说方言"></a><strong>喜欢的冲绳妹说方言</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/7f4a23f11ed367ec74ef117ee2aeac12.jpg" alt="喜欢的冲绳妹说方言"></p><blockquote><p>人文纪录片 + 恋爱喜剧</p></blockquote><p>近几年还挺流行通过动漫来进行地区宣传的，虽然好看的也有一些（比如佐贺偶像是传奇），但看完真正让我产生“好想去这里旅游啊”的想法的这还是第一部。人文纪录片和恋爱喜剧两个都是我比较喜欢的类型，本季个人最佳大脑按摩番。</p><ul><li><strong>人文纪录片</strong>：剧中把各种因为文化、自然环境等因素产生的习俗差异，自然地融入了角色的日常交流中。与其说是在地区宣传中加入角色互动，不如说是通过角色互动中自然产生的交流gap来科普地区特色，加上段子情节设计的也都挺有趣，看的乐呵的同时还能学到不少异域豆知识。</li><li><strong>恋爱喜剧</strong>：<del>女二好可爱呀好可爱呀。本来我对于黑皮是拒绝的，但女二真的好可爱啊（本季第二喜欢的女角色）</del>。男主喜欢女主，女二喜欢男主，看起来扭曲的设定实际却异常清爽（原因是女二一个人贡献了全片90%以上的恋爱桥段），看女二一直自我拉扯还是挺有趣的（听漫画党说后面女二有望反杀女主，希望是真的）。</li></ul><blockquote><p>综合打分——7.7</p></blockquote><ul><li><del>剧情</del>有趣度：7.7</li><li>人设：7.7（7.2 女二再加0.5）</li><li>动画制作：7.2</li></ul><h3 id="群花绽放，彷如修罗"><a href="#群花绽放，彷如修罗" class="headerlink" title="群花绽放，彷如修罗"></a><strong>群花绽放，彷如修罗</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/e73e378e85ae3f374b5a816e84a46b0e.jpg" alt="群花绽放，彷如修罗"></p><blockquote><p>青春+社团活动+苦呀西（武田三板斧）</p></blockquote><ul><li><strong>有点尬的朗读演出</strong>：说实在朗读这个题材是真不太能get到，平时没接触过这个领域，单纯听也听不出名堂（毕竟天天听各种专业声优的配音）。制作组选择用领域展开这种方式表现朗读在我看来是有点尬的，所以朗读方面对我来讲是减分项。</li><li><strong>意外的文戏水平</strong>：这番在文戏上的刻画倒是渐入佳境，特别是在三四集左右进入各个部员的个人回，每集都看的挺舒服的。每个人都有各自的追求和心结，但又不拧巴。第九集的重女登场更是为我提供了不少乐子。</li><li><strong>可爱的女主</strong>：本番还贡献了本季度我最喜欢的女主（<del>花奈像只小动物一样，真的好可爱呀好可爱呀好可爱呀</del>）</li></ul><p><img src="https://atelieryu.xyz/elog/202503/1c1b2dc84f2e71b63751487b5e3a18fa.png" alt="花奈可爱捏"></p><blockquote><p>综合打分——7.6</p></blockquote><ul><li>剧情：7.5</li><li>人设：8（7.5女主再加0.5）</li><li>动画制作：7.5</li></ul><h3 id="一杆青空"><a href="#一杆青空" class="headerlink" title="一杆青空"></a>一杆青空</h3><p><img src="https://atelieryu.xyz/elog/202503/84b2ab9241b002fe2da88dea8091d697.jpg" alt="一杆青空"></p><blockquote><p>你们三个把日子过好比啥都重要</p></blockquote><p>本来对高尔夫这项运动也没啥兴趣（刻板印象：中年有钱大叔们谈生意的娱乐活动），结果看着看着居然能get到一点乐趣了。</p><p>算向山进发类型片吧，看着比较空气系但却并不无聊。主角团三人关系的文戏刻画意外地出色，每集看完都心里暖暖的，看美少女们开开心心做点啥还是比较放空大脑的，本季第二大脑按摩番。</p><p>此外女主也挺可爱的（说不出啥原因，就感觉蛮可爱的）</p><blockquote><p>综合评分——7.4</p></blockquote><ul><li>日常感：7.4</li><li>人设：7.4</li><li>动画制作：6.9</li></ul><h3 id="中年大叔转生恶役大小姐"><a href="#中年大叔转生恶役大小姐" class="headerlink" title="中年大叔转生恶役大小姐"></a>中年大叔转生恶役大小姐</h3><p><img src="https://atelieryu.xyz/elog/202503/76d5a1d2eae80ad8a1b8bd91951e84cb.jpg" alt="中年大叔转生恶役大小姐"></p><blockquote><p>体制内老干部的优雅与从容</p></blockquote><p>恶役系除了第一部猴王其他都没看完，几乎都是一个模板套出来的，导致越看越觉得土。这部倒是有点特色，中年大叔转生，利用多年体制内混出来的情商俘获一群人心。段子设计的也挺好（怀疑作者真是中年体制内老干部），甚至设定里还有一丝悬疑味。每周打开前都觉得好土，但最后又都是开心地看完一集（</p><blockquote><p>综合打分——7.2</p></blockquote><ul><li>有趣度：7.5</li><li>人设：6.8</li><li>动画制作：6.9</li></ul><h2 id="6分段"><a href="#6分段" class="headerlink" title="6分段"></a>6分段</h2><h3 id="不想加班的公会柜台小姐单挑BOSS"><a href="#不想加班的公会柜台小姐单挑BOSS" class="headerlink" title="不想加班的公会柜台小姐单挑BOSS"></a>不想加班的公会柜台小姐单挑BOSS</h3><p><img src="https://atelieryu.xyz/elog/202503/f4bab2b9a92c88c3ffe0efd5ef15dc84.jpg" alt="不想加班的公会柜台小姐单挑BOSS"></p><blockquote><p>她太喜欢当公务员了</p></blockquote><p>女主实在是太爱国了，明明随手打一个boss的报酬就够躺平好久，但她还是选择了天天加班当公务员，除了爱国想不出别的理由（</p><p>经典凤傲天番，看点是同类型中不错的制作水平（cw你有空做这个不如早点凑齐人手把我孤独摇滚第二季吐出来）和无处不在的女主大腿特写（上面的宣传图就能看出端倪了吧）。总之不带大脑1.5倍速看还算能看</p><blockquote><p>综合评分——6.2</p></blockquote><ul><li>剧情：5.2</li><li>人设：6.5</li><li>动画制作：7</li></ul><h2 id="4分段"><a href="#4分段" class="headerlink" title="4分段"></a>4分段</h2><h3 id="颂乐人偶（BanG-Dream-Ave-Mujica）"><a href="#颂乐人偶（BanG-Dream-Ave-Mujica）" class="headerlink" title="颂乐人偶（BanG Dream! Ave Mujica）"></a>颂乐人偶（BanG Dream! Ave Mujica）</h3><p><img src="https://atelieryu.xyz/elog/202503/04ea7b35fd43ab92229f73fcea9b1a18.jpg" alt="颂乐人偶"></p><blockquote><p>唉，人偶</p></blockquote><p>虽然想到大概率会翻车，但能烂到这种程度是真没想到。<del>我又幻想了，幻想独角兽老师归来重置母鸡卡，负责全部集数的脚本，所有爆点都处理的酣畅淋漓，剧本完成度甚至超越前作MyGo，一举拿下2025年度动画</del></p><ul><li><strong>逻辑混乱的剧情</strong>：团炸的莫名其妙，重组的也莫名其妙，角色性格转变的也莫名其妙。能看出很多地方剧情大纲是没大问题了，但具体实施到细节就充满了随意与混乱。</li><li><strong>崩坏无常的人设</strong>：角色没一个是人：只对熟人哈气的多重人格大祥，真多重人格的精神病睦、让30个乐队倒大霉的信用复读机海玲、强制soulmate的喵梦、地上狗爬的初华。未免过于不爱惜自己笔下的角色了</li><li><strong>毫无底线的炒作</strong>：制作组没那实力又想炒波大的。前几集每集结尾都在炒，然后下一集开头又轻轻放下；中间几集围绕一个多重人格的烂活硬炒几集，还把前作角色的人设给整崩了；最后几集没活了又炒出个二次元雷雨。更过分的是这些炒作设定对剧情推进和人物塑造几乎没有贡献。评价是为了热度连🐎都不要了。</li></ul><blockquote><p>综合评分——4.2</p></blockquote><ul><li>剧情：3</li><li>人设：3</li><li>动画制作：7.3</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://atelieryu.xyz/elog/202503/5bc14bd1a2dea71b40ea2ff3f912f073.png" alt="2025冬季番追番体验榜"></p><p>以为只是个过渡季，没想到黑马还挺多的，追番体验大概如上吧，比其往年平淡的一月，这季度看的还是比较开心的</p><p>还有几部续作，比如百人女友、异修罗、石纪元，准备之后再补。上季度看一半搁置的甘神家和青之箱有空可能也会补回来。</p><p>（唉，mujica带给我的失望是真的，可追番过程每周磕假药溜二创带给我的快乐也是真的。或许这回它烂了，但下次碰到这类原创番我肯定还会追的，毕竟长颈鹿渴望的永远是无法预测的命运之舞台呀。豪赤！再来一份！）</p><h1 id="2025四月番前瞻"><a href="#2025四月番前瞻" class="headerlink" title="2025四月番前瞻"></a>2025四月番前瞻</h1><p>度过了较为平淡的一月，四月就热闹起来了。数了数感兴趣的居然有16部</p><h3 id="夏日口袋"><a href="#夏日口袋" class="headerlink" title="夏日口袋"></a>夏日口袋</h3><p><img src="https://atelieryu.xyz/elog/202503/b750ead19b9bb7a15fc51e8d9a5f1302.jpg" alt="夏日口袋"></p><p>夏季是我最喜欢的季节，暑假是一年中我最喜欢的时期，而Summer Pocket则是我认为对夏日感和暑期感描写的最好的作品之一。原作是我最喜欢的Gal之一，希望feel能给点劲把它做好吧，重振Gal改荣光（</p><h3 id="机动战士高达GQuuuuuuX"><a href="#机动战士高达GQuuuuuuX" class="headerlink" title="机动战士高达GQuuuuuuX"></a><strong>机动战士高达GQuuuuuuX</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/441462356fded410db4427fc91d5dbe3.jpg" alt="机动战士高达GQuuuuuuX"></p><p>庵野秀明编剧 + 吉翁反杀联邦if线 + 过于标新立异的机设，反正噱头是已经拉满了，看肯定是会看的，但感觉翻车率拉满（得有个70%+的翻车率吧）。是时候把之前坑的Z高达补完了</p><h3 id="LAZARUS"><a href="#LAZARUS" class="headerlink" title="LAZARUS"></a><strong>LAZARUS</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/d58312a81eb7f7be7e9c31a239ec864f.jpg" alt="LAZARUS"></p><p>渡边信一郎导演的新作 + 近年来稳定高质量的Mappa + 听说已经完成制作的超充裕工期，好像还请来的疾速追杀系列的动作设计（不太看电影不太熟就是了），同样噱头拉满，但感觉比GQuuuX稳多了。</p><h3 id="赛马娘-芦毛灰姑娘"><a href="#赛马娘-芦毛灰姑娘" class="headerlink" title="赛马娘 芦毛灰姑娘"></a><strong>赛马娘 芦毛灰姑娘</strong></h3><p><img src="https://atelieryu.xyz/elog/202503/eb1f0a3356127d4947278ebc864b88d8.jpg" alt="赛马娘 芦毛灰姑娘"></p><p>听漫画原作党说是赛马娘系列最优秀的作品，小栗帽也是日本人气断层领先的赛马，Cy应该会拿出全力做吧，顶尖之路和新时代之扉做的都挺好的，还是值得一看的（虽然看制作人员好像还是有点危险）</p><h3 id="魔女与使魔"><a href="#魔女与使魔" class="headerlink" title="魔女与使魔"></a>魔女与使魔</h3><p><img src="https://atelieryu.xyz/elog/202503/f7514468c2e15d5167a4124b69faf28b.jpg" alt="魔女与使魔"></p><p>原作是jump中坚之一，看pv表现挺好的，制作不错，pv里都有不少笑点，校园恋爱喜剧一直是我比较喜欢的类型，应该是会追的</p><h3 id="mono女孩"><a href="#mono女孩" class="headerlink" title="mono女孩"></a>mono女孩</h3><p><img src="https://atelieryu.xyz/elog/202503/87704935c7a772bc38b7da56d34fa0af.jpg" alt="mono女孩"></p><p>摇曳露营代餐其一，摇曳露营原作者的另一部作品，好像是摄影为主题的。没啥好说的，先追着</p><h3 id="杂旅"><a href="#杂旅" class="headerlink" title="杂旅"></a>杂旅</h3><p><img src="https://atelieryu.xyz/elog/202503/edda6f86ef1858c336da8a41b8c8a766.jpg" alt="杂旅"></p><p>摇曳露营代餐其二，以旅行为主题的作品，可能成为日本旅游guidebook，没啥好说的，先追着</p><h3 id="时光流逝-饭菜依旧美味"><a href="#时光流逝-饭菜依旧美味" class="headerlink" title="时光流逝 饭菜依旧美味"></a>时光流逝 饭菜依旧美味</h3><p><img src="https://atelieryu.xyz/elog/202503/efbc9571de508608f09524eb2076b0f6.jpg" alt="时光流逝 饭菜依旧美味"></p><p>PA的原创，以美食为主题，PA制作的下限一直都挺高，感觉是每一部都在认真做，但之前几部作品总是看着看着就觉得无聊弃坑了。这部也准备先追几集看看吧，毕竟PA的美少女画的都挺可爱的（</p><h3 id="忍者与杀手二人组的日常生活"><a href="#忍者与杀手二人组的日常生活" class="headerlink" title="忍者与杀手二人组的日常生活"></a>忍者与杀手二人组的日常生活</h3><p><img src="https://atelieryu.xyz/elog/202503/09116b1547639eceacb0964139a146cd.jpg" alt="忍者与杀手二人组的日常生活"></p><p><del>我超忍杀二</del>看pv女角色都蛮可爱的，但好像是主打反差的（指可爱的妹子下一集就惨死，<del>这也是末世之法的一个侧面</del>），看多了轻松日常番来点这类番调节一下也挺好？</p><h3 id="摇滚乐是淑女的嗜好"><a href="#摇滚乐是淑女的嗜好" class="headerlink" title="摇滚乐是淑女的嗜好"></a>摇滚乐是淑女的嗜好</h3><p><img src="https://atelieryu.xyz/elog/202503/5f397b019511285d4744731e99cddc39.jpg" alt="摇滚乐是淑女的嗜好"></p><p>最新的少女乐队番，看点好像是少女们边摇滚边颜艺彪垃圾话，emmm，这就是摇滚吗，总之先看几集吧</p><h3 id="启示录酒店"><a href="#启示录酒店" class="headerlink" title="启示录酒店"></a>启示录酒店</h3><p><img src="https://atelieryu.xyz/elog/202503/bfd937ede8da9855f132a7f05fb2cb40.jpg" alt="启示录酒店"></p><p>Cy的一部原创番，看设定有点像几年前的星之梦，但看pv2又有点闹腾，可能会是那种欢乐日常中带点刀的单元剧？制作看起来不错，期待表现（Cy主力不会在这吧）。</p><h3 id="搞笑漫画日和-第5期"><a href="#搞笑漫画日和-第5期" class="headerlink" title="搞笑漫画日和 第5期"></a>搞笑漫画日和 第5期</h3><p><img src="https://atelieryu.xyz/elog/202503/9fca3b749d3f31e6217e171e45f373a0.jpg" alt="搞笑漫画日和 第5期"></p><p>这是真童年了啊，入动画坑前就看过的作品，产出的不少梗到今天还有生命力。不知道隔了这么久的动画化还是不是内味（也有可能我的口味变了，导致看不进去了，唉）</p><h3 id="乡下大叔成为剑圣"><a href="#乡下大叔成为剑圣" class="headerlink" title="乡下大叔成为剑圣"></a>乡下大叔成为剑圣</h3><p><img src="https://atelieryu.xyz/elog/202503/beb32691702746a2cd938a72a367afdb.jpg" alt="乡下大叔成为剑圣"></p><p>之前吃安利看过原作，原作剧情比较平庸，但画的分镜和动作相当出色，角色的动作真的能让人感受到武术的美感。动画不知道能不能体现好</p><h3 id="阳光马达棒球场"><a href="#阳光马达棒球场" class="headerlink" title="阳光马达棒球场"></a>阳光马达棒球场</h3><p><img src="https://atelieryu.xyz/elog/202503/2b670f8bceef549d680cc1f41ada8f37.jpg" alt="阳光马达棒球场"></p><p>好像讲的不是棒球，而是围绕棒球的各类人群（看客、售货员、解说等）的群像剧。有点兴趣，感觉有成为泛鸽鸽每周六直播间下播番的潜力</p><h3 id="拜托请穿上-鹰峰同学"><a href="#拜托请穿上-鹰峰同学" class="headerlink" title="拜托请穿上 鹰峰同学"></a>拜托请穿上 鹰峰同学</h3><p><img src="https://atelieryu.xyz/elog/202503/eca1c2b813c2442060670f8deb5a0181.jpg" alt="拜托请穿上 鹰峰同学"></p><p>福利番一号，还有表里版。十年前我还觉得看这种卖肉番不如去看里番，而在现在里番业界不断走下坡，真得表番来当里番代餐了。这部人设还挺好看的，可能会看？</p><h3 id="快藏起来-玛琪娜同学"><a href="#快藏起来-玛琪娜同学" class="headerlink" title="快藏起来 玛琪娜同学"></a>快藏起来 玛琪娜同学</h3><p><img src="https://atelieryu.xyz/elog/202503/a9e3bbafe2b4048dd06161a3c16fca65.jpg" alt="快藏起来 玛琪娜同学"></p><p>福利番二号，性x机器人，总觉得能看到未来（</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info modern&quot;&gt;&lt;p&gt;食用说明&lt;/p&gt;
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;本文更偏向追番体验的记录，可能与补番体验略有不同&lt;/li&gt;
&lt;li&gt;本文评分体系近似bangumi，以下为分数区间参考含义&lt;ul&gt;
&lt;li&gt;&amp;gt;9：全人类都应</summary>
      
    
    
    
    <category term="ACGN" scheme="https://atelieryu.site/categories/ACGN/"/>
    
    
    <category term="追番记录" scheme="https://atelieryu.site/tags/%E8%BF%BD%E7%95%AA%E8%AE%B0%E5%BD%95/"/>
    
    <category term="动画" scheme="https://atelieryu.site/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>基于Elog的 Notion-hexo 同步方案</title>
    <link href="https://atelieryu.site/posts/3bcc203.html"/>
    <id>https://atelieryu.site/posts/3bcc203.html</id>
    <published>2025-03-16T03:37:00.000Z</published>
    <updated>2025-03-16T14:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客工具"><a href="#博客工具" class="headerlink" title="博客工具"></a>博客工具</h1><ul><li>写作平台：<a href="https://www.notion.so/">Notion</a></li><li>博客平台：<a href="https://hexo.io/">Hexo</a></li><li>博客主题：<a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></li><li>博客文档同步：<a href="https://github.com/LetTTGACO/elog">Elog</a></li><li>原项目仓库：<a href="https://github.com/elog-x/notion-hexo">https://github.com/elog-x/notion-hexo</a></li></ul><h1 id="博客搭建指南"><a href="#博客搭建指南" class="headerlink" title="博客搭建指南"></a>博客搭建指南</h1><h2 id="Fork模板仓库"><a href="#Fork模板仓库" class="headerlink" title="Fork模板仓库"></a>Fork模板仓库</h2><p>将<a href="https://github.com/elog-x/notion-hexo">模板仓库</a> clone 到本地</p><h3 id="之前已经有博客的情况"><a href="#之前已经有博客的情况" class="headerlink" title="之前已经有博客的情况"></a>之前已经有博客的情况</h3><ol><li><p>使用旧博客文件<strong>覆盖</strong>博客仓库</p></li><li><p>修改<code>package.json</code>中的依赖：</p> <figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;hexo generate&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;hexo clean&quot;,</span><br><span class="line">    &quot;deploy&quot;: &quot;hexo deploy&quot;,</span><br><span class="line"><span class="addition">+   &quot;server&quot;: &quot;hexo clean &amp;&amp; hexo server&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;sync:local&quot;: &quot;elog sync -e .elog.env&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;elog:init&quot;: &quot;elog init&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;sync&quot;: &quot;elog sync&quot;,</span></span><br><span class="line"><span class="addition">+   &quot;elog:clean&quot;: &quot;elog clean&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;7.3.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line"><span class="addition">+   &quot;@elog/cli&quot;: &quot;^0.14.0&quot;,</span></span><br><span class="line">    &quot;hexo&quot;: &quot;^7.0.0&quot;,</span><br><span class="line">    &quot;hexo-abbrlink&quot;: &quot;^2.2.1&quot;,</span><br><span class="line">    &quot;hexo-bilibili-bangumi&quot;: &quot;^1.10.8&quot;,</span><br><span class="line">    &quot;hexo-butterfly-categories-card&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">    &quot;hexo-butterfly-clock-anzhiyu&quot;: &quot;^1.1.8&quot;,</span><br><span class="line">    &quot;hexo-butterfly-envelope&quot;: &quot;^1.0.15&quot;,</span><br><span class="line">    &quot;hexo-butterfly-footer-beautify&quot;: &quot;^1.0.6&quot;,</span><br><span class="line">    &quot;hexo-butterfly-tag-plugins-plus&quot;: &quot;^1.0.18&quot;,</span><br><span class="line">    &quot;hexo-butterfly-wowjs&quot;: &quot;^1.0.5&quot;,</span><br><span class="line">    &quot;hexo-deployer-git&quot;: &quot;^4.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-feed&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-generator-search&quot;: &quot;^2.4.3&quot;,</span><br><span class="line">    &quot;hexo-generator-sitemap&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^2.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-kramed&quot;: &quot;^0.1.4&quot;,</span><br><span class="line"><span class="addition">+   &quot;hexo-renderer-marked&quot;: &quot;^6.0.0&quot;,</span></span><br><span class="line">    &quot;hexo-renderer-pug&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^3.0.0&quot;,</span><br><span class="line">    &quot;hexo-tag-aplayer&quot;: &quot;^3.0.4&quot;,</span><br><span class="line">    &quot;hexo-theme-landscape&quot;: &quot;^1.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.9&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继续后续操作</p></li></ol><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>在项目根目录下运行命令安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="新建-Elog-本地调试文件"><a href="#新建-Elog-本地调试文件" class="headerlink" title="新建 Elog 本地调试文件"></a><strong>新建 Elog 本地调试文件</strong></h2><ol><li>将<code>.elog.example.env</code>文件重命名为<code>.elog.env</code>，此文件将用于本地同步Notion 文档</li></ol><h2 id="配置-Notion-关键信息"><a href="#配置-Notion-关键信息" class="headerlink" title="配置 Notion 关键信息"></a>配置 Notion 关键信息</h2><h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><ol><li>使用 <a href="https://1874.notion.site/09ff9e1e141744c6af0a1f69d2a3d834?v=a09065f9266446afa745b475044daca6"><strong>Database 模板</strong></a> 创建数据库副本或增加必要属性到已有 Notion 数据库<ul><li>博客平台为Hexo时，可参考<a href="https://1874.notion.site/867486af567f4a8897427b15ffd10b3c?v=a25aec8e27d5415e8605e43034f822bd"><strong>elog-hexo-template</strong></a> 创建数据库副本或增加必要属性到已有 Notion 数据库</li></ul></li><li>创建 Integration Token，具体请参考 <a href="https://developers.notion.com/docs/create-a-notion-integration#create-your-integration-in-notion"><strong>Notion 官方教程</strong></a></li><li>将复制的数据库连接到刚创建的 Integration，具体请参考 <a href="https://developers.notion.com/docs/create-a-notion-integration#give-your-integration-page-permissions"><strong>Notion 官方教程</strong></a></li><li>获取数据库 DatabaseId</li></ol><p>按照<a href="https://elog.1874.cool/notion/gvnxobqogetukays#notion">文档提示</a>配置 Notion 并获取 <code>token</code> 和 <code>databaseId</code>，在本地<code>.elog.env</code>中写入</p><figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOTION_TOKEN=获取的token</span><br><span class="line">NOTION_DATABASE_ID=获取的databaseId</span><br></pre></td></tr></table></figure><h3 id="配置Notion-Database"><a href="#配置Notion-Database" class="headerlink" title="配置Notion Database"></a>配置Notion Database</h3><p>示例：</p><p><img src="https://atelieryu.xyz/elog-image-plugin-test/a2be76ee2e6a013e213586a7e524b722.png" alt="image.png"></p><p>Database字段：</p><ul><li><code>permalink</code>为文档的永久链接，例如<code>https://notion-hexo.vercel.app/notion-hexo/</code>，注意记得在结尾加上<code>/</code></li><li><code>categories</code>为文档的分类</li><li><code>tags</code> 为文档的标签</li><li><code>description</code>为主题配置中可选的文档描述</li></ul><h3 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h3><ol><li><p>登录Notion 网页版 &#x3D;&gt;访问<a href="https://www.notion.so/my-integrations">My integrations</a> &#x3D;&gt;New Integration &#x3D;&gt; 生成 Internal Integration Token</p><p> <img src="https://atelieryu.xyz/elog-image-plugin-test/2a01b8634fd5897a79a9fa367d6502c2.png" alt="image.png"></p></li><li><p>Internal Intergration Secret即为token</p><p> <img src="https://atelieryu.xyz/elog-image-plugin-test/35735ef273abc3537dad0072dec232f5.png" alt="image.png"></p></li><li><p>在使用的Notion Database页面点击右上角设置→Connections，选择刚才创建的Integration</p><p> <img src="https://atelieryu.xyz/elog-image-plugin-test/bc53f185657c5009ec62d22aafdb14ed.png" alt="image.png"></p></li></ol><p>其他注意事项：</p><ul><li>notion文章必须有封面（cover），否则同步会失败</li></ul><h3 id="获取DatabaseId"><a href="#获取DatabaseId" class="headerlink" title="获取DatabaseId"></a>获取DatabaseId</h3><p>图中url中红框部分（1b8a0f24b32980ca9c66cbc557236562）即为DatabaseId</p><p><img src="https://atelieryu.xyz/elog-image-plugin-test/3ec5b264fea657120d4bf98a8801b77c.png" alt="029401505f8359601294e9d4af319792.png"></p><h2 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h2><p>在项目根目录运行同步命令，Notion Database中的文章就会被全部同步值本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm run sync:local</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line">elog sync -e .elog.env</span><br></pre></td></tr></table></figure><h1 id="Elog配置CloudFlare-R2图床"><a href="#Elog配置CloudFlare-R2图床" class="headerlink" title="Elog配置CloudFlare R2图床"></a>Elog配置CloudFlare R2图床</h1><p><a href="https://github.com/LetTTGACO/elog/tree/master/plugins/plugin-img-r2#readme">官方插件文档</a></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a><strong>安装插件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @elog/plugin-img-r2</span><br></pre></td></tr></table></figure><h2 id="配置-elog-config-js"><a href="#配置-elog-config-js" class="headerlink" title="配置 elog.config.js"></a><strong>配置 elog.config.js</strong></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// elog.config.js</span></span><br><span class="line"><span class="keyword">const</span> r2 = <span class="built_in">require</span>(<span class="string">&#x27;@elog/plugin-img-r2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="attr">image</span>: &#123;</span><br><span class="line">    <span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">plugin</span>: r2,</span><br><span class="line">    <span class="attr">r2</span>: &#123;</span><br><span class="line">      <span class="attr">accessKeyId</span>: process.<span class="property">env</span>.<span class="property">R2_ACCESSKEYID</span>,</span><br><span class="line">      <span class="attr">secretAccessKey</span>: process.<span class="property">env</span>.<span class="property">R2_SECRET_ACCESSKEY</span>,</span><br><span class="line">      <span class="attr">bucket</span>: process.<span class="property">env</span>.<span class="property">R2_BUCKET</span>,</span><br><span class="line">      <span class="attr">endpoint</span>: process.<span class="property">env</span>.<span class="property">R2_ENDPOINT</span>,</span><br><span class="line">      <span class="attr">host</span>: process.<span class="property">env</span>.<span class="property">R2_HOST</span>,</span><br><span class="line">      <span class="attr">prefixKey</span>: <span class="string">&#x27;elog-image-plugin-test&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置-elog-env文件"><a href="#配置-elog-env文件" class="headerlink" title="配置 .elog.env文件"></a>配置 .elog.env文件</h2><p>在 .elog.env 中插入以下信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .elog.env 配置R2 相关账号参数</span></span><br><span class="line"><span class="comment">#R2</span></span><br><span class="line"><span class="comment"># 访问密钥 ID</span></span><br><span class="line"><span class="string">R2_ACCESSKEYID=</span></span><br><span class="line"><span class="comment"># 机密访问密钥</span></span><br><span class="line"><span class="string">R2_SECRET_ACCESSKEY=</span></span><br><span class="line"><span class="string">R2_ENDPOINT=</span></span><br><span class="line"><span class="comment"># R2 需要使r2.dev子域供网络访问或者绑定自己的域名</span></span><br><span class="line"><span class="string">R2_HOST=</span></span><br><span class="line"><span class="string">R2_BUCKET=</span></span><br></pre></td></tr></table></figure><ul><li>R2_ACCESSKEYID、R2_SECRET_ACCESSKEY、R2_ENDPOINT：API令牌中查看</li><li>R2_HOST：生成的R2.dev子域 或 自己的域名</li><li>R2_BUCKET：存储桶的名称</li></ul><p><img src="https://atelieryu.xyz/elog-image-plugin-test/cb3779952158c30a0a2591b0797040e9.png" alt="image.png"></p><p>令牌信息仅在创建令牌时显示一次，之后无法再次查看，如需查看只能选择轮转重新生成令牌信息。</p><p><img src="https://atelieryu.xyz/elog-image-plugin-test/76cd80a3e9d22864fee2c756afaea01f.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;博客工具&quot;&gt;&lt;a href=&quot;#博客工具&quot; class=&quot;headerlink&quot; title=&quot;博客工具&quot;&gt;&lt;/a&gt;博客工具&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;写作平台：&lt;a href=&quot;https://www.notion.so/&quot;&gt;Notion&lt;/a&gt;&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="技术随记" scheme="https://atelieryu.site/categories/%E6%8A%80%E6%9C%AF%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="elog" scheme="https://atelieryu.site/tags/elog/"/>
    
    <category term="notion" scheme="https://atelieryu.site/tags/notion/"/>
    
    <category term="hexo" scheme="https://atelieryu.site/tags/hexo/"/>
    
  </entry>
  
</feed>
