<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++高性能服务器框架Sylar（二）——配置模块 | Yu的炼金工房</title><meta name="author" content="Yu"><meta name="copyright" content="Yu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="模块概述基于YAML配置文件实现的一个配置模块  难点：Lexical_cast的泛化与偏特化实现 设计点： 将配置项ConfigVar抽象出虚基类ConfigVarBase，使得Config可以通过多态机制统一管理配置类 通过Lexical_cast，将“支持更多的类型”，变为“支持更多类型的Lexcial_cast偏特化实现”    配置项概述一项配置应该包括以下要素：  名称：对应一个字符串">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高性能服务器框架Sylar（二）——配置模块">
<meta property="og:url" content="https://atelieryu.site/Sylar%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97">
<meta property="og:site_name" content="Yu的炼金工房">
<meta property="og:description" content="模块概述基于YAML配置文件实现的一个配置模块  难点：Lexical_cast的泛化与偏特化实现 设计点： 将配置项ConfigVar抽象出虚基类ConfigVarBase，使得Config可以通过多态机制统一管理配置类 通过Lexical_cast，将“支持更多的类型”，变为“支持更多类型的Lexcial_cast偏特化实现”    配置项概述一项配置应该包括以下要素：  名称：对应一个字符串">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atelieryu.xyz/elog/202504/b1738be865fb17e115bb8938b3f4b2ec.jpg">
<meta property="article:published_time" content="2025-04-01T03:40:00.000Z">
<meta property="article:modified_time" content="2025-04-02T08:07:00.000Z">
<meta property="article:author" content="Yu">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="服务器框架">
<meta property="article:tag" content="YAML">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atelieryu.xyz/elog/202504/b1738be865fb17e115bb8938b3f4b2ec.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++高性能服务器框架Sylar（二）——配置模块",
  "url": "https://atelieryu.site/Sylar%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97",
  "image": "https://atelieryu.xyz/elog/202504/b1738be865fb17e115bb8938b3f4b2ec.jpg",
  "datePublished": "2025-04-01T03:40:00.000Z",
  "dateModified": "2025-04-02T08:07:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu",
      "url": "https://atelieryu.site/"
    }
  ]
}</script><link rel="shortcut icon" href="https://atelieryu.xyz/PicGo/shizuku.png"><link rel="canonical" href="https://atelieryu.site/Sylar%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#3F4F44')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++高性能服务器框架Sylar（二）——配置模块',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://fastly.jsdelivr.net/npm/pace-js@latest/pace.min.js"></script><link rel="stylesheet" href="/css/corner-indicator.css" /><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://fastly.jsdelivr.net/combine/gh/dylanNew/live2d/webgl/Live2D/lib/live2d.min.js,npm/pixi.js@6.5.2/dist/browser/pixi.min.js,npm/pixi-live2d-display/dist/index.min.js,gh/Weidows-projects/Live2dLoader/dist/Live2dLoader.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Yu的炼金工房" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/kurumi.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-pink"></use></svg><span> 追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chaxun"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://atelieryu.xyz/elog/202504/b1738be865fb17e115bb8938b3f4b2ec.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/shizuku_logo.png" alt="Logo"><span class="site-name">Yu的炼金工房</span></a><a class="nav-page-title" href="/"><span class="site-name">C++高性能服务器框架Sylar（二）——配置模块</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-pink"></use></svg><span> 追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chaxun"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++高性能服务器框架Sylar（二）——配置模块</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-01T03:40:00.000Z" title="发表于 2025-04-01 11:40:00">2025-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-02T08:07:00.000Z" title="更新于 2025-04-02 16:07:00">2025-04-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.4k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h1><p>基于YAML配置文件实现的一个配置模块</p>
<ul>
<li>难点：Lexical_cast的泛化与偏特化实现</li>
<li>设计点：<ul>
<li>将配置项ConfigVar抽象出虚基类ConfigVarBase，使得Config可以通过多态机制统一管理配置类</li>
<li>通过Lexical_cast，将“支持更多的类型”，变为“支持更多类型的Lexcial_cast偏特化实现”</li>
</ul>
</li>
</ul>
<h2 id="配置项概述"><a href="#配置项概述" class="headerlink" title="配置项概述"></a>配置项概述</h2><p>一项配置应该包括以下要素：</p>
<ol>
<li>名称：对应一个字符串，必须唯一，不能与其他配置项产生冲突。支持名称的层级，如<code>tcp.connect.timeout</code></li>
<li>类型：支持基本类型、复杂类型（STL）和自定义类型。</li>
<li>值：配置项的值</li>
<li>默认值：考虑到用户不一定总是会显式地给配置项赋值，所以配置项最好有一个默认值（约定优于配置）</li>
<li>配置变更通知：一旦用户更新了配置值，那么应该通知所有使用了这项配置的代码，以便于进行一些具体的操作，比如重新打开文件，重新起监听端口等。</li>
<li>校验方法：更新配置时会调用校验方法进行校验，以保证用户不会给配置项设置一个非法的值。</li>
</ol>
<h2 id="配置模块功能概述"><a href="#配置模块功能概述" class="headerlink" title="配置模块功能概述"></a>配置模块功能概述</h2><p>本项目配置模块具备的基本功能：</p>
<ol>
<li>支持定义&#x2F;声明配置项：也就是在提供配置名称、类型以及可选的默认值的情况下生成一个可用的配置项。</li>
<li>支持更新配置项的值：用户可以使用新的值来覆盖掉原来的值。</li>
<li>支持从预置的途径中加载配置项：一般是配置文件。支持基本数据类型与复杂数据类型的加载，比如直接从配置文件中加载一个map类型的配置项，或是直接从一个预定格式的配置文件中加载一个自定义结构体。</li>
<li>支持给配置项注册配置变更通知：用户可以为配置项注册回调函数，让程序知道某项配置被修改了，以便于进行一些操作。比如对于网络服务器而言，如果服务器端口配置变化了，那程序应该重新起监听端口。由于一项配置可能在多个地方引用，所以配置变更回调函数是一个数组的形式。</li>
<li>支持导出当前配置：将当前配置导出为YAML字符串</li>
</ol>
<p>待实现的功能：</p>
<ol>
<li>支持给配置项设置校验方法：配置项在定义时也可以指定一个校验方法，以保证该项配置不会被设置成一个非法的值，比如对于文件路径类的配置，可以通过校验方法来确保该路径一定存在。</li>
<li>从命令行参数或是网络服务器中加载配置项</li>
</ol>
<h1 id="Yaml"><a href="#Yaml" class="headerlink" title="Yaml"></a>Yaml</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Yaml书写方式比较简单，主要注意缩进问题</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Person information</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">street:</span> <span class="number">123</span> <span class="string">Main</span> <span class="string">St</span></span><br><span class="line">    <span class="attr">city:</span> <span class="string">Somewhere</span></span><br><span class="line">    <span class="attr">country:</span> <span class="string">USA</span></span><br><span class="line">  <span class="attr">hobbies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">reading</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hiking</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">coding</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A list of items</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">orange</span></span><br></pre></td></tr></table></figure>


<h3 id="键值对（Mapping）"><a href="#键值对（Mapping）" class="headerlink" title="键值对（Mapping）"></a><strong>键值对（Mapping）</strong></h3><p>键值对使用 <code>:</code> 进行分隔，键和值之间用空格分开。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">John</span> <span class="string">Doe</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure>


<h3 id="列表（Sequence）"><a href="#列表（Sequence）" class="headerlink" title="列表（Sequence）"></a><strong>列表（Sequence）</strong></h3><p>列表元素前使用 <code>-</code> 符号进行标记。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fruits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">apple</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">banana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cherry</span></span><br></pre></td></tr></table></figure>


<h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a><strong>嵌套结构</strong></h3><p>YAML 使用<strong>缩进</strong>来表示嵌套结构。通常使用<strong>2个空格</strong>作为缩进。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Alice</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">28</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">street:</span> <span class="number">123</span> <span class="string">Main</span> <span class="string">St</span></span><br><span class="line">    <span class="attr">city:</span> <span class="string">Wonderland</span></span><br></pre></td></tr></table></figure>


<h3 id="注释（Comments）"><a href="#注释（Comments）" class="headerlink" title="注释（Comments）"></a><strong>注释（Comments）</strong></h3><p>注释以 <code>#</code> 开头，注释内容会被忽略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">John</span> <span class="string">Doe</span>  <span class="comment"># Inline comment</span></span><br></pre></td></tr></table></figure>


<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a><strong>多行字符串</strong></h3><p>使用 <code>|</code> 或 <code>&gt;</code> 来表示多行字符串。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">  This is a multi-line</span></span><br><span class="line"><span class="string">  string that keeps line breaks.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="attr">note:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">  This is a folded</span></span><br><span class="line"><span class="string">  multi-line string that</span></span><br><span class="line"><span class="string">  turns into a single line.</span></span><br></pre></td></tr></table></figure>


<h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a><strong>复杂数据类型</strong></h3><p>YAML 支持复杂数据类型，如时间、日期、布尔值等。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date:</span> <span class="number">2024-12-25</span></span><br><span class="line"><span class="attr">boolean:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>


<h2 id="yaml-cpp"><a href="#yaml-cpp" class="headerlink" title="yaml-cpp"></a>yaml-cpp</h2><p>项目中主要使用yaml-cpp来进行yaml文件的解析</p>
<h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><ul>
<li>方法1：apt安装依赖：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install libyaml-cpp-dev</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：git从源码安装最新版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jbeder/yaml-cpp.git</span><br><span class="line"><span class="built_in">cd</span> yaml-cpp</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>


<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>本项目中只使用部分Api，对于yaml-cpp掌握下面这些即可：</p>
<blockquote>
<p>YAML::NodeType</p>
</blockquote>
<p>yaml-cpp会自动解析Yaml字符串，并将解析结果变为以下几种YAML::NodeType：</p>
<ul>
<li>Scalar：简单类型</li>
<li>Map：键值对</li>
<li>Sequence：列表</li>
</ul>
<blockquote>
<p>Yaml的加载</p>
</blockquote>
<ul>
<li>YAML::Load：从字符串中加载YAML::Node</li>
<li>YAML::LoadFile：从文件中加载YAML::Node</li>
</ul>
<h1 id="配置模块设计"><a href="#配置模块设计" class="headerlink" title="配置模块设计"></a>配置模块设计</h1><h2 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h2><div class="note info modern"><p>约定优于配置的方式可以减少程序员做决定的数量，获得简单的好处，同时兼顾灵活性。</p>
</div>

<p>配置模块采用约定优于配置的思想，参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE">维基百科：约定优于配置</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1424634">如何理解 SpringBoot 中的约定优于配置 - 云+社区 - 腾讯云</a></li>
</ul>
<p>简单来说，约定优于配置的背景条件是，一般来说，程序所依赖的配置项都有一个公认的默认值，也就是所谓的约定。这点有可许多可以参考的例子，比如对于一个http网络服务器，服务端口通常都是80端口，对于配置文件夹路径，一般都是conf文件夹，对于数据库目录，一般都是db或data文件夹。对于这些具有公认约定的配置，就不需要麻烦程序员在程序跑起来后再一项一项地指定了，而是可以初始时就将配置项设置成对应的值。这样，程序员就可以**<span class='p red'>只修改那些约定之外的配置项，然后以最小的代价让程序跑起来</span>**。</p>
<p>在代码上，约定优于配置的思路体现为所有的配置项在定义时都带一个的默认值，以下是一个sylar配置项的示例，这是一个int类型的配置项，名称为<code>tcp.connect.timeout</code>，初始值为5000。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> sylar::ConfigVar&lt;<span class="type">int</span>&gt;::ptr g_tcp_connect_timeout = \</span><br><span class="line">	sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;tcp.connect.timeout&quot;</span>, <span class="number">5000</span>, <span class="string">&quot;tcp connect timeout&quot;</span>);</span><br></pre></td></tr></table></figure>


<p>该配置项转换为YAML配置文件后如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tcp:</span></span><br><span class="line">  <span class="attr">connect:</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>


<h2 id="模块中的类"><a href="#模块中的类" class="headerlink" title="模块中的类"></a>模块中的类</h2><h3 id="ConfigVarBase"><a href="#ConfigVarBase" class="headerlink" title="ConfigVarBase"></a>ConfigVarBase</h3><p>配置项抽象类，定义了配置项公有的成员和方法：</p>
<ul>
<li>配置项的公有成员：<ul>
<li><code>name</code>：配置项的名称</li>
<li><code>description</code>：配置项的描述</li>
</ul>
</li>
<li>配置项的公有方法，两个纯虚函数，由派生类负责实现：<ul>
<li><code>toString</code>：将配置项转换为YAML字符串</li>
<li><code>fromString</code>：从YAML字符串中载入配置项</li>
</ul>
</li>
</ul>
<h3 id="ConfigVar："><a href="#ConfigVar：" class="headerlink" title="ConfigVar："></a>ConfigVar：</h3><p>每个配置项对应一个ConfigVar对象</p>
<p>是一个模板类，有三个模板参数：</p>
<ul>
<li><code>T</code>：配置项的类型</li>
<li><code>FromStr</code>、<code>ToStr</code>：两个仿函数，用于进行YAML字符串与配置项类型T之间的转换，是<strong>实现的重点</strong>，不同类型的配置项需要各自实现它们的偏特化版本</li>
</ul>
<p>继承自ConfigVarBase（相当于定义了ConfigVarBase的一系列派生类），在其基础上实现了还需要实现以下功能：</p>
<ul>
<li>对配置项数值的更新&#x2F;获取操作：<code>setValue</code> &#x2F; <code>getValue</code></li>
<li>对配置项的监听回调：<code>addListener</code> &#x2F; <code>delListener</code></li>
</ul>
<h3 id="Config："><a href="#Config：" class="headerlink" title="Config："></a>Config：</h3><p>一个单例类（但单例的实现方式与普通的单例模式有所不同），使用map管理ConfigVar配置项</p>
<p>实现了以下方法：</p>
<ul>
<li><code>Lookup</code>：可以在容器中查找&#x2F;新增配置项</li>
<li><code>LoadFromYaml</code>：从YAML文件中载入配置项</li>
</ul>
<h1 id="模块实现"><a href="#模块实现" class="headerlink" title="模块实现"></a>模块实现</h1><h2 id="ConfigVarBase-1"><a href="#ConfigVarBase-1" class="headerlink" title="ConfigVarBase"></a>ConfigVarBase</h2><p>抽象基类，简单定义了get&#x2F;set方法，以及两个纯虚函数<code>fromString</code>和<code>toString</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConfigVarBase</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;ConfigVarBase&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConfigVarBase</span>(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; description = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        :<span class="built_in">m_name</span>(name)</span><br><span class="line">        ,<span class="built_in">m_description</span>(description)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ConfigVarBase</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getDescription</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_description; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">getTypename</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将配置参数的值转换为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">toString</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符串中获取配置参数初始值</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">fromString</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置参数的名称</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="comment">// 配置参数的描述</span></span><br><span class="line">    std::string m_description;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="ConfigVar"><a href="#ConfigVar" class="headerlink" title="ConfigVar"></a>ConfigVar</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FromStr和ToStr：两个仿函数，用于将字符串转换为数值类型 / 将数值转换为字符串</span></span><br><span class="line"><span class="comment">// FromStr: T operator(const std::string&amp;)</span></span><br><span class="line"><span class="comment">// ToStr: std::string operator(const T&amp;)</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> FromStr = Lexical_cast&lt;std::string, T&gt;</span><br><span class="line">                   , <span class="keyword">typename</span> ToStr = Lexical_cast&lt;T, std::string&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> ConfigVar: <span class="keyword">public</span> ConfigVarBase&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;ConfigVar&gt;;</span><br><span class="line">    <span class="keyword">using</span> on_change_cb = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> T&amp; oldVal, <span class="type">const</span> T&amp; newVal)&gt;;</span><br><span class="line">    <span class="keyword">using</span> RWMutexType = RWMutex;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ConfigVar</span>(<span class="type">const</span> std::string&amp; name</span><br><span class="line">            , <span class="type">const</span> T&amp; val</span><br><span class="line">            , <span class="type">const</span> std::string&amp; description = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        : <span class="built_in">ConfigVarBase</span>(name, description)</span><br><span class="line">        , <span class="built_in">m_val</span>(val)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ToStr()将配置值转换为Yaml字符串返回</span></span><br><span class="line">    <span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="comment">// return boost::lexical_cast&lt;std::string&gt;(m_val);</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ToStr</span>()(m_val);</span><br><span class="line">        &#125; <span class="built_in">catch</span>(std::exception&amp; e) &#123;</span><br><span class="line">            <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;ConfigVar::toString exception: &quot;</span></span><br><span class="line">                &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot; convert: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(m_val).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; to string&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用FromStr()将Yaml字符串解析为配置值</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">fromString</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// setValue 中进行了加锁操作，这里不需要额外加锁</span></span><br><span class="line">            <span class="comment">// m_val = boost::lexical_cast&lt;T&gt;(val);</span></span><br><span class="line">            <span class="built_in">setValue</span>(<span class="built_in">FromStr</span>()(val));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="built_in">catch</span>(std::exception&amp; e) &#123;</span><br><span class="line">            <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;ConfiVar::fromString exception: &quot;</span></span><br><span class="line">                &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot; convert string to &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(m_val).<span class="built_in">name</span>(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置项的值</span></span><br><span class="line">    <span class="function"><span class="type">const</span> T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置配置项的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先读后写</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 使用&#123;&#125;来控制RAII类的作用范围</span></span><br><span class="line">            <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(val == m_val)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果配置项的值发生了变化，通知所有回调函数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> cb : m_cbs)&#123;</span><br><span class="line">                cb.<span class="built_in">second</span>(m_val, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">RWMutexType::WriteLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getTypename</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">typeid</span>(T).<span class="built_in">name</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加回调函数，返回该回调函数的唯一id</span></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">addListener</span><span class="params">(on_change_cb cb)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 自动创建回调函数对应的key</span></span><br><span class="line">        <span class="type">static</span> <span class="type">uint64_t</span> s_cbfun_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">RWMutexType::WriteLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        ++s_cbfun_id;</span><br><span class="line">        m_cbs[s_cbfun_id] = cb;</span><br><span class="line">        <span class="keyword">return</span> s_cbfun_id;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delListener</span><span class="params">(<span class="type">uint64_t</span> key)</span></span>&#123;</span><br><span class="line">        <span class="function">RWMutexType::WriteLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_cbs.<span class="built_in">erase</span>(key);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">on_change_cb <span class="title">getListener</span><span class="params">(<span class="type">uint64_t</span> key)</span></span>&#123;</span><br><span class="line">        <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">auto</span> it = m_cbs.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">return</span> it == m_cbs.<span class="built_in">end</span>() ? <span class="literal">nullptr</span> : it-&gt;second;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="function">RWMutexType::WriteLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_cbs.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置项的值</span></span><br><span class="line">    T m_val;</span><br><span class="line">    <span class="comment">// 管理回调函数的map</span></span><br><span class="line">    std::map&lt;<span class="type">uint64_t</span>, on_change_cb&gt; m_cbs;</span><br><span class="line">    <span class="comment">// 读写锁</span></span><br><span class="line">    <span class="keyword">mutable</span> RWMutexType m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h3><p>由于配置项一般为<strong>读多写少</strong>，所以使用<strong>读写锁</strong>保证ConfigVar的线程安全</p>
<h3 id="Lexical-cast"><a href="#Lexical-cast" class="headerlink" title="Lexical_cast"></a>Lexical_cast</h3><div class="note info modern"><p>支持更多类型，在于支持更多类型的Lexical_cast特化版本</p>
</div>


<p>一个仿函数类，用于封装<code>boost::lexical_cast</code>，支持<code>ToStr</code>和<code>FromStr</code>的实现</p>
<pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> FromStr = Lexical_cast&lt;std::string, T&gt;;</span><br><span class="line"><span class="keyword">typename</span> ToStr = Lexical_cast&lt;T, std::string&gt;;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>Lexical_cast泛化与特化两个版本</p>
<ul>
<li><p>泛化版本，可直接用作简单类型的转换，或被其他特化版本递归调用</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F：转换源类型；T：转换目标类型</span></span><br><span class="line"><span class="comment">// 泛化的版本，可直接用作简单类型的转换，或被其他特化版本递归调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> F&amp; val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boost::<span class="built_in">lexical_cast</span>&lt;T&gt;(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特化版本，用于<strong>扩展支持更多类型</strong>的配置项，如STL、用户自定义类型</p>
</li>
</ul>
<h3 id="toString-fromString"><a href="#toString-fromString" class="headerlink" title="toString &#x2F; fromString"></a>toString &#x2F; fromString</h3><p>调用模板传入的仿函数<code>ToStr</code>&#x2F;<code>FromStr</code>即可，注意读写锁的上锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用ToStr()将配置值转换为Yaml字符串返回</span></span><br><span class="line">  <span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">          <span class="comment">// return boost::lexical_cast&lt;std::string&gt;(m_val);</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">ToStr</span>()(m_val);</span><br><span class="line">      &#125; <span class="built_in">catch</span>(std::exception&amp; e) &#123;</span><br><span class="line">          <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;ConfigVar::toString exception: &quot;</span></span><br><span class="line">              &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot; convert: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(m_val).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; to string&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用FromStr()将Yaml字符串解析为配置值</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">fromString</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// setValue 中进行了加锁操作，这里不需要额外加锁</span></span><br><span class="line">          <span class="comment">// m_val = boost::lexical_cast&lt;T&gt;(val);</span></span><br><span class="line">          <span class="built_in">setValue</span>(<span class="built_in">FromStr</span>()(val));</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="built_in">catch</span>(std::exception&amp; e) &#123;</span><br><span class="line">          <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;ConfiVar::fromString exception: &quot;</span></span><br><span class="line">              &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot; convert string to &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(m_val).<span class="built_in">name</span>(); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>ConfigVar支持添加回调函数，并在配置项数值更新时自动通知所有的回调函数。ConfigVar使用一个map管理所有的回调函数，在添加回调函数时会自动分配一个id</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加回调函数，返回该回调函数的唯一id</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">addListener</span><span class="params">(on_change_cb cb)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 自动创建回调函数对应的key</span></span><br><span class="line">      <span class="type">static</span> <span class="type">uint64_t</span> s_cbfun_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function">RWMutexType::WriteLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">      ++s_cbfun_id;</span><br><span class="line">      m_cbs[s_cbfun_id] = cb;</span><br><span class="line">      <span class="keyword">return</span> s_cbfun_id;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>


<p>setValue中配置项值更新完成后通知所有回调：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置配置项的值</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">const</span> T&amp; val)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 先读后写</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">// 使用&#123;&#125;来控制RAII类的作用范围</span></span><br><span class="line">          <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">          <span class="keyword">if</span>(val == m_val)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果配置项的值发生了变化，通知所有回调函数</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> cb : m_cbs)&#123;</span><br><span class="line">              cb.<span class="built_in">second</span>(m_val, val);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function">RWMutexType::WriteLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">      m_val = val;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ConfigVarMap = std::unordered_map&lt;std::string, ConfigVarBase::ptr&gt;;</span><br><span class="line">    <span class="keyword">using</span> RWMutexType = RWMutex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据name在容器中查找配置项</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">Lookup</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 这个Lookup版本只进行读操作，所以上读锁</span></span><br><span class="line">        <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(GetMutex())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">GetDatas</span>().<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span>(it != <span class="built_in">GetDatas</span>().<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// dynamic_pointer_cast可以理解为作用于shared_ptr上的dynamic_cast</span></span><br><span class="line">            <span class="keyword">return</span> std::dynamic_pointer_cast&lt;ConfigVar&lt;T&gt;&gt;(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在容器中查找配置项，如果找不到就尝试新增配置项</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">Lookup</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> T&amp; default_value, <span class="type">const</span> std::string&amp; description = <span class="string">&quot;&quot;</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; mp = <span class="built_in">GetDatas</span>();</span><br><span class="line">        <span class="comment">// 先上一个读锁，进行查询操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(GetMutex())</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(name);</span><br><span class="line">            <span class="keyword">if</span>(it != <span class="built_in">GetDatas</span>().<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> Config::<span class="built_in">pointer_cast</span>&lt;T&gt;(name, it-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查name中是否所有字符都合法</span></span><br><span class="line">        <span class="keyword">if</span>(name.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;1234567890._abcdefghijklmnopqrstuvwxyz&quot;</span>)</span><br><span class="line">            != std::string::npos)&#123;</span><br><span class="line">            <span class="comment">// name中存在非法字符，写入错误log并抛出invalid_argument异常</span></span><br><span class="line">            <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name invalid: &quot;</span> &lt;&lt; name;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查询失败，就尝试在容器中新增一个配置参数项</span></span><br><span class="line">        <span class="comment">// 上写锁，进行插入操作</span></span><br><span class="line">        <span class="function">RWMutexType::WriteLock <span class="title">lock</span><span class="params">(GetMutex())</span></span>;</span><br><span class="line">        <span class="comment">// 再次检查 name 是否存在，避免多线程重复插入的问题</span></span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(name);</span><br><span class="line">        <span class="keyword">if</span>(it != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> Config::<span class="built_in">pointer_cast</span>&lt;T&gt;(name, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">typename</span> ConfigVar&lt;T&gt;::ptr newConfigVar = std::make_shared&lt;ConfigVar&lt;T&gt;&gt;(name, default_value, description);</span><br><span class="line">        mp[name] = newConfigVar;</span><br><span class="line">        <span class="comment">// SYLAR_LOG_DEBUG(SYLAR_LOG_ROOT()) &lt;&lt; &quot;Add config name: &quot; &lt;&lt; name &lt;&lt; &quot;, type: &quot;&lt;&lt; typeid(T).name();</span></span><br><span class="line">        <span class="comment">// SYLAR_LOG_DEBUG(SYLAR_LOG_ROOT()) &lt;&lt; &quot; -Add config: &quot; &lt;&lt; name;</span></span><br><span class="line">        <span class="keyword">return</span> newConfigVar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找name，并返回其父类指针（利用多态性）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ConfigVarBase::ptr <span class="title">LookupBase</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从Yaml中加载配置</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">LoadFromYaml</span><span class="params">(<span class="type">const</span> YAML::Node&amp; root)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit接收一个回调函数cb，对Config管理的所有配置项应用该回调函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Visit</span><span class="params">(std::function&lt;<span class="type">void</span>(ConfigVarBase::ptr)&gt; cb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 封装 dynamic_pointer_cast 和类型检查逻辑操作</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">pointer_cast</span><span class="params">(<span class="type">const</span> std::string&amp; name, ConfigVarBase::ptr val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">typename</span> ConfigVar&lt;T&gt;::ptr tmp = std::dynamic_pointer_cast&lt;ConfigVar&lt;T&gt;&gt;(val);;</span><br><span class="line">        <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">            <span class="built_in">SYLAR_LOG_INFO</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;exists.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, but type not &lt;&quot;</span></span><br><span class="line">                &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;&gt;, real type=&lt;&quot;</span> &lt;&lt; val-&gt;<span class="built_in">getTypename</span>() &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用静态成员函数获取数据，避免静态变量的初始化顺序问题（见Effective C++条款4）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> ConfigVarMap&amp; <span class="title">GetDatas</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> ConfigVarMap s_datas;</span><br><span class="line">        <span class="keyword">return</span> s_datas;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为读写锁应用的对象为静态变量，所以也需要使用静态成员函数获得读写锁</span></span><br><span class="line">    <span class="function"><span class="type">static</span> RWMutexType&amp; <span class="title">GetMutex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> RWMutexType s_mutex;</span><br><span class="line">        <span class="keyword">return</span> s_mutex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="单例类实现"><a href="#单例类实现" class="headerlink" title="单例类实现"></a>单例类实现</h3><p>Config的单例实现方式有所不同。它不通过Sington来实现单例，而是将所有的成员函数都设置为静态</p>
<p>注意静态数据成员变量也转变为通过静态成员函数获取</p>
<ul>
<li><p>复习一下Effective C++条款4：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/efce89d3c10e4cc7badc0686f51899a2.png" alt="Effective C++条款4——确定对象被使用前已被初始化"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用静态成员函数获取数据，避免静态变量的初始化顺序问题</span></span><br><span class="line">  <span class="function"><span class="type">static</span> ConfigVarMap&amp; <span class="title">GetDatas</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="type">static</span> ConfigVarMap s_datas;</span><br><span class="line">      <span class="keyword">return</span> s_datas;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 因为读写锁应用的对象为静态变量，所以也需要使用静态成员函数获得读写锁</span></span><br><span class="line">  <span class="function"><span class="type">static</span> RWMutexType&amp; <span class="title">GetMutex</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="type">static</span> RWMutexType s_mutex;</span><br><span class="line">      <span class="keyword">return</span> s_mutex;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="Lookup"><a href="#Lookup" class="headerlink" title="Lookup"></a>Lookup</h3><p>Lookup用于向map中查找&#x2F;添加配置项，整体逻辑比较简单。注意一下几点即可：</p>
<ul>
<li><p>有两个重载版本的Lookup：</p>
<ul>
<li><p>版本1：只用于读操作</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">Lookup</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>版本2：接受数值与描述，如果没有查询到对应的配置项则使用该数值与描述新增一个配置项</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">Lookup</span><span class="params">(<span class="type">const</span> std::string&amp; name, </span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">const</span> T&amp; default_value, <span class="type">const</span> std::string&amp; description = <span class="string">&quot;&quot;</span>)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>版本2在新增配置项前需要对名称与数值类型进行检查：</p>
<ul>
<li><p>名称检查：仅支持名称由 数字、字母（大小写不敏感）、‘.’和’_’构成</p>
</li>
<li><p>类型检查：通过封装pointer_cast进行类型检查</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装 dynamic_pointer_cast 和类型检查逻辑操作</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">static</span> <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">pointer_cast</span><span class="params">(<span class="type">const</span> std::string&amp; name, ConfigVarBase::ptr val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> ConfigVar&lt;T&gt;::ptr tmp = std::dynamic_pointer_cast&lt;ConfigVar&lt;T&gt;&gt;(val);;</span><br><span class="line">    <span class="keyword">if</span>(tmp)&#123;</span><br><span class="line">        <span class="built_in">SYLAR_LOG_INFO</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;exists.&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, but type not &lt;&quot;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;&gt;, real type=&lt;&quot;</span> &lt;&lt; val-&gt;<span class="built_in">getTypename</span>() &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Visit"><a href="#Visit" class="headerlink" title="Visit"></a>Visit</h3><p><code>Visit</code>接收一个回调函数cb，对Config管理的所有配置项应用该回调函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Config::Visit</span><span class="params">(std::function&lt;<span class="type">void</span>(ConfigVarBase::ptr)&gt; cb)</span></span>&#123;</span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(GetMutex())</span></span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; mp = <span class="built_in">GetDatas</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : mp)&#123;</span><br><span class="line">        <span class="built_in">cb</span>(i.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="LoadFromYaml"><a href="#LoadFromYaml" class="headerlink" title="LoadFromYaml"></a>LoadFromYaml</h3><p><code>LoadFromYaml</code>实现从YAML::Node中载入配置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从Yaml中导入配置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Config::LoadFromYaml</span><span class="params">(<span class="type">const</span> YAML::Node&amp; root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将Yaml的树状结构拍平为list（方便遍历）</span></span><br><span class="line">    <span class="comment">// &lt;name, yaml_node&gt;</span></span><br><span class="line">    std::list&lt;std::pair&lt;std::string, <span class="type">const</span> YAML::Node&gt;&gt; all_nodes;</span><br><span class="line">    <span class="built_in">ListAllMember</span>(<span class="string">&quot;&quot;</span>, root, all_nodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历Yaml，逐个解析配置项</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : all_nodes)&#123;</span><br><span class="line">        std::string key = item.first;</span><br><span class="line">        <span class="keyword">if</span>(key.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将键转换为全小写</span></span><br><span class="line">        std::<span class="built_in">transform</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>(), key.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; key &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在Config容器中查找一项配置项var（只查找注册过的配置项，如果没有找到不会自动添加配置项）</span></span><br><span class="line">        ConfigVarBase::ptr var = <span class="built_in">LookupBase</span>(item.first);</span><br><span class="line">        <span class="comment">// 从字符串获取配置项var的值</span></span><br><span class="line">        <span class="keyword">if</span>(var)&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.second.<span class="built_in">IsScalar</span>())&#123;</span><br><span class="line">                var-&gt;<span class="built_in">fromString</span>(item.second.<span class="built_in">Scalar</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::stringstream ss;</span><br><span class="line">                ss &lt;&lt; item.second;</span><br><span class="line">                <span class="comment">// ss.str()为Yaml格式的字符串，交给fromString来解析</span></span><br><span class="line">                var-&gt;<span class="built_in">fromString</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>步骤：</p>
<ol>
<li><p>将Yaml树结构拍平为list，便于后面遍历</p>
 <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp:</span><br><span class="line">  connect:                 ----拍平----&gt;       tcp.connect.timeout</span><br><span class="line">    timeout: 10000</span><br></pre></td></tr></table></figure>

 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Yaml的树结果拍平为list</span></span><br><span class="line"><span class="comment">//  ·prefix：配置项名称的前缀</span></span><br><span class="line"><span class="comment">//  ·output：传出参数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ListAllMember</span><span class="params">(<span class="type">const</span> std::string&amp; prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> YAML::Node&amp; node,</span></span></span><br><span class="line"><span class="params"><span class="function">                          std::list&lt;std::pair&lt;std::string, <span class="type">const</span> YAML::Node&gt;&gt;&amp; output)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prefix.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;1234567890._abcdefghijklmnopqrstuvwxyz&quot;</span>)</span><br><span class="line">        != std::string::npos)&#123;</span><br><span class="line">        <span class="built_in">SYLAR_LOG_ERROR</span>(<span class="built_in">SYLAR_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name invalid: &quot;</span> &lt;&lt; prefix;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(prefix);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    output.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(prefix, node));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node.<span class="built_in">IsMap</span>())&#123;</span><br><span class="line">        <span class="comment">// 递归地处理map</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : node)&#123;</span><br><span class="line">            <span class="built_in">ListAllMember</span>(prefix.<span class="built_in">empty</span>() ? it.first.<span class="built_in">Scalar</span>() : prefix + <span class="string">&quot;.&quot;</span> + it.first.<span class="built_in">Scalar</span>(),</span><br><span class="line">                          it.second, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历YAML::Node，逐个解析配置项，有两个注意点</p>
<ul>
<li>将配置项的键（名称）转换为全小写（大小写不敏感）</li>
<li>只有已经存在于Config中的配置项才会被载入</li>
</ul>
</li>
</ol>
<h2 id="STL支持"><a href="#STL支持" class="headerlink" title="STL支持"></a>STL支持</h2><blockquote>
<p>支持更多类型，在于支持更多类型的Lexical_cast特化版本</p>
</blockquote>
<ul>
<li>实现方法：定义一个仿函数类Lexical_cast，以及它的一系列偏特化</li>
<li>由于Lexical_cast的递归调用，实现天生<strong>支持STL的嵌套</strong></li>
</ul>
<p>STL的实现方式分为以下两大类</p>
<ul>
<li>将容器转化为<code>YAML::NodeType::Sequence</code><ul>
<li>包括vector、list、set、unordered_set</li>
</ul>
</li>
<li>将容器转化为<code>YAML::NodeType::Map</code><ul>
<li>map、unordered_map（目前的实现只支持key为std::string）</li>
</ul>
</li>
</ul>
<h3 id="vector、list、set、unordered-set"><a href="#vector、list、set、unordered-set" class="headerlink" title="vector、list、set、unordered_set"></a>vector、list、set、unordered_set</h3><p>转化为<code>YAML::NodeType::Sequence</code>，以vector为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector -&gt; Yaml格式字符串</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;std::vector&lt;T&gt;, std::string&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt; vec)</span></span>&#123;</span><br><span class="line">        <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Sequence)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : vec)&#123;</span><br><span class="line">            <span class="comment">// 递归地将vec的元素转换为Yaml字符串格式</span></span><br><span class="line">            node.<span class="built_in">push_back</span>(YAML::<span class="built_in">Load</span>(<span class="built_in">Lexical_cast</span>&lt;T, std::string&gt;()(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用stringstream来接收Yaml格式字符串</span></span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yaml格式字符串 -&gt; vector</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;std::string, std::vector&lt;T&gt;&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::vector&lt;T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string str)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用YAML::Load解析Yaml格式字符串</span></span><br><span class="line">        YAML::Node nodes = YAML::<span class="built_in">Load</span>(str);</span><br><span class="line">        std::vector&lt;T&gt; vec;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; node : nodes)&#123;</span><br><span class="line">            <span class="comment">// 使用使用stringstream来接收Yaml格式字符串</span></span><br><span class="line">            ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            ss &lt;&lt; node;</span><br><span class="line">            <span class="comment">// 递归地将Yaml格式字符串转换为vec的元素</span></span><br><span class="line">            vec.<span class="built_in">push_back</span>(<span class="built_in">Lexical_cast</span>&lt;std::string, T&gt;()(ss.<span class="built_in">str</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="map、unordered-map"><a href="#map、unordered-map" class="headerlink" title="map、unordered_map"></a>map、unordered_map</h3><p>转化为<code>YAML::NodeType::Map</code>，以map为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map，只支持key类型为std::string</span></span><br><span class="line"><span class="comment">// map -&gt; Yaml格式字符串</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;std::map&lt;std::string, T&gt;, std::string&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, T&gt; mp)</span></span>&#123;</span><br><span class="line">        <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : mp)&#123;</span><br><span class="line">            node[i.first] = YAML::<span class="built_in">Load</span>(<span class="built_in">Lexical_cast</span>&lt;T, std::string&gt;()(i.second));</span><br><span class="line">        &#125;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yaml格式字符串 -&gt; map</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;std::string, std::map&lt;std::string, T&gt;&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::map&lt;std::string, T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string str)</span></span>&#123;</span><br><span class="line">        YAML::Node nodes = YAML::<span class="built_in">Load</span>(str);</span><br><span class="line">        std::map&lt;std::string, T&gt; mp;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; node : nodes)&#123;</span><br><span class="line">            ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            ss &lt;&lt; node.second;</span><br><span class="line">            mp.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(node.first.<span class="built_in">Scalar</span>(),</span><br><span class="line">                                     <span class="built_in">Lexical_cast</span>&lt;std::string, T&gt;()(ss.<span class="built_in">str</span>())));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="自定义类型支持"><a href="#自定义类型支持" class="headerlink" title="自定义类型支持"></a>自定义类型支持</h2><p>同STL，只要提供自定义类型的fromString和toString，就可以让配置系统支持该自定义类型</p>
<p>例子：</p>
<ul>
<li><p>类定义</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">0</span>, <span class="type">bool</span> sex = <span class="literal">false</span>)</span><br><span class="line">        : <span class="built_in">m_name</span>(name), <span class="built_in">m_age</span>(age), <span class="built_in">m_sex</span>(sex)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toString</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;[Person: name=&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;, age=&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&quot;, sex=&quot;</span> &lt;&lt; (m_sex ? <span class="string">&quot;female&quot;</span> : <span class="string">&quot;male&quot;</span>) &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_age; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">getSex</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_sex; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; oth) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m_name == oth.m_name</span><br><span class="line">            &amp;&amp; m_age == oth.m_age</span><br><span class="line">            &amp;&amp; m_sex == oth.m_sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">bool</span> m_sex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fromString和toString</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Person类的Lexical_cast偏特化版本，使得配置系统支持该自定义类型</span></span><br><span class="line"><span class="keyword">namespace</span> sylar&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Yaml字符串 -&gt; Person类</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;std::string, Person&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Person <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span>&#123;</span><br><span class="line">        YAML::Node node = YAML::<span class="built_in">Load</span>(val);</span><br><span class="line">        <span class="function">Person <span class="title">p</span><span class="params">(node[<span class="string">&quot;name&quot;</span>].as&lt;std::string&gt;(),</span></span></span><br><span class="line"><span class="params"><span class="function">                 node[<span class="string">&quot;age&quot;</span>].as&lt;<span class="type">int</span>&gt;(),</span></span></span><br><span class="line"><span class="params"><span class="function">                 node[<span class="string">&quot;sex&quot;</span>].as&lt;<span class="type">bool</span>&gt;())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person类 -&gt; Yaml字符串</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;Person, std::string&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; val)</span></span>&#123;</span><br><span class="line">        <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = val.<span class="built_in">getName</span>();</span><br><span class="line">        node[<span class="string">&quot;age&quot;</span>] = val.<span class="built_in">getAge</span>();</span><br><span class="line">        node[<span class="string">&quot;sex&quot;</span>] = val.<span class="built_in">getSex</span>();</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类</span></span><br><span class="line">sylar::ConfigVar&lt;Person&gt;::ptr g_person_config = </span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;class.person&quot;</span>, <span class="built_in">Person</span>(<span class="string">&quot;y&quot;</span>, <span class="number">0</span>, <span class="literal">false</span>), <span class="string">&quot;Person class&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类与STL的嵌套</span></span><br><span class="line">sylar::ConfigVar&lt;std::map&lt;std::string, Person&gt;&gt;::ptr g_person_map_config = </span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;class.persons&quot;</span>, std::<span class="built_in">map</span>&lt;std::string, Person&gt;(&#123;&#123;<span class="string">&quot;nobody&quot;</span>, <span class="built_in">Person</span>()&#125;&#125;), <span class="string">&quot;Person class map&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h1><h2 id="载入配置项"><a href="#载入配置项" class="headerlink" title="载入配置项"></a>载入配置项</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YAML文件载入为YAML::Node</span></span><br><span class="line">YAML::Node root = YAML::<span class="built_in">LoadFile</span>(<span class="string">&quot;/conf/test.yml&quot;</span>);</span><br><span class="line"><span class="comment">// 从YAML::Node中载入配置项</span></span><br><span class="line">sylar::Config::<span class="built_in">LoadFromYaml</span>(root);</span><br></pre></td></tr></table></figure>


<h2 id="添加-获取配置项"><a href="#添加-获取配置项" class="headerlink" title="添加&#x2F;获取配置项"></a>添加&#x2F;获取配置项</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sylar::ConfigVar&lt;<span class="type">int</span>&gt;::ptr g_int_value_config = </span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;system.port&quot;</span>, <span class="number">8080</span>, <span class="string">&quot;system port&quot;</span>);</span><br><span class="line"></span><br><span class="line">sylar::ConfigVar&lt;std::vector&lt;<span class="type">int</span>&gt; &gt;::ptr g_int_vec_value_config =</span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;system.int_vec&quot;</span>, std::vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="string">&quot;system int vector&quot;</span>);</span><br><span class="line"></span><br><span class="line">sylar::ConfigVar&lt;std::list&lt;<span class="type">int</span>&gt; &gt;::ptr g_int_list_value_config =</span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;system.int_list&quot;</span>, std::list&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="string">&quot;system int list&quot;</span>);</span><br><span class="line"></span><br><span class="line">sylar::ConfigVar&lt;std::set&lt;<span class="type">int</span>&gt; &gt;::ptr g_int_set_value_config =</span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;system.int_set&quot;</span>, std::set&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="string">&quot;system int set&quot;</span>);</span><br><span class="line"></span><br><span class="line">sylar::ConfigVar&lt;std::unordered_set&lt;<span class="type">int</span>&gt; &gt;::ptr g_int_uset_value_config =</span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;system.int_uset&quot;</span>, std::unordered_set&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="string">&quot;system int unordered_set&quot;</span>);</span><br><span class="line"></span><br><span class="line">sylar::ConfigVar&lt;std::map&lt;std::string, <span class="type">int</span>&gt; &gt;::ptr g_str_int_map_value_config =</span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;system.str_int_map&quot;</span>, std::map&lt;std::string, <span class="type">int</span>&gt;&#123;&#123;<span class="string">&quot;k&quot;</span>,<span class="number">2</span>&#125;&#125;, <span class="string">&quot;system str int map&quot;</span>);</span><br><span class="line"></span><br><span class="line">sylar::ConfigVar&lt;std::unordered_map&lt;std::string, <span class="type">int</span>&gt; &gt;::ptr g_str_int_umap_value_config =</span><br><span class="line">    sylar::Config::<span class="built_in">Lookup</span>(<span class="string">&quot;system.str_int_umap&quot;</span>, std::unordered_map&lt;std::string, <span class="type">int</span>&gt;&#123;&#123;<span class="string">&quot;k&quot;</span>,<span class="number">2</span>&#125;&#125;, <span class="string">&quot;system str int map&quot;</span>);</span><br></pre></td></tr></table></figure>


<h1 id="与日志系统的整合"><a href="#与日志系统的整合" class="headerlink" title="与日志系统的整合"></a>与日志系统的整合</h1><h2 id="LogAppenderDefine"><a href="#LogAppenderDefine" class="headerlink" title="LogAppenderDefine"></a>LogAppenderDefine</h2><p><code>LogAppenderDefine</code>为定义Appender信息的结构体，结构体需要包含以下内容：</p>
<ol>
<li><code>type</code>：表示Appender的类型，目前日志系统支持输出到终端&#x2F;文件两种appender，type取值如下：<ul>
<li>0：未初始化</li>
<li>1：输出到文件</li>
<li>2：输出到终端</li>
</ul>
</li>
<li><code>pattern</code>：表示输出格式的模板</li>
<li><code>file</code>：在type &#x3D;&#x3D; 1时有效，记录输出文件的路径</li>
<li><code>operator==</code>：为配置系统提供结构体的比较方法，上面三个数据成员全相等才返回true</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LogAppenderDefine</span>&#123;</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;   <span class="comment">// 1: File, 2: Stdout</span></span><br><span class="line">    std::string pattern;</span><br><span class="line">    std::string file;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> LogAppenderDefine&amp; oth) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type == oth.type</span><br><span class="line">            &amp;&amp; pattern == oth.pattern</span><br><span class="line">            &amp;&amp; file == oth.file;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="LoggerDefine"><a href="#LoggerDefine" class="headerlink" title="LoggerDefine"></a>LoggerDefine</h2><p><code>LoggerDefine</code>为记录Logger信息的结构体，结构体需要包含以下内容：</p>
<ol>
<li><code>name</code>：Logger的名称</li>
<li><code>level</code>：Logger的级别，类型为LogLevel::Level</li>
<li><code>appenders</code>：管理LogAppenderDefine结构体的数组</li>
<li>重载关系运算符，包括operator&#x3D;&#x3D;、operator!&#x3D;、operator&lt;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录Logger相关信息的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LoggerDefine</span>&#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    LogLevel::Level level = LogLevel::UNKNOW;</span><br><span class="line">    std::vector&lt;LogAppenderDefine&gt; appenders;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> LoggerDefine&amp; oth) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name == oth.name</span><br><span class="line">            &amp;&amp; level == oth.level</span><br><span class="line">            &amp;&amp; appenders == oth.appenders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> LoggerDefine&amp; oth) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == oth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> LoggerDefine&amp; oth) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name &lt; oth.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Lexcial-cast偏特化"><a href="#Lexcial-cast偏特化" class="headerlink" title="Lexcial_cast偏特化"></a>Lexcial_cast偏特化</h2><p>实现Lexical_cast偏特化，使用YAML::NodeType::Map管理。整体逻辑不难理解，注意一下YAML::Node的操作方法即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 偏特化Lexical_cast</span></span><br><span class="line"><span class="comment">// Yaml字符串 -&gt; LoggerDefine</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;std::string, LoggerDefine&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">LoggerDefine <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span></span>&#123;</span><br><span class="line">        YAML::Node node = YAML::<span class="built_in">Load</span>(val);</span><br><span class="line">        LoggerDefine ld;</span><br><span class="line">        <span class="keyword">if</span>(!node[<span class="string">&quot;name&quot;</span>].<span class="built_in">IsDefined</span>())&#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;log config error: name is null&quot;</span> &lt;&lt; node &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;log config name is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理name和level</span></span><br><span class="line">        ld.name = node[<span class="string">&quot;name&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;();</span><br><span class="line">        ld.level = LogLevel::<span class="built_in">FromString</span>(node[<span class="string">&quot;level&quot;</span>].<span class="built_in">IsDefined</span>() ? node[<span class="string">&quot;level&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;() : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 处理appenders</span></span><br><span class="line">        <span class="keyword">if</span>(node[<span class="string">&quot;appenders&quot;</span>].<span class="built_in">IsDefined</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a : node[<span class="string">&quot;appenders&quot;</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!a[<span class="string">&quot;type&quot;</span>].<span class="built_in">IsDefined</span>())&#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;log config error: appender type is null&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                LogAppenderDefine lad;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不同的appender类型设置不同的type，FileLogAppender还需要获取输出的文件路径</span></span><br><span class="line">                std::string type = a[<span class="string">&quot;type&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;();</span><br><span class="line">                <span class="keyword">if</span>(type == <span class="string">&quot;FileLogAppender&quot;</span>)&#123;</span><br><span class="line">                    lad.type = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(!a[<span class="string">&quot;file&quot;</span>].<span class="built_in">IsDefined</span>())&#123;</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;log config error: FileLogAppender filename is null&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lad.file = a[<span class="string">&quot;file&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="string">&quot;StdoutLogAppender&quot;</span>)&#123;</span><br><span class="line">                    lad.type = <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;log config error: appender type is invalid&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 以上appender都需要检测是否配置了formatter的pattern</span></span><br><span class="line">                <span class="keyword">if</span>(a[<span class="string">&quot;pattern&quot;</span>].<span class="built_in">IsDefined</span>())&#123;</span><br><span class="line">                    lad.pattern = a[<span class="string">&quot;pattern&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将处理完成的LogAppenderDefine加入appenders中</span></span><br><span class="line">                ld.appenders.<span class="built_in">push_back</span>(lad);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ld;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoggerDefine -&gt; Yaml字符串</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lexical_cast</span>&lt;LoggerDefine, std::string&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> LoggerDefine&amp; ld)</span></span>&#123;</span><br><span class="line">        <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = ld.name;</span><br><span class="line">        node[<span class="string">&quot;level&quot;</span>] = LogLevel::<span class="built_in">ToString</span>(ld.level);</span><br><span class="line">        std::stringstream ss_appenders;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; lad : ld.appenders)&#123;</span><br><span class="line">            <span class="function">YAML::Node <span class="title">nlad</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(lad.type == <span class="number">1</span>)&#123;</span><br><span class="line">                nlad[<span class="string">&quot;type&quot;</span>] = <span class="string">&quot;FileLogAppender&quot;</span>;</span><br><span class="line">                nlad[<span class="string">&quot;file&quot;</span>] = lad.file;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lad.type == <span class="number">2</span>)&#123;</span><br><span class="line">                nlad[<span class="string">&quot;type&quot;</span>] = <span class="string">&quot;StdoutLogAppender&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!lad.pattern.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                nlad[<span class="string">&quot;pattern&quot;</span>] = lad.pattern;</span><br><span class="line">            &#125;</span><br><span class="line">            node[<span class="string">&quot;appenders&quot;</span>].<span class="built_in">push_back</span>(nlad);</span><br><span class="line">        &#125;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="日志模块配置项g-log-config"><a href="#日志模块配置项g-log-config" class="headerlink" title="日志模块配置项g_log_config"></a>日志模块配置项g_log_config</h2><p>在log.h中注册日志模块的配置项：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册 logs 配置项</span></span><br><span class="line">ConfigVar&lt;std::set&lt;LoggerDefine&gt;&gt;::ptr g_log_config = </span><br><span class="line">        Config::<span class="built_in">Lookup</span>(<span class="string">&quot;logs&quot;</span>, std::<span class="built_in">set</span>&lt;LoggerDefine&gt;(), <span class="string">&quot;logs config&quot;</span>);</span><br></pre></td></tr></table></figure>


<h3 id="回调函数-1"><a href="#回调函数-1" class="headerlink" title="回调函数"></a>回调函数</h3><p>**<span class='p red'>全局对象在main函数前构造（其构造函数在main函数之前触发）</span>**，我们可以利用这一特性为 g_log_config 配置项添加回调函数</p>
<p>回调函数接收两个set<LoggerDefine>，一个为配置项旧值<code>oldVal</code>，一个为新值<code>newVal</code>。对比配置项的新旧值，完成logger的创建 &#x2F; 修改 &#x2F; 删除工作：</p>
<ul>
<li>创建 &#x2F; 修改：创建&#x2F;获取<code>newVal</code>中对应的日志器，根据LoggerDefine的新值设置日志器属性</li>
<li>删除：如果日志器在<code>oldVal</code>中但不在<code>newVal</code>中，则说明该日志器需要被删除。进行的操作为逻辑删除（将Level设置为无法访问到的级别，并情况其appender）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LogIniter</span>&#123;</span><br><span class="line">    <span class="built_in">LogIniter</span>()&#123;</span><br><span class="line">        <span class="comment">// SYLAR_LOG_INFO(SYLAR_LOG_ROOT()) &lt;&lt; &quot;g_log_config add callback&quot;;</span></span><br><span class="line">        g_log_config-&gt;<span class="built_in">addListener</span>([](<span class="type">const</span> std::set&lt;LoggerDefine&gt;&amp; oldVal,</span><br><span class="line">                                     <span class="type">const</span> std::set&lt;LoggerDefine&gt;&amp; newVal)&#123;</span><br><span class="line">            <span class="comment">// 监测以下三种情况：新增 / 修改 / 删除</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : newVal)&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = oldVal.<span class="built_in">find</span>(i);</span><br><span class="line">                Logger::ptr logger;</span><br><span class="line">                <span class="keyword">if</span>(it == oldVal.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="comment">// &lt;新增&gt;</span></span><br><span class="line">                    logger = <span class="built_in">SYLAR_LOG_NAME</span>(i.name);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != *it)&#123;</span><br><span class="line">                        <span class="comment">// &lt;修改&gt;</span></span><br><span class="line">                        logger = <span class="built_in">SYLAR_LOG_NAME</span>(i.name);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 根据newVal中的数据成员修改logger配置</span></span><br><span class="line">                <span class="comment">// 设置level</span></span><br><span class="line">                logger-&gt;<span class="built_in">setLevel</span>(i.level);</span><br><span class="line">                <span class="comment">// 设置appenders</span></span><br><span class="line">                logger-&gt;<span class="built_in">clearAppenders</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : i.appenders)&#123;</span><br><span class="line">                    LogAppender::ptr ap;</span><br><span class="line">                    <span class="keyword">if</span>(a.type == <span class="number">1</span>)&#123;</span><br><span class="line">                        ap.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">FileLogAppender</span>(a.file));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a.type == <span class="number">2</span>)&#123;</span><br><span class="line">                        ap.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">StdoutLogAppender</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// pattern非空时设置自定义formatter，否则使用默认formatter</span></span><br><span class="line">                    <span class="keyword">if</span>(!a.pattern.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                        ap-&gt;<span class="built_in">setFormatter</span>(LogFormatter::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">LogFormatter</span>(a.pattern)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    logger-&gt;<span class="built_in">addAppender</span>(ap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// &lt;删除&gt;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : oldVal)&#123;</span><br><span class="line">                <span class="keyword">auto</span> it = newVal.<span class="built_in">find</span>(i);</span><br><span class="line">                <span class="keyword">if</span>(it == newVal.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="comment">// 对配置文件中被删除的logger执行逻辑删除</span></span><br><span class="line">                    Logger::ptr logger = <span class="built_in">SYLAR_LOG_NAME</span>(i.name);</span><br><span class="line">                    <span class="comment">// 逻辑删除：将Level设置为访问不到的级别，并清空所有appender</span></span><br><span class="line">                    logger-&gt;<span class="built_in">setLevel</span>(LogLevel::NOTSET);</span><br><span class="line">                    logger-&gt;<span class="built_in">clearAppenders</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 全局对象在main函数前构造</span></span><br><span class="line"><span class="type">static</span> LogIniter __log_init;</span><br></pre></td></tr></table></figure>


<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>日志系统的配置系统可以如下形式：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">      <span class="attr">appenders:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">FileLogAppender</span></span><br><span class="line">            <span class="attr">file:</span> <span class="string">/home/mySylar/log.txt</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">StdoutLogAppender</span></span><br><span class="line">            <span class="attr">pattern:</span> <span class="string">&quot;%d%T%m%n&quot;</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://atelieryu.site">Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://atelieryu.site/Sylar%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97">https://atelieryu.site/Sylar%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://atelieryu.site" target="_blank">Yu的炼金工房</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/">服务器框架</a><a class="post-meta__tags" href="/tags/YAML/">YAML</a></div><div class="post-share"><div class="social-share" data-image="https://atelieryu.xyz/elog/202504/b1738be865fb17e115bb8938b3f4b2ec.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/Sylar%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（一）——日志模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/a8604dd41597308b4187f82906e13a21.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++高性能服务器框架Sylar（一）——日志模块</div></div></div></a><a class="pagination-related  no-desc" href="/Sylar%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（三）——线程模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/480969dd9045574653c6c6d8bbfa61dc.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++高性能服务器框架Sylar（三）——线程模块</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/Sylar%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（三）——线程模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/480969dd9045574653c6c6d8bbfa61dc.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-02</div><div class="info-item-2">C++高性能服务器框架Sylar（三）——线程模块</div></div></div></a><a class="pagination-related no-desc" href="/Sylar%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（一）——日志模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/a8604dd41597308b4187f82906e13a21.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-29</div><div class="info-item-2">C++高性能服务器框架Sylar（一）——日志模块</div></div></div></a><a class="pagination-related no-desc" href="/RPC" title="C++实现轻量级RPC分布式网络通信框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">C++实现轻量级RPC分布式网络通信框架</div></div></div></a><a class="pagination-related no-desc" href="/Protobuf" title="Protobuf简易使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/29adb56737da425f642d3dd22328e4eb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">Protobuf简易使用</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/kurumi.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YVollerei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/YVollerei" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-githublogo"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/7661819" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://steamcommunity.com/profiles/76561198310594699/" target="_blank" title="Steam"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-steam_icon"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">模块概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">配置项概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">配置模块功能概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Yaml"><span class="toc-number">2.</span> <span class="toc-text">Yaml</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%88Mapping%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">键值对（Mapping）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%88Sequence%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">列表（Sequence）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">嵌套结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%EF%BC%88Comments%EF%BC%89"><span class="toc-number">2.1.4.</span> <span class="toc-text">注释（Comments）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.5.</span> <span class="toc-text">多行字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.6.</span> <span class="toc-text">复杂数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yaml-cpp"><span class="toc-number">2.2.</span> <span class="toc-text">yaml-cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%AE%89%E8%A3%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">依赖安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text">配置模块设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A%E4%BC%98%E4%BA%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">约定优于配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">模块中的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigVarBase"><span class="toc-number">3.2.1.</span> <span class="toc-text">ConfigVarBase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigVar%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">ConfigVar：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Config%EF%BC%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">Config：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ConfigVarBase-1"><span class="toc-number">4.1.</span> <span class="toc-text">ConfigVarBase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConfigVar"><span class="toc-number">4.2.</span> <span class="toc-text">ConfigVar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">多线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lexical-cast"><span class="toc-number">4.2.2.</span> <span class="toc-text">Lexical_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-fromString"><span class="toc-number">4.2.3.</span> <span class="toc-text">toString &#x2F; fromString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.4.</span> <span class="toc-text">回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Config"><span class="toc-number">4.3.</span> <span class="toc-text">Config</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">单例类实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lookup"><span class="toc-number">4.3.2.</span> <span class="toc-text">Lookup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Visit"><span class="toc-number">4.3.3.</span> <span class="toc-text">Visit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadFromYaml"><span class="toc-number">4.3.4.</span> <span class="toc-text">LoadFromYaml</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STL%E6%94%AF%E6%8C%81"><span class="toc-number">4.4.</span> <span class="toc-text">STL支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E3%80%81list%E3%80%81set%E3%80%81unordered-set"><span class="toc-number">4.4.1.</span> <span class="toc-text">vector、list、set、unordered_set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E3%80%81unordered-map"><span class="toc-number">4.4.2.</span> <span class="toc-text">map、unordered_map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%94%AF%E6%8C%81"><span class="toc-number">4.5.</span> <span class="toc-text">自定义类型支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">模块使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BD%E5%85%A5%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">5.1.</span> <span class="toc-text">载入配置项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-%E8%8E%B7%E5%8F%96%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-number">5.2.</span> <span class="toc-text">添加&#x2F;获取配置项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8E%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B4%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">与日志系统的整合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LogAppenderDefine"><span class="toc-number">6.1.</span> <span class="toc-text">LogAppenderDefine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LoggerDefine"><span class="toc-number">6.2.</span> <span class="toc-text">LoggerDefine</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lexcial-cast%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-number">6.3.</span> <span class="toc-text">Lexcial_cast偏特化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E9%A1%B9g-log-config"><span class="toc-number">6.4.</span> <span class="toc-text">日志模块配置项g_log_config</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">6.4.1.</span> <span class="toc-text">回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">6.5.</span> <span class="toc-text">配置文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Nas-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" title="自建Nas内网穿透——ZeroTier/FRP"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202506/b8b24bcfd6ef35d87082dd5a4a7a0685.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自建Nas内网穿透——ZeroTier/FRP"/></a><div class="content"><a class="title" href="/Nas-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" title="自建Nas内网穿透——ZeroTier/FRP">自建Nas内网穿透——ZeroTier/FRP</a><time datetime="2025-08-04T11:21:00.000Z" title="发表于 2025-08-04 19:21:00">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%BF%BD%E7%95%AA%E8%AE%B0%E5%BD%95-2025-Spring" title="2025四月番追番记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202507/e1fbc76878de30645319135bb0176c6d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025四月番追番记录"/></a><div class="content"><a class="title" href="/%E8%BF%BD%E7%95%AA%E8%AE%B0%E5%BD%95-2025-Spring" title="2025四月番追番记录">2025四月番追番记录</a><time datetime="2025-06-29T03:03:00.000Z" title="发表于 2025-06-29 11:03:00">2025-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%9C%BA%E5%A8%98%E5%88%B6%E4%BD%9C-%E6%B3%B3%E8%A3%85%E7%9F%AD%E5%89%91" title="机娘制作记录——FAG 短剑 Swimsuit Ver."><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202506/ac0acafc7727715d80e0c9811c6d4ee0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机娘制作记录——FAG 短剑 Swimsuit Ver."/></a><div class="content"><a class="title" href="/%E6%9C%BA%E5%A8%98%E5%88%B6%E4%BD%9C-%E6%B3%B3%E8%A3%85%E7%9F%AD%E5%89%91" title="机娘制作记录——FAG 短剑 Swimsuit Ver.">机娘制作记录——FAG 短剑 Swimsuit Ver.</a><time datetime="2025-06-22T03:24:00.000Z" title="发表于 2025-06-22 11:24:00">2025-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A5%E9%97%A8%E7%90%86%E8%AE%BA" title="分布式入门——基础理论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202508/72e1b397531a821fbfd91c373d025617.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式入门——基础理论"/></a><div class="content"><a class="title" href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A5%E9%97%A8%E7%90%86%E8%AE%BA" title="分布式入门——基础理论">分布式入门——基础理论</a><time datetime="2025-04-14T08:12:00.000Z" title="发表于 2025-04-14 16:12:00">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Sylar%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（三）——线程模块"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/480969dd9045574653c6c6d8bbfa61dc.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高性能服务器框架Sylar（三）——线程模块"/></a><div class="content"><a class="title" href="/Sylar%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（三）——线程模块">C++高性能服务器框架Sylar（三）——线程模块</a><time datetime="2025-04-02T06:40:00.000Z" title="发表于 2025-04-02 14:40:00">2025-04-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://atelieryu.xyz/PicGo/footer.jpeg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Yu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.atelieryu.site/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.atelieryu.site/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://fastly.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>addEventListener("DOMContentLoaded",function(){let models=[{width:300,height:350,right:"40px",bottom:"0px",role:"/live2d_models/阿米娅/阿米娅(1).model3.json",background:"",opacity:1,mobile:false,draggable:false,scale:0.1},];new Live2dLoader(models)});</script><div class="aplayer no-destroy" data-id="13432525808" data-server="netease" data-type="playlist" data-order="random" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" data-volume="0.25" data-showlrc="false" data-lrc-type="0"></div><script id="canvas_nest" defer="defer" color="106,114,255" opacity="0.7" zIndex="-1" count="100" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://fastly.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="会搜出什么呢......" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover1.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACGN/&quot;);" href="javascript:void(0);">ACGN</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover2.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习笔记/&quot;);" href="javascript:void(0);">学习笔记</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover3.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/技术随记/&quot;);" href="javascript:void(0);">技术随记</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover4.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/模型制作/&quot;);" href="javascript:void(0);">模型制作</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '3d14be69ac344084881f00a1a2ba6169';
  var gaud_map_key = 'db9c16c529193cc3f1649f61aca0db13';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script async src="/js/ali_font.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>