<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++实现轻量级RPC分布式网络通信框架 | Yu的炼金工房</title><meta name="author" content="Yu"><meta name="copyright" content="Yu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="前言RPC简介RPC（Remote Procedure Call）是一种使程序能够像调用本地函数一样调用远程服务的方法。它屏蔽了底层的通信细节，使得开发人员无需关注远程调用的复杂性，只需像操作本地方法一样调用远程方法。 参考资料 参考博客 参考项目  项目仓库   项目概述框架流程图 代码调用流程 三个主体 zookeeper服务端  zooKeeper在这里作为服务方法的管理配置中心，负责管理服">
<meta property="og:type" content="article">
<meta property="og:title" content="C++实现轻量级RPC分布式网络通信框架">
<meta property="og:url" content="https://atelieryu.site/posts/ccad8bf.html">
<meta property="og:site_name" content="Yu的炼金工房">
<meta property="og:description" content="前言RPC简介RPC（Remote Procedure Call）是一种使程序能够像调用本地函数一样调用远程服务的方法。它屏蔽了底层的通信细节，使得开发人员无需关注远程调用的复杂性，只需像操作本地方法一样调用远程方法。 参考资料 参考博客 参考项目  项目仓库   项目概述框架流程图 代码调用流程 三个主体 zookeeper服务端  zooKeeper在这里作为服务方法的管理配置中心，负责管理服">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg">
<meta property="article:published_time" content="2025-03-18T12:38:00.000Z">
<meta property="article:modified_time" content="2025-03-25T03:23:00.000Z">
<meta property="article:author" content="Yu">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="RPC">
<meta property="article:tag" content="Protobuf">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="分布式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++实现轻量级RPC分布式网络通信框架",
  "url": "https://atelieryu.site/posts/ccad8bf.html",
  "image": "https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg",
  "datePublished": "2025-03-18T12:38:00.000Z",
  "dateModified": "2025-03-25T03:23:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu",
      "url": "https://atelieryu.site/"
    }
  ]
}</script><link rel="shortcut icon" href="https://atelieryu.xyz/PicGo/shizuku.png"><link rel="canonical" href="https://atelieryu.site/posts/ccad8bf.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#3F4F44')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++实现轻量级RPC分布式网络通信框架',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://fastly.jsdelivr.net/npm/pace-js@latest/pace.min.js"></script><link rel="stylesheet" href="/css/corner-indicator.css" /><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://fastly.jsdelivr.net/combine/gh/dylanNew/live2d/webgl/Live2D/lib/live2d.min.js,npm/pixi.js@6.5.2/dist/browser/pixi.min.js,npm/pixi-live2d-display/dist/index.min.js,gh/Weidows-projects/Live2dLoader/dist/Live2dLoader.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Yu的炼金工房" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/kurumi.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-pink"></use></svg><span> 追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chaxun"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/shizuku_logo.png" alt="Logo"><span class="site-name">Yu的炼金工房</span></a><a class="nav-page-title" href="/"><span class="site-name">C++实现轻量级RPC分布式网络通信框架</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-pink"></use></svg><span> 追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chaxun"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++实现轻量级RPC分布式网络通信框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-18T12:38:00.000Z" title="发表于 2025-03-18 20:38:00">2025-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-25T03:23:00.000Z" title="更新于 2025-03-25 11:23:00">2025-03-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><p>RPC（Remote Procedure Call）是一种使程序能够像调用本地函数一样调用远程服务的方法。它屏蔽了底层的通信细节，使得<strong>开发人员无需关注远程调用的复杂性，只需像操作本地方法一样调用远程方法</strong>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/T_Solotov/article/details/124107667?spm=1001.2014.3001.5501">参考博客</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/youngyangyang04/Krpc">参考项目</a></li>
</ul>
<h2 id="项目仓库"><a href="#项目仓库" class="headerlink" title="项目仓库"></a>项目仓库</h2><a class="ghcard" rel="external nofollow noopener noreferrer noopener" target="_blank" href="https://github.com/YVollerei/RPC"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github-readme-stats.vercel.app/api/pin/?username=YVollerei&repo=RPC&show_owner=true"/></a>


<h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><h2 id="框架流程图"><a href="#框架流程图" class="headerlink" title="框架流程图"></a>框架流程图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/658296c43b32f9ef93f5847831247355.png" alt="image.png"></p>
<h2 id="代码调用流程"><a href="#代码调用流程" class="headerlink" title="代码调用流程"></a>代码调用流程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/25f25fec56e09f89f5fd76fd8d2bcc2e.png" alt="image.png"></p>
<h3 id="三个主体"><a href="#三个主体" class="headerlink" title="三个主体"></a>三个主体</h3><ul>
<li><p><strong>zookeeper服务端</strong></p>
<ul>
<li>zooKeeper在这里作为服务方法的管理配置中心，负责管理服务方法提供者对外提供的服务方法</li>
<li>Rpc服务端与客户端的身份都是zookeeper客户端</li>
<li>zookeeper存储服务对象与服务方法的方式：</li>
</ul>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/d9567a2a7c46ad22233b0c41cef598ff.png" alt="image.png"></p>
</li>
<li><p><strong>Rpc服务端</strong></p>
<ul>
<li>Rpc服务端需要向zookeeper注册服务对象与服务方法，注册的内容是本机上提供该服务的ip+端口</li>
<li>注册完服务后，启动epoll监听客户端的远端调用请求</li>
<li>接收到Rpc客户端的远端调用后，先对调用参数进行反序列化，再调用本地方法处理该调用，最后将处理结果包装为响应，序列化后发出</li>
</ul>
</li>
<li><p><strong>Rpc客户端</strong></p>
<ul>
<li>Rpc客户端需要先从zookeeper中查询提供目标服务的Rpc服务端ip与端口</li>
<li>查询到Rpc服务端的ip与端口向目标端口发起连接，之后就是send - recv的流程，区别是send前需要对请求内容进行序列化，recv后需要对响应内容进行反序列化</li>
</ul>
</li>
</ul>
<h1 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h1><p>定义了两个proto文件</p>
<h2 id="Krpcheader-proto"><a href="#Krpcheader-proto" class="headerlink" title="Krpcheader.proto"></a>Krpcheader.proto</h2><p>该文件定义了<strong>RPC调用的元数据头部</strong></p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Krpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RpcHeader</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> service_name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> method_name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint32</span> args_size = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>service_name：用于标识目标服务（如 <code>UserServiceRpc</code>）</li>
<li>method_name：用于标识目标方法（如 <code>Login</code>）</li>
<li>args_size：表示后续参数数据的字节长度，避免粘包问题</li>
</ul>
<p>服务端接收到请求后，通过service_name和method_name找到对应的服务</p>
<h2 id="user-proto"><a href="#user-proto" class="headerlink" title="user.proto"></a>user.proto</h2><p>该文件定义了<code>UserServiceRpc</code>服务，以及它的两个方法<code>Login</code>和<code>Register</code></p>
<p>可以根据具体需求改动<code>LoginRequest</code>和<code>RegisterRequest</code>中的参数</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> Kuser;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制生成基于protobuf的通用RPC服务基类</span></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span> &#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterRequest</span> &#123;</span><br><span class="line">    <span class="type">uint32</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">RegisterResponse</span> &#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Register(RegisterRequest) <span class="keyword">returns</span>(RegisterResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Login和Register"><a href="#Login和Register" class="headerlink" title="Login和Register"></a>Login和Register</h3><ul>
<li>定义Login方法接收两个参数：name和pwd</li>
<li>定义Register方法接收三个参数：id、name、pwd</li>
</ul>
<h3 id="cc-generic-services"><a href="#cc-generic-services" class="headerlink" title="cc_generic_services"></a>cc_generic_services</h3><p>启用<code>cc_generic_services</code>后，proto会生成两个C++类</p>
<ul>
<li><code>UserServiceRpc</code>：callee需要继承此类并实现 <code>Login</code> 和 <code>Register</code> 方法</li>
<li><code>UserServiceRpc_Stub</code>：客户端存根类，由caller继承，通过 <code>RpcChannel</code> 发起调用</li>
</ul>
<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>调用以下命令生成proto文件对应的C++代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc user.proto -I ./ --cpp_out=./user</span><br></pre></td></tr></table></figure>


<p>生成的 user.h 和 user.cc 会被保存到 .&#x2F;user 文件夹中</p>
<h1 id="RPC服务端"><a href="#RPC服务端" class="headerlink" title="RPC服务端"></a>RPC服务端</h1><h2 id="服务端主文件Kserver-cpp"><a href="#服务端主文件Kserver-cpp" class="headerlink" title="服务端主文件Kserver.cpp"></a>服务端主文件Kserver.cpp</h2><p>主文件由UserService和main函数两部分组成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcProvider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端上的自定义UserService，继承自proto生成的UserServiceRpc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span>: <span class="keyword">public</span> Kuser::UserServiceRpc&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个版本执行Login的本地任务 </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd=&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写UserServiceRpc的虚函数</span></span><br><span class="line">    <span class="comment">// 这个版本的Login执行：接收远端调用 - 调用执行本地任务 - 写入响应 - 执行回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ::Kuser::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::Kuser::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Closure* done)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 接收远端调用的参数</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用重载版本，执行本地任务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入响应，参考user.proto中的定义</span></span><br><span class="line">        Kuser::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调（执行响应对象数据的序列化和网络发送，交给框架来完成）</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    KrpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider将UserService发布到rpc节点上</span></span><br><span class="line">    KrpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务发布节点。Run以后进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h3><p>UserService继承自proto文件生成的UserServiceRpc，为具体服务，其中定义了服务中Login方法的两个具体实现：</p>
<ul>
<li>一个版本的Login负责执行本地任务</li>
<li>一个版本的Login负责接收远端调用，之后调用重载版本执行本地任务，最后将执行结果写入响应，并阻塞等待回调</li>
</ul>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>main函数主要执行以下工作：</p>
<ol>
<li>调用框架的初始化操作，从配置文件中读取必要的配置信息</li>
<li>将上面定义的UserService发布到Rpc节点上</li>
<li>启动Rpc服务发布节点，阻塞等待远端客户端调用该服务</li>
</ol>
<h2 id="为服务端提供服务的类"><a href="#为服务端提供服务的类" class="headerlink" title="为服务端提供服务的类"></a>为服务端提供服务的类</h2><h3 id="KrpcApplication"><a href="#KrpcApplication" class="headerlink" title="KrpcApplication"></a>KrpcApplication</h3><p>KrpcApplication主要负责框架的初始化操作，有以下几个注意点：</p>
<ul>
<li>KrpcApplication为一个单例类</li>
<li>初始化操作具体为：从命令行中解析出配置文件路径 → 调用KrpcConfig类载入配置文件，完成各参数的初始化</li>
<li>初始化的配置项包括zookeeper服务器的ip和端口，以及Rpc服务端自己的ip和端口</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcChannel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Krpc基础类，负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 初始化框架</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例模式，返回单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KrpcApplication&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 删除单例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DeleteInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取配置</span></span><br><span class="line">    <span class="function"><span class="type">static</span> KrpcConfig&amp; <span class="title">GetConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 单例模式，私有的构造函数</span></span><br><span class="line">    <span class="built_in">KrpcApplication</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">KrpcApplication</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝与移动构造</span></span><br><span class="line">    <span class="built_in">KrpcApplication</span>(<span class="type">const</span> KrpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">KrpcApplication</span>(KrpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="type">static</span> KrpcConfig m_config;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="type">static</span> KrpcApplication* m_application;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 互斥量</span></span><br><span class="line">    <span class="type">static</span> std::mutex m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次声明静态变量</span></span><br><span class="line">KrpcConfig KrpcApplication::m_config;</span><br><span class="line">std::mutex KrpcApplication::m_mutex;</span><br><span class="line"><span class="comment">// 懒汉模式初始化单例对象</span></span><br><span class="line">KrpcApplication* KrpcApplication::m_application = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化框架</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;KrpcApplication::Init&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// -i后必须有配置文件路径，文件中记录zookeeper服务器的ip和端口，以及服务器的ip和端口</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    std::string config_file;</span><br><span class="line">    <span class="comment">// getopt用于解析命令行字符，第三个参数表示接收的参数，这里只指定i</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">-1</span> != (opt = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:&#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;KrpcApplication: case -i&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="comment">// -i表示指定配置文件路径</span></span><br><span class="line">                <span class="comment">// optarg为命令行参数对应的值，这里即为指定的配置文件路径</span></span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 不接受i以外的命令行参数</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:&#123;</span><br><span class="line">                <span class="comment">// 出现了i但后面没有对应的值</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;format::command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从配置文件中载入配置项</span></span><br><span class="line">    m_config.<span class="built_in">LoadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例模式，返回单例对象</span></span><br><span class="line"><span class="function">KrpcApplication&amp; <span class="title">KrpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取单例时上锁</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!m_application)&#123;</span><br><span class="line">        m_application = <span class="keyword">new</span> <span class="built_in">KrpcApplication</span>();</span><br><span class="line">        <span class="comment">// 设置程序退出时自动销毁单例对象</span></span><br><span class="line">        <span class="built_in">atexit</span>(DeleteInstance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *m_application;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除单例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcApplication::DeleteInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_application)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_application;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置</span></span><br><span class="line"><span class="function">KrpcConfig&amp; <span class="title">KrpcApplication::GetConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="KrpcConfig"><a href="#KrpcConfig" class="headerlink" title="KrpcConfig"></a>KrpcConfig</h3><p>KrpcConfig主要负责实际的配置项初始化操作，具体就是从配置文件中逐行读入配置项，逻辑比较简单</p>
<p>值得学习的点有使用智能指针管理文件指针，这样可以在初始化结束后自动关闭文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* config_file)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找配置项对应的值</span></span><br><span class="line">    <span class="function">std::string <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 辅助函数，用于去除字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string&amp; read_buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 存放配置项的容器</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcConfig::LoadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* config_file)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理文件指针，并指定删除器为fclose</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;FILE, <span class="title">decltype</span><span class="params">(&amp;fclose)</span>&gt; <span class="title">pf</span><span class="params">(fopen(config_file, <span class="string">&quot;r&quot;</span>), fclose)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐行读取配置项</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fgets</span>(buf, <span class="number">1024</span>, pf.<span class="built_in">get</span>()) != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line">        <span class="comment">// 跳过空行与注释行</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf.<span class="built_in">empty</span>() || read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &#x27;=&#x27;前为配置名，后为配置值</span></span><br><span class="line">        <span class="type">int</span> ind = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ind == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析key</span></span><br><span class="line">        std::string key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, ind);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="comment">// 解析value</span></span><br><span class="line">        <span class="type">int</span> endInd = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, ind);</span><br><span class="line">        std::string value = read_buf.<span class="built_in">substr</span>(ind + <span class="number">1</span>, endInd - ind - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入配置项</span></span><br><span class="line">        m_configs[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找配置项对应的值</span></span><br><span class="line"><span class="function">std::string <span class="title">KrpcConfig::Load</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configs.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configs.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，用于去除字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcConfig::Trim</span><span class="params">(std::string&amp; read_buf)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 去除前导空格</span></span><br><span class="line">    <span class="type">int</span> ind = read_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ind != <span class="number">-1</span>)&#123;</span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(ind, read_buf.<span class="built_in">size</span>() - ind);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除尾部空格</span></span><br><span class="line">    ind = read_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ind != <span class="number">-1</span>)&#123;</span><br><span class="line">        read_buf = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, ind + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="KrpcProvider"><a href="#KrpcProvider" class="headerlink" title="KrpcProvider"></a>KrpcProvider</h2><div class="note info modern"><p>Rpc服务端的核心函数类，提供发布Rpc方法、启动Rpc服务节点等功能</p>
</div>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">KrpcProvider</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给外部使用，用于发布rpc方法</span></span><br><span class="line">    <span class="comment">// 多态：所有服务都继承自google::protobuf::Service</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service* service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动Rpc服务节点，开始提供Rpc远程调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 服务结构体，用于保存具体的服务对象和它的方法</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service* service;</span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; method_map;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理新连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理已有连接上发来的消息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buffer, muduo::Timestamp receive_time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送Rpc响应</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    muduo::net::EventLoop m_eventloop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存服务对象的容器</span></span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_services;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>KrpcProvider如何管理服务对象与其方法？</p>
</blockquote>
<ul>
<li>使用unordered_map存放ServiceInfo，管理所有服务</li>
<li>每个ServiceInfo也使用一个unordered_map存放method描述符，管理该服务下的所有方法</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KrpcProvider::~<span class="built_in">KrpcProvider</span>()&#123;</span><br><span class="line">    <span class="comment">// 析构函数，停止Event Loop</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;~KrpcProvider()&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    m_eventloop.<span class="built_in">quit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="NotifyService"><a href="#NotifyService" class="headerlink" title="NotifyService"></a>NotifyService</h3><p><code>NotifyService</code>提供给外部使用，用于<strong>在Rpc服务端上注册RPC服务</strong>：</p>
<ul>
<li>将传入的服务保存到<code>m_services</code>中，等待之后调用Run时发布到zookeeper服务器上</li>
</ul>
<p>多态思想的利用：</p>
<ul>
<li>所有服务都继承自<code>google::protobuf::Service</code>，所以<code>NotifyService</code>能接受任何类型的服务</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::NotifyService</span><span class="params">(google::protobuf::Service* service)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 存放服务对象及其方法的结构体</span></span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用多态返回服务类的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor* psd = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务对象的方法都存入service_info</span></span><br><span class="line">    <span class="type">int</span> method_cnt = psd-&gt;<span class="built_in">method_count</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; method_cnt; ++i)&#123;</span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor* pmd = psd-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        service_info.method_map.<span class="built_in">emplace</span>(pmd-&gt;<span class="built_in">name</span>(), pmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务对象放入容器进行管理</span></span><br><span class="line">    m_services.<span class="built_in">emplace</span>(psd-&gt;<span class="built_in">name</span>(), service_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><p><code>Run</code>的主要工作：</p>
<ol>
<li>从配置文件中读取Rpc服务器的ip和端口</li>
<li>调用muduo库接口创建TcpServer对象，并分别绑定连接事件和消息事件，实现网络连接业务和消息处理业务的分离</li>
<li>将<code>m_services</code>中<strong>注册的服务全部发布到zookeeper服务器上</strong>，让Rpc客户端可以从zookeeper上发现Rpc服务端提供的服务</li>
<li>所有服务都完成发布后，<strong>启动muduo库网络服务</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中读取Rpc服务端的ip和端口</span></span><br><span class="line">    std::string ip = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="comment">// 创建地址</span></span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    <span class="keyword">auto</span> server = std::<span class="built_in">make_shared</span>&lt;muduo::net::TcpServer&gt;(&amp;m_eventloop, address, <span class="string">&quot;KrpcProvider&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别绑定连接事件和消息事件</span></span><br><span class="line">    server-&gt;<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server-&gt;<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;KrpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程数量为4</span></span><br><span class="line">    server-&gt;<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前Rpc服务端的服务全部注册到zookeeper上，使得Rpc客户端能够从zookeeper上发现服务</span></span><br><span class="line">    ZkClient zkclient;</span><br><span class="line">    zkclient.<span class="built_in">Start</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;KrpcProvider: zkclient Start success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// service_name为永久节点，method_name为临时节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; service: m_services)&#123;</span><br><span class="line">        <span class="comment">// service_name的路径: /service_name</span></span><br><span class="line">        std::string service_path = <span class="string">&quot;/&quot;</span> + service.first;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;KrpcProvider: zkclient Create znode: &quot;</span> &lt;&lt; service_path &lt;&lt; std::endl;</span><br><span class="line">        zkclient.<span class="built_in">Create</span>(service_path.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建method_name节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; method: service.second.method_map)&#123;</span><br><span class="line">            std::string method_path = service_path + <span class="string">&quot;/&quot;</span> + method.first;</span><br><span class="line">            <span class="type">char</span> method_path_data[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="comment">// 写入节点内容：ip + 端口</span></span><br><span class="line">            <span class="built_in">sprintf</span>(method_path_data, <span class="string">&quot;%s:%d&quot;</span>, ip.<span class="built_in">c_str</span>(), port);</span><br><span class="line">            <span class="comment">// zookeeper上创建临时节点</span></span><br><span class="line">            zkclient.<span class="built_in">Create</span>(method_path.<span class="built_in">c_str</span>(), method_path_data, <span class="built_in">strlen</span>(method_path_data), ZOO_EPHEMERAL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rpc服务端准备启动</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot;, port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动muduo网络服务</span></span><br><span class="line">    server-&gt;<span class="built_in">start</span>();</span><br><span class="line">    m_eventloop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="OnConnection"><a href="#OnConnection" class="headerlink" title="OnConnection"></a>OnConnection</h3><p>如果连接失效，则调用shutdown断开连接，除此不对连接事件做特殊处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不做特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="OnMessage"><a href="#OnMessage" class="headerlink" title="OnMessage"></a>OnMessage</h3><p><code>OnMessage</code>的主要工作：</p>
<ol>
<li>处理Tcp粘包问题，反序列化从字节流中解析出参数</li>
<li>根据参数找到对应的服务与方法</li>
<li>生成Rpc方法调用的请求和响应，调用本地的方法，并通过回调函数发送响应</li>
</ol>
<blockquote>
<p>如何处理Tcp粘包问题?</p>
</blockquote>
<p>将字节流分割为以下几部分：</p>
<ul>
<li><code>header_size</code>: 固定4字节，记录header_str的长度</li>
<li><code>header_str</code>: 记录服务名、方法名、参数长度（KrpcHeader.proto中定义）</li>
<li><code>arg_str</code>: 用于调用方法的参数</li>
</ul>
<blockquote>
<p>什么是<code>NewCallback</code>？</p>
</blockquote>
<p><code>NewCallback</code>函数会返回一个google::protobuf::Closure类的对象，可以理解为定义了一个<strong>回调函数</strong></p>
<p>Closure类对象相当于一个闭包，它捕获了以下内容：</p>
<ul>
<li>一个成员对象的成员函数（这里为<code>SendRpcResponse</code>）</li>
<li>以及这个成员函数需要的参数（这里为<code>conn</code>、<code>response</code>）</li>
</ul>
<blockquote>
<p>什么是<code>CallMethod</code> ？</p>
</blockquote>
<p>CallMethod在<code>UserServiceRpc</code>中实现（proto自动生成），功能为<strong>根据远端Rpc请求，调用当前Rpc节点上发布的方法</strong></p>
<p><code>request</code>与<code>response</code>中包含了调用method的参数，<code>done</code>是执行完method后的回调函数，这里指定了<code>SendRpcResponse</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, muduo::net::Buffer* buffer, muduo::Timestamp receive_time)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;OnMessage&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收远端调用的字节流</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line">    <span class="comment">// ArrayInputStream: 将字节流包装为一个可读取的输入溜</span></span><br><span class="line">    google::protobuf::<span class="function">io::ArrayInputStream <span class="title">raw_input</span><span class="params">(recv_buf.data(), recv_buf.size())</span></span>;</span><br><span class="line">    <span class="comment">// CodedInputStream: 提供高效的二进制流解析工具</span></span><br><span class="line">    google::protobuf::<span class="function">io::CodedInputStream <span class="title">coded_input</span><span class="params">(&amp;raw_input)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取4字节的header_size</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size&#123;&#125;;</span><br><span class="line">    coded_input.<span class="built_in">ReadVarint32</span>(&amp;header_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size的值读取header_str，并对其反序列化，得到Rpc请求的详细信息（既服务名、方法名、参数大小）</span></span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    Krpc::RpcHeader krpcHeader;</span><br><span class="line">    std::string service_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line">    <span class="comment">// 设置读取规则，读取header_str</span></span><br><span class="line">    google::protobuf::io::CodedInputStream::Limit msg_limit = coded_input.<span class="built_in">PushLimit</span>(header_size);</span><br><span class="line">    coded_input.<span class="built_in">ReadString</span>(&amp;rpc_header_str, header_size);</span><br><span class="line">    <span class="comment">// 恢复规则，便于之后安全地读取其他数据</span></span><br><span class="line">    coded_input.<span class="built_in">PopLimit</span>(msg_limit);</span><br><span class="line">    <span class="comment">// 反序列化，解析KrpcHeader</span></span><br><span class="line">    <span class="keyword">if</span>(krpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        service_name = krpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = krpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = krpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: krpcHeader parse error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于调用Rpc方法的参数</span></span><br><span class="line">    std::string args_str;</span><br><span class="line">    <span class="comment">// 读取args_size长度的字符串</span></span><br><span class="line">    <span class="keyword">if</span>(!coded_input.<span class="built_in">ReadString</span>(&amp;args_str, args_size))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error: read args error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Rpc服务端中搜索service对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> sit = m_services.<span class="built_in">find</span>(service_name);</span><br><span class="line">    <span class="keyword">if</span>(sit == m_services.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&quot; is no exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> mit = sit-&gt;second.method_map.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == sit-&gt;second.method_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is no exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取服务对象与方法对象</span></span><br><span class="line">    google::protobuf::Service* service = sit-&gt;second.service;</span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor* method = mit-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成Rpc方法调用的请求（request）和响应（response）</span></span><br><span class="line">    <span class="comment">// 通过 GetRequestPrototype，可以根据方法描述符动态获取对应的请求消息类型，并New（）实例化该类型的对象</span></span><br><span class="line">    google::protobuf::Message* request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; service_name &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message* response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NewCallback函数会返回一个google::protobuf::Closure类的对象</span></span><br><span class="line">    <span class="comment">// Closure类对象相当于一个闭包，它捕获了一个成员对象的成员函数(SendRpcResponse)，以及这个成员函数需要的参数(conn、response)）</span></span><br><span class="line">    google::protobuf::Closure* done = google::protobuf::<span class="built_in">NewCallback</span>&lt;KrpcProvider,</span><br><span class="line">                                                                    <span class="type">const</span> muduo::net::TcpConnectionPtr&amp;,</span><br><span class="line">                                                                    google::protobuf::Message*&gt;(<span class="keyword">this</span>, &amp;KrpcProvider::SendRpcResponse,</span><br><span class="line">                                                                                                conn,</span><br><span class="line">                                                                                                response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CallMethod在UserServiceRpc实现，功能为根据远端Rpc请求，调用当前Rpc节点上发布的方法</span></span><br><span class="line">    <span class="comment">// request与response中包含了调用method的参数，done是执行完method后的回调函数，这里指定了SendRpcResponse</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="SendRpcResponse"><a href="#SendRpcResponse" class="headerlink" title="SendRpcResponse"></a>SendRpcResponse</h3><p>SendRpcResponse作为OnMessage中CallMethod的回调函数，在执行玩远端Rpc调用的方法后调用。其功能是<strong>序列化响应信息，并通过send发送给Rpc客户端</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn, google::protobuf::Message* response)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 序列化响应字符串，并将其发送给Rpc调用方</span></span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123;</span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Serialize Error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="zookeeperutil"><a href="#zookeeperutil" class="headerlink" title="zookeeperutil"></a>zookeeperutil</h2><p><code>zookeeperutil</code>主要对zookeeper提供的一些api进行封装</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zookeeper/zookeeper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// zookeeper客户端，主要封装一些zookeeper相关的api</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZkClient</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ZkClient</span>();</span><br><span class="line">    ~<span class="built_in">ZkClient</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zk客户端启动，连接zk服务器。封装zookeeper_init</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在zk服务器中根据path新建一个节点。封装zoo_create</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datalen, <span class="type">int</span> state = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据指定的路径，获取znode节点值。封装zoo_get</span></span><br><span class="line">    <span class="function">std::string <span class="title">GetData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// zk客户端的句柄</span></span><br><span class="line">    <span class="type">zhandle_t</span>* m_zhandle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="global-watcher"><a href="#global-watcher" class="headerlink" title="global_watcher"></a>global_watcher</h3><blockquote>
<p>watcher机制</p>
</blockquote>
<p>global_watcher定义了一个全局的watcher观察器，当znode节点发生变化时，zk服务端会通过该回调函数通知zk客户端</p>
<p>这里的global_watcher只处理 type&#x3D;&#x3D;ZOO_SESSION_EVENT &amp;&amp; state&#x3D;&#x3D;ZOO_CONNECTED_STATE 的watcher事件。目的是<strong>保证Start()调用完成后zk客户端（即Rpc服务端）与zk服务器的连接已经建立完成了</strong></p>
<blockquote>
<p>为什么需要watcher机制提供保证？</p>
</blockquote>
<p>因为<strong>zk客户端与zk服务器的连接建立过程是异步的</strong>。zookeeper_mt库的zookeeper客户端使用了以下三个线程：</p>
<ul>
<li>主线程：用户调用API的线程。</li>
<li>IO线程：负责网络通信的线程。</li>
<li>completion线程：对于异步请求（Zookeeper中提供的异步API，一般都是以zoo_a开头的api）以及<strong>watcher的响应回调</strong>，io线程会发送给completion线程完成处理。</li>
</ul>
<p>主线程在zk客户端调用api后返回zk句柄，而此时IO线程可能还没有完成连接的建立。所以需要watcher机制配合条件变量来保证Start()调用结束前连接的建立。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局锁</span></span><br><span class="line">std::mutex cv_mutex;</span><br><span class="line"><span class="comment">// 条件变量</span></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="comment">// 标记zk客户端是否已经连接到zk服务器</span></span><br><span class="line"><span class="type">bool</span> isConnected = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局的watcher观察器，当节点发生变化时，zk服务端会通过该回调函数通知zk客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">global_watcher</span><span class="params">(<span class="type">zhandle_t</span>* zh, <span class="type">int</span> type, <span class="type">int</span> state, <span class="type">const</span> <span class="type">char</span>* path, <span class="type">void</span>* watcher_ctx)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只处理 type==ZOO_SESSION_EVENT &amp;&amp; state==ZOO_CONNECTED_STATE 的watcher事件</span></span><br><span class="line">    <span class="keyword">if</span>(type == ZOO_SESSION_EVENT)&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == ZOO_CONNECTED_STATE)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;</span><br><span class="line">            <span class="comment">// 标记zk客户端已经与zk服务端建立连接</span></span><br><span class="line">            isConnected = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒条件变量</span></span><br><span class="line">    cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，初始化zk客户端句柄</span></span><br><span class="line">ZkClient::<span class="built_in">ZkClient</span>(): <span class="built_in">m_zhandle</span>(<span class="literal">nullptr</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数，关闭zk客户端句柄</span></span><br><span class="line">ZkClient::~<span class="built_in">ZkClient</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_zhandle != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">zookeeper_close</span>(m_zhandle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// zk客户端启动，连接zk服务器。封装zookeeper_init</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZkClient::Start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 从配置文件中获取zookeeper服务器的ip和端口</span></span><br><span class="line">    std::string host = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperip&quot;</span>);</span><br><span class="line">    std::string port = KrpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">GetConfig</span>().<span class="built_in">Load</span>(<span class="string">&quot;zookeeperport&quot;</span>);</span><br><span class="line">    <span class="comment">// 拼接 ip + port</span></span><br><span class="line">    std::string conn_str = host + port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化zk对象，异步建立zk客户端（即Rpc服务端）与zk服务器的连接</span></span><br><span class="line">    m_zhandle = <span class="built_in">zookeeper_init</span>(conn_str.<span class="built_in">c_str</span>(), global_watcher, <span class="number">6000</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_zhandle)&#123;</span><br><span class="line">        <span class="comment">// 初始化失败</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zookeeper_init error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待global_watcher回调通知连接已经建立完成(isConnected == true)</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(cv_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 第二个参数用于防止虚假唤醒</span></span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, []&#123;<span class="keyword">return</span> isConnected;&#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeper_init success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在zk服务器中根据path新建一个节点。封装zoo_create</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ZkClient::Create</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* data, <span class="type">int</span> datalen, <span class="type">int</span> state = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建znode节点，可以选择永久性节点还是临时性节点</span></span><br><span class="line">    <span class="type">char</span> path_buffer[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(path_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指定的节点是否存在，只有不存在时才创建节点</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_exists</span>(m_zhandle, path, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == ZNONODE)&#123;</span><br><span class="line">        <span class="comment">// 创建指定path的znode节点</span></span><br><span class="line">        flag = <span class="built_in">zoo_create</span>(m_zhandle, path, data, datalen, &amp;ZOO_OPEN_ACL_UNSAFE, state, path_buffer, bufferlen);</span><br><span class="line">        <span class="keyword">if</span>(flag == ZOK)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;znode create success, path=&quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;znode create fail, path=&quot;</span> &lt;&lt; path &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据指定的路径，获取znode节点值。封装zoo_get</span></span><br><span class="line"><span class="function">std::string <span class="title">ZkClient::GetData</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">int</span> bufferlen = <span class="built_in">sizeof</span>(buffer);</span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">zoo_get</span>(m_zhandle, path, <span class="number">0</span>, buffer, &amp;bufferlen, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(flag == ZOK)&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;zoo_get error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="KrpcController"><a href="#KrpcController" class="headerlink" title="KrpcController"></a>KrpcController</h2><p>KrpcController的主要作用是跟踪RPC方法调用的状态、错误信息并提供控制功能（如取消调用）。这里只实现了其最基本的功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述Rpc调用的控制器，主要作用是跟踪RPC方法调用的状态、错误信息并提供控制功能（如取消调用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcController</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KrpcController</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置状态与错误信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前状态是否为错误</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Failed</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_failed; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回错误信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">ErrorText</span><span class="params">()</span> <span class="type">const</span> </span>&#123; m_errmsg; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置状态与错误信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFailed</span><span class="params">(<span class="type">const</span> std::string&amp; reason)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是一些还未实现的功能</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">StartCancel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsCanceled</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// RPC方法执行过程中的状态</span></span><br><span class="line">    <span class="type">bool</span> m_failed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC方法执行过程中的错误信息</span></span><br><span class="line">    std::string m_errmsg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcController.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">KrpcController::<span class="built_in">KrpcController</span>()</span><br><span class="line">    : <span class="built_in">m_failed</span>(<span class="literal">false</span>)</span><br><span class="line">    , <span class="built_in">m_errmsg</span>(<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置状态与错误信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::Reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m_failed = <span class="literal">false</span>;</span><br><span class="line">    m_errmsg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态与错误信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::SetFailed</span><span class="params">(<span class="type">const</span> std::string&amp; reason)</span></span>&#123;</span><br><span class="line">    m_failed = <span class="literal">true</span>;</span><br><span class="line">    m_errmsg = reason;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一些还未实现的功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::StartCancel</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KrpcController::IsCanceled</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcController::NotifyOnCancel</span><span class="params">(google::protobuf::Closure* callback)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="RPC客户端"><a href="#RPC客户端" class="headerlink" title="RPC客户端"></a>RPC客户端</h1><h2 id="KrpcChannel"><a href="#KrpcChannel" class="headerlink" title="KrpcChannel"></a>KrpcChannel</h2><blockquote>
<p>多态的应用</p>
</blockquote>
<p><code>UserServiceRpc_Stub</code>的构造函数必须传入一个<code>google::protobuf::RpcChannel</code>。所以我们必须自己实现一个<code>KrpcChannel</code>继承自<code>google::protobuf::RpcChannel</code> ，并实现它的<code>CallMethod</code>方法</p>
<blockquote>
<p><code>CallMethod</code>如何理解？</p>
</blockquote>
<ul>
<li><p><strong>客户端视角</strong>：<code>CallMethod</code> 是客户端存根（Stub）类调用的入口，负责将本地方法调用（如这里的<code>Login</code>）的参数序列化为网络传输格式，并通过网络发送给服务端（简单理解就是<strong>将本地方法调用转换为远程过程调用</strong>）</p>
<ul>
<li>客户端所有服务方法的调用最终都会转变为对<code>CallMethod</code>的调用，如Login：</li>
</ul>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/1234ff92ae5a0fac62f2656fddd6f9d0.png" alt="UserServiceRpc_stub::Login源码"></p>
</li>
<li><p><strong>服务端视角</strong>：服务端通过 <code>CallMethod</code> 接收请求后，根据消息头中的服务名和方法名路由到具体的服务实现，并触发本地方法执行</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/service.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;zookeeperutil.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自google::protobuf::RpcChannel</span></span><br><span class="line"><span class="comment">// 目的是为了给客户端进行方法调用的时候，统一接收的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KrpcChannel</span>: <span class="keyword">public</span> google::protobuf::RpcChannel&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">KrpcChannel</span>(<span class="type">bool</span> connectNow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">KrpcChannel</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写继承的CallMethod</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CallMethod</span><span class="params">(<span class="type">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::RpcController* controller, </span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Message* response, </span></span></span><br><span class="line"><span class="params"><span class="function">                    ::google::protobuf::Closure* done)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 建立与Rpc服务端的连接</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">newConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">uint16_t</span> port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向zookeeper服务器查询服务方法对应的Rpc服务端ip和端口</span></span><br><span class="line">    <span class="function">std::string <span class="title">QueryServiceHost</span><span class="params">(ZkClient* zkclient, <span class="type">const</span> std::string&amp; service_name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> std::string&amp; method_name, <span class="type">int</span>&amp; idx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 客户端通信的socket</span></span><br><span class="line">    <span class="type">int</span> m_clientSock;</span><br><span class="line">    <span class="comment">// 服务名</span></span><br><span class="line">    std::string m_service_name; </span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    std::string m_method_name;</span><br><span class="line">    <span class="comment">// Rpc服务端的ip和端口</span></span><br><span class="line">    std::string m_ip;</span><br><span class="line">    <span class="type">uint16_t</span> m_port;</span><br><span class="line">    <span class="comment">// 划分服务器ip和端口的下标</span></span><br><span class="line">    <span class="type">int</span> m_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>如果已经处于连接状态（connectNow &#x3D;&#x3D; True），则尝试与Rpc服务端进行连接</p>
<ul>
<li><strong>重试机制</strong>：当连接失败时，可以重试3次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">KrpcChannel::<span class="built_in">KrpcChannel</span>(<span class="type">bool</span> connectNow)</span><br><span class="line">    : <span class="built_in">m_clientSock</span>(<span class="number">-1</span>)</span><br><span class="line">    , <span class="built_in">m_idx</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!connectNow)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试与Rpc服务端进行连接，可以重试3次</span></span><br><span class="line">    <span class="keyword">auto</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(!rt &amp;&amp; cnt--)&#123;</span><br><span class="line">        rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="CallMethod"><a href="#CallMethod" class="headerlink" title="CallMethod"></a>CallMethod</h3><p>CallMethod的主要工作：</p>
<ol>
<li>连接Rpc服务器 ：查询zookeeper服务器获取ip和端口 → 调用<code>newConnect</code>连接服务端</li>
<li>序列化请求：打包header_size、header_str、args_size、args_str</li>
<li>发送请求：<code>send</code></li>
<li>接受响应：<code>recv</code></li>
<li>解析响应数据</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KrpcChannel::CallMethod</span><span class="params">(<span class="type">const</span> ::google::protobuf::MethodDescriptor* method,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::RpcController* controller, </span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> ::google::protobuf::Message* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::Message* response, </span></span></span><br><span class="line"><span class="params"><span class="function">                            ::google::protobuf::Closure* done)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 建立与Rpc服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span>(m_clientSock == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 获取服务对象名和方法名</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::ServiceDescriptor* sd = method-&gt;<span class="built_in">service</span>();</span><br><span class="line">        m_service_name = sd-&gt;<span class="built_in">name</span>();</span><br><span class="line">        m_method_name = method-&gt;<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向zookeeper服务器查询服务对象和方法对应的服务端host</span></span><br><span class="line">        ZkClient zkCli;</span><br><span class="line">        zkCli.<span class="built_in">Start</span>();</span><br><span class="line">        std::string server_host = <span class="built_in">QueryServiceHost</span>(&amp;zkCli, m_service_name, m_method_name, m_idx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析host</span></span><br><span class="line">        m_ip = server_host.<span class="built_in">substr</span>(<span class="number">0</span>, m_idx);</span><br><span class="line">        m_port = <span class="built_in">atoi</span>(server_host.<span class="built_in">substr</span>(m_idx + <span class="number">1</span>, server_host.<span class="built_in">size</span>() - m_idx).<span class="built_in">c_str</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Server ip: &quot;</span> &lt;&lt; m_ip &lt;&lt; <span class="string">&quot;, port: &quot;</span> &lt;&lt; m_port &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        <span class="type">bool</span> rt = <span class="built_in">newConnect</span>(m_ip.<span class="built_in">c_str</span>(), m_port);</span><br><span class="line">        <span class="keyword">if</span>(rt) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect server success&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;connect server error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 连接建立失败时返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装KrpcHeader</span></span><br><span class="line">    Krpc::RpcHeader krpcHeader;</span><br><span class="line">    <span class="comment">// - service_name</span></span><br><span class="line">    krpcHeader.<span class="built_in">set_service_name</span>(m_service_name);</span><br><span class="line">    <span class="comment">// - method_name</span></span><br><span class="line">    krpcHeader.<span class="built_in">set_method_name</span>(m_method_name);</span><br><span class="line">    <span class="comment">// - args_size</span></span><br><span class="line">    <span class="type">uint32_t</span> args_size&#123;&#125;;</span><br><span class="line">    std::string args_str;</span><br><span class="line">    <span class="comment">// 序列化参数到字符串</span></span><br><span class="line">    <span class="keyword">if</span>(request-&gt;<span class="built_in">SerializeToString</span>(&amp;args_str))&#123;</span><br><span class="line">        args_size = args_str.<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置KrpcController的错误信息</span></span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize request fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    krpcHeader.<span class="built_in">set_args_size</span>(args_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将(header_size、header_str、args_size、args_str)打包到send_rpc_str</span></span><br><span class="line">    std::string send_rpc_str;</span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    std::string rpc_header_str;</span><br><span class="line">    <span class="comment">// 序列化KrpcHeader到字符串</span></span><br><span class="line">    <span class="keyword">if</span>(krpcHeader.<span class="built_in">SerializeToString</span>(&amp;rpc_header_str))&#123;</span><br><span class="line">        header_size = rpc_header_str.<span class="built_in">size</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;serialize rpc header fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流式写入send_rpc_str</span></span><br><span class="line">    &#123;</span><br><span class="line">        google::protobuf::<span class="function">io::StringOutputStream <span class="title">string_output</span><span class="params">(&amp;send_rpc_str)</span></span>;</span><br><span class="line">        google::protobuf::<span class="function">io::CodedOutputStream <span class="title">coded_output</span><span class="params">(&amp;string_output)</span></span>;</span><br><span class="line">        coded_output.<span class="built_in">WriteVarint32</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(header_size));</span><br><span class="line">        coded_output.<span class="built_in">WriteString</span>(rpc_header_str);</span><br><span class="line">    &#125;</span><br><span class="line">    send_rpc_str += args_str;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送Rpc请求</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">send</span>(m_clientSock, send_rpc_str.<span class="built_in">c_str</span>(), send_rpc_str.<span class="built_in">size</span>(), <span class="number">0</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 发送请求失败</span></span><br><span class="line">        <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受Rpc请求的响应</span></span><br><span class="line">    <span class="type">char</span> recv_buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="built_in">recv</span>(m_clientSock, recv_buf, <span class="built_in">sizeof</span>(recv_buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_size == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化解析响应数据</span></span><br><span class="line">    <span class="keyword">if</span>(!response-&gt;<span class="built_in">ParseFromArray</span>(recv_buf, recv_size))&#123;</span><br><span class="line">        <span class="comment">// 解析失败</span></span><br><span class="line">        <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;parse&quot;</span>);</span><br><span class="line">        controller-&gt;<span class="built_in">SetFailed</span>(<span class="string">&quot;parse error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求-响应完毕，关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(m_clientSock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="newConnect"><a href="#newConnect" class="headerlink" title="newConnect"></a>newConnect</h3><p>获得服务端的ip和port后，建立与Rpc服务端的TCP连接。常规的socket编程客户端connect流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KrpcChannel::newConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ip, <span class="type">uint16_t</span> port)</span></span>&#123;</span><br><span class="line">    <span class="comment">// socket编程的客户端connect流程</span></span><br><span class="line">    <span class="type">int</span> clientfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(clientfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    server_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(clientfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;KrpcChannel::newConnect: connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_clientSock = clientfd;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="QueryServiceHost"><a href="#QueryServiceHost" class="headerlink" title="QueryServiceHost"></a>QueryServiceHost</h3><p>向zookeeper服务器查询服务方法对应的Rpc服务端的host</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">KrpcChannel::QueryServiceHost</span><span class="params">(ZkClient* zkclient, <span class="type">const</span> std::string&amp; service_name, </span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> std::string&amp; method_name, <span class="type">int</span>&amp; idx)</span></span>&#123;</span><br><span class="line">    std::string method_path = <span class="string">&#x27;/&#x27;</span> + service_name + <span class="string">&#x27;/&#x27;</span> + method_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上锁从zookeeper获取Rpc服务器host，保证多线程情况下每一个线程都能拿到信息</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mutex)</span></span>;</span><br><span class="line">    std::string server_host = zkclient-&gt;<span class="built_in">GetData</span>(method_path.<span class="built_in">c_str</span>());</span><br><span class="line">    lock.<span class="built_in">unlock</span>();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断host合法性</span></span><br><span class="line">    <span class="keyword">if</span>(server_host == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; method_path &lt;&lt; <span class="string">&quot; is no exist! \n&quot;</span>;</span><br><span class="line">        <span class="comment">// 不能返回空字符串，否则后续substr会出错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以&quot;:&quot;为分隔符分隔ip和port</span></span><br><span class="line">    idx = server_host.<span class="built_in">find</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ERROR: &quot;</span> &lt;&lt; method_path &lt;&lt; <span class="string">&quot; address is invalid! \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> server_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="客户端主函数"><a href="#客户端主函数" class="headerlink" title="客户端主函数"></a>客户端主函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcApplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KrpcChannel.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rpc客户端远端调用Rpc服务端的服务方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">send_request</span><span class="params">(<span class="type">int</span> thread_id, std::atomic&lt;<span class="type">int</span>&gt;&amp; success_cnt, std::atomic&lt;<span class="type">int</span>&gt;&amp; fail_cnt)</span></span>&#123;</span><br><span class="line">    <span class="function">Kuser::UserServiceRpc_Stub <span class="title">stub</span><span class="params">(<span class="keyword">new</span> KrpcChannel(<span class="literal">false</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Rpc请求参数</span></span><br><span class="line">    Kuser::LoginRequest request;</span><br><span class="line">    request.<span class="built_in">set_name</span>(<span class="string">&quot;yu&quot;</span>);</span><br><span class="line">    request.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建Rpc响应参数</span></span><br><span class="line">    Kuser::LoginResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程调用Login方法</span></span><br><span class="line">    KrpcController controller;</span><br><span class="line">    <span class="comment">// 这里Login实际就是通过KrpcChannel::CallMethod间接调用的</span></span><br><span class="line">    stub.<span class="built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 读取响应</span></span><br><span class="line">    <span class="keyword">if</span>(controller.Failed)&#123;</span><br><span class="line">        <span class="comment">// 调用失败</span></span><br><span class="line">        std::cout &lt;&lt; controller.<span class="built_in">ErrorText</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(response.<span class="built_in">result</span>().<span class="built_in">errcode</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Rpc login response success: &quot;</span> &lt;&lt; response.<span class="built_in">success</span>() &lt;&lt; std::endl;</span><br><span class="line">            ++success_cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Rpc login response success: &quot;</span> &lt;&lt; response.<span class="built_in">result</span>().<span class="built_in">errmsg</span>() &lt;&lt; std::endl;</span><br><span class="line">            ++fail_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 程序启动后，调用KrpcApplication类进行初始化</span></span><br><span class="line">    KrpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程配置属性</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> thread_cnt = <span class="number">1000</span>;        <span class="comment">// 并发线程数</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> request_per_thread = <span class="number">10</span>;  <span class="comment">// 每个线程发送的请求数</span></span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">success_cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">fail_cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序开始时间</span></span><br><span class="line">    <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动多线程并发测试</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_cnt; ++i)&#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>([argc, argv, i, &amp;success_cnt, &amp; fail_cnt]()&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; request_per_thread; ++j)&#123;</span><br><span class="line">                <span class="built_in">send_request</span>(i, success_cnt, fail_cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞等待所有线程执行完成</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : threads)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序结束时间，并计算程序执行时间</span></span><br><span class="line">    <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    std::chrono::duration&lt;<span class="type">double</span>&gt; elapsed = end_time - start_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出统计结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Total requests: &quot;</span> &lt;&lt; thread_cnt * request_per_thread &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Success count: &quot;</span> &lt;&lt; success_cnt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Fail count: &quot;</span> &lt;&lt; fail_cnt &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time: &quot;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; seconds&quot;</span> &lt;&lt; std::end;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;QPS: &quot;</span> &lt;&lt; (thread_cnt * request_per_thread) / elapsed.<span class="built_in">count</span>() &lt;&lt; std::endl;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="send-request"><a href="#send-request" class="headerlink" title="send_request"></a>send_request</h3><p>客户端通过<code>send_request</code> 远端调用<code>Login</code>方法</p>
<h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><p>进行Rpc框架的多线程并发测试</p>
<h1 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h1><p>分别运行服务端、客户端即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.在example文件夹和src文件夹中为proto文件生成.h和.cc文件</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.回到项目根目录，使用以下命令编译生成可执行文件</span></span><br><span class="line">mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make -j$&#123;nproc&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.进入bin文件夹，在不同会话中分别运行server和client</span></span><br><span class="line">./server -i ./test.conf</span><br><span class="line">./client -i ./test.conf</span><br></pre></td></tr></table></figure>


<h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><ul>
<li>测试平台：阿里云服务器</li>
<li>操作系统：Ubuntu 22.04</li>
<li>CPU：2核</li>
<li>内存：2G</li>
<li>硬盘：40G</li>
</ul>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><ul>
<li><p>并发线程数<code>200</code>，每个线程发送的请求数<code>10</code>：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Total requests: 2000</span><br><span class="line">Success count: 2000</span><br><span class="line">Fail count: 0</span><br><span class="line">Elapsed time: 10.4225 seconds</span><br><span class="line">QPS: 191.892</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发线程数<code>1000</code>，每个线程发送的请求数<code>10</code>：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Total requests: 10000</span><br><span class="line">Success count: 10000</span><br><span class="line">Fail count: 0</span><br><span class="line">Elapsed time: 79.2326 seconds</span><br><span class="line">QPS: 126.21</span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://atelieryu.site">Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://atelieryu.site/posts/ccad8bf.html">https://atelieryu.site/posts/ccad8bf.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://atelieryu.site" target="_blank">Yu的炼金工房</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/RPC/">RPC</a><a class="post-meta__tags" href="/tags/Protobuf/">Protobuf</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div><div class="post-share"><div class="social-share" data-image="https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width no-desc" href="/posts/522b2664.html" title="Protobuf简易使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/29adb56737da425f642d3dd22328e4eb.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Protobuf简易使用</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/posts/522b2664.html" title="Protobuf简易使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/29adb56737da425f642d3dd22328e4eb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">Protobuf简易使用</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/kurumi.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YVollerei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/YVollerei" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-githublogo"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/7661819" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://steamcommunity.com/profiles/76561198310594699/" target="_blank" title="Steam"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-steam_icon"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=58377889@qq.com" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RPC%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">RPC简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.2.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BB%93%E5%BA%93"><span class="toc-number">1.3.</span> <span class="toc-text">项目仓库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">项目概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">框架流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">代码调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E4%B8%BB%E4%BD%93"><span class="toc-number">2.2.1.</span> <span class="toc-text">三个主体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Protobuf"><span class="toc-number">3.</span> <span class="toc-text">Protobuf</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Krpcheader-proto"><span class="toc-number">3.1.</span> <span class="toc-text">Krpcheader.proto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#user-proto"><span class="toc-number">3.2.</span> <span class="toc-text">user.proto</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Login%E5%92%8CRegister"><span class="toc-number">3.2.1.</span> <span class="toc-text">Login和Register</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cc-generic-services"><span class="toc-number">3.2.2.</span> <span class="toc-text">cc_generic_services</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="toc-number">3.3.</span> <span class="toc-text">生成代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">4.</span> <span class="toc-text">RPC服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BB%E6%96%87%E4%BB%B6Kserver-cpp"><span class="toc-number">4.1.</span> <span class="toc-text">服务端主文件Kserver.cpp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UserService"><span class="toc-number">4.1.1.</span> <span class="toc-text">UserService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main"><span class="toc-number">4.1.2.</span> <span class="toc-text">main</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">为服务端提供服务的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KrpcApplication"><span class="toc-number">4.2.1.</span> <span class="toc-text">KrpcApplication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KrpcConfig"><span class="toc-number">4.2.2.</span> <span class="toc-text">KrpcConfig</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KrpcProvider"><span class="toc-number">4.3.</span> <span class="toc-text">KrpcProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NotifyService"><span class="toc-number">4.3.2.</span> <span class="toc-text">NotifyService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Run"><span class="toc-number">4.3.3.</span> <span class="toc-text">Run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnConnection"><span class="toc-number">4.3.4.</span> <span class="toc-text">OnConnection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnMessage"><span class="toc-number">4.3.5.</span> <span class="toc-text">OnMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SendRpcResponse"><span class="toc-number">4.3.6.</span> <span class="toc-text">SendRpcResponse</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeperutil"><span class="toc-number">4.4.</span> <span class="toc-text">zookeeperutil</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#global-watcher"><span class="toc-number">4.4.1.</span> <span class="toc-text">global_watcher</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KrpcController"><span class="toc-number">4.5.</span> <span class="toc-text">KrpcController</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.</span> <span class="toc-text">RPC客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KrpcChannel"><span class="toc-number">5.1.</span> <span class="toc-text">KrpcChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CallMethod"><span class="toc-number">5.1.2.</span> <span class="toc-text">CallMethod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newConnect"><span class="toc-number">5.1.3.</span> <span class="toc-text">newConnect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QueryServiceHost"><span class="toc-number">5.1.4.</span> <span class="toc-text">QueryServiceHost</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">客户端主函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#send-request"><span class="toc-number">5.2.1.</span> <span class="toc-text">send_request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">main</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="toc-number">6.1.</span> <span class="toc-text">测试环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">6.2.</span> <span class="toc-text">测试结果</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/ccad8bf.html" title="C++实现轻量级RPC分布式网络通信框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++实现轻量级RPC分布式网络通信框架"/></a><div class="content"><a class="title" href="/posts/ccad8bf.html" title="C++实现轻量级RPC分布式网络通信框架">C++实现轻量级RPC分布式网络通信框架</a><time datetime="2025-03-18T12:38:00.000Z" title="发表于 2025-03-18 20:38:00">2025-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/522b2664.html" title="Protobuf简易使用"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/29adb56737da425f642d3dd22328e4eb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Protobuf简易使用"/></a><div class="content"><a class="title" href="/posts/522b2664.html" title="Protobuf简易使用">Protobuf简易使用</a><time datetime="2025-03-17T01:48:00.000Z" title="发表于 2025-03-17 09:48:00">2025-03-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/bb92517d.html" title="2025一月番追番记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/04dd9b6026e684a4b6089ec5fd33b805.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025一月番追番记录"/></a><div class="content"><a class="title" href="/posts/bb92517d.html" title="2025一月番追番记录">2025一月番追番记录</a><time datetime="2025-03-16T09:24:00.000Z" title="发表于 2025-03-16 17:24:00">2025-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3bcc203.html" title="基于Elog的 Notion-hexo 同步方案"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog-image-plugin-test/30605dd537ff7e35f6a853d1edb64c14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Elog的 Notion-hexo 同步方案"/></a><div class="content"><a class="title" href="/posts/3bcc203.html" title="基于Elog的 Notion-hexo 同步方案">基于Elog的 Notion-hexo 同步方案</a><time datetime="2025-03-16T03:37:00.000Z" title="发表于 2025-03-16 11:37:00">2025-03-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://atelieryu.xyz/PicGo/footer.jpeg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Yu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.atelieryu.site/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.atelieryu.site/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://fastly.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>addEventListener("DOMContentLoaded",function(){let models=[{width:300,height:350,right:"40px",bottom:"0px",role:"/live2d_models/阿米娅/阿米娅(1).model3.json",background:"",opacity:1,mobile:false,draggable:false,scale:0.1},];new Live2dLoader(models)});</script><div class="aplayer no-destroy" data-id="13432525808" data-server="netease" data-type="playlist" data-order="random" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" data-volume="0.25" data-showlrc="false" data-lrc-type="0"></div><script id="canvas_nest" defer="defer" color="106,114,255" opacity="0.7" zIndex="-1" count="100" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://fastly.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="会搜出什么呢......" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover1.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACGN/&quot;);" href="javascript:void(0);">ACGN</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover2.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习笔记/&quot;);" href="javascript:void(0);">学习笔记</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover3.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/技术随记/&quot;);" href="javascript:void(0);">技术随记</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '3d14be69ac344084881f00a1a2ba6169';
  var gaud_map_key = 'db9c16c529193cc3f1649f61aca0db13';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a><a class="github-badge" target="_blank" href="https://www.cloudflare.com/zh-cn/" style="margin-inline:5px" data-title="本站图片资源由CloudflareR2托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/ImageHost-Cloudflare-F38020?style=flat&amp;logo=Cloudflare" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>