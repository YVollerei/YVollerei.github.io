<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++高性能服务器框架Sylar（一）——日志模块 | Yu的炼金工房</title><meta name="author" content="Yu"><meta name="copyright" content="Yu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="模块概述模仿log4j日志框架实现一个的日志模块  难点：Logformatter的init()，引入了一个简单的状态机机制，实现了将一个字符串解析为模板 设计点： LogEventWrap：一个封装LogEvent和Logger的RAII类 LoggerManager：一个管理Logger的单例类 LogAppender：一个抽象基类，可以方便地扩展日志的输出地 一系列辅助函数： 优化用户使用方">
<meta property="og:type" content="article">
<meta property="og:title" content="C++高性能服务器框架Sylar（一）——日志模块">
<meta property="og:url" content="https://atelieryu.site/Sylar%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">
<meta property="og:site_name" content="Yu的炼金工房">
<meta property="og:description" content="模块概述模仿log4j日志框架实现一个的日志模块  难点：Logformatter的init()，引入了一个简单的状态机机制，实现了将一个字符串解析为模板 设计点： LogEventWrap：一个封装LogEvent和Logger的RAII类 LoggerManager：一个管理Logger的单例类 LogAppender：一个抽象基类，可以方便地扩展日志的输出地 一系列辅助函数： 优化用户使用方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://atelieryu.xyz/elog/202503/a8604dd41597308b4187f82906e13a21.jpg">
<meta property="article:published_time" content="2025-03-29T07:12:00.000Z">
<meta property="article:modified_time" content="2025-03-29T10:01:00.000Z">
<meta property="article:author" content="Yu">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="日志库">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="服务器框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://atelieryu.xyz/elog/202503/a8604dd41597308b4187f82906e13a21.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++高性能服务器框架Sylar（一）——日志模块",
  "url": "https://atelieryu.site/Sylar%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97",
  "image": "https://atelieryu.xyz/elog/202503/a8604dd41597308b4187f82906e13a21.jpg",
  "datePublished": "2025-03-29T07:12:00.000Z",
  "dateModified": "2025-03-29T10:01:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yu",
      "url": "https://atelieryu.site/"
    }
  ]
}</script><link rel="shortcut icon" href="https://atelieryu.xyz/PicGo/shizuku.png"><link rel="canonical" href="https://atelieryu.site/Sylar%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#3F4F44')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++高性能服务器框架Sylar（一）——日志模块',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://fastly.jsdelivr.net/npm/pace-js@latest/pace.min.js"></script><link rel="stylesheet" href="/css/corner-indicator.css" /><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><script src="https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js"></script><script src="https://fastly.jsdelivr.net/combine/gh/dylanNew/live2d/webgl/Live2D/lib/live2d.min.js,npm/pixi.js@6.5.2/dist/browser/pixi.min.js,npm/pixi-live2d-display/dist/index.min.js,gh/Weidows-projects/Live2dLoader/dist/Live2dLoader.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Yu的炼金工房" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/kurumi.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-pink"></use></svg><span> 追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chaxun"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://atelieryu.xyz/elog/202503/a8604dd41597308b4187f82906e13a21.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/shizuku_logo.png" alt="Logo"><span class="site-name">Yu的炼金工房</span></a><a class="nav-page-title" href="/"><span class="site-name">C++高性能服务器框架Sylar（一）——日志模块</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouye"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/index.html"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili-pink"></use></svg><span> 追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xinfeng"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chaxun"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C++高性能服务器框架Sylar（一）——日志模块</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-29T07:12:00.000Z" title="发表于 2025-03-29 15:12:00">2025-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-29T10:01:00.000Z" title="更新于 2025-03-29 18:01:00">2025-03-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.3k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h1><p>模仿log4j日志框架实现一个的日志模块</p>
<ul>
<li>难点：Logformatter的init()，引入了一个简单的状态机机制，实现了将一个字符串解析为模板</li>
<li>设计点：<ul>
<li><strong>LogEventWrap</strong>：一个封装LogEvent和Logger的<strong>RAII类</strong></li>
<li><strong>LoggerManager</strong>：一个管理Logger的<strong>单例类</strong></li>
<li><strong>LogAppender</strong>：一个<strong>抽象基类</strong>，可以方便地扩展日志的输出地</li>
<li><strong>一系列辅助函数</strong>：<ul>
<li>优化用户使用方式，用户可使用<strong>流式方式或格式化方式</strong>进行日志内容的写入</li>
<li>包括一系列宏函数和inline，辅助函数创建LogEventWrap来实现日志的输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="模块UML类图"><a href="#模块UML类图" class="headerlink" title="模块UML类图"></a>模块UML类图</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/49d699bf874ff79e3f2cf7a2245d2330.png" alt="日志模块类图"></p>
<h2 id="Logger：日志器"><a href="#Logger：日志器" class="headerlink" title="Logger：日志器"></a>Logger：日志器</h2><ul>
<li>负责进行日志输出</li>
<li>一个日志器可指定一个日志级别（LogLevel）和多个日志输出地（LogAppender）</li>
<li>提供log方法，传入日志事件，如果该日志事件的级别高于日志器本身的级别则将其输出，否则将该日志抛弃。</li>
</ul>
<h2 id="LogAppender：日志输出器"><a href="#LogAppender：日志输出器" class="headerlink" title="LogAppender：日志输出器"></a>LogAppender：日志输出器</h2><ul>
<li>用于将一个日志事件输出到对应的输出地。</li>
<li>类内部包含一个日志格式器（LogFormatter）成员和一个log方法，日志事件经过格式化后输出到对应的输出地。</li>
<li>由于有多种输出地，所以该类成为一个<strong>抽象基类</strong>，其派生类必须重写它的log方法<ul>
<li>比如StdoutLogAppender和FileLogAppender为LogAppender的派生类，分别表示输出到终端和文件。</li>
</ul>
</li>
</ul>
<h2 id="LogFormatter：日志格式器"><a href="#LogFormatter：日志格式器" class="headerlink" title="LogFormatter：日志格式器"></a>LogFormatter：日志格式器</h2><ul>
<li>与log4cpp的PatternLayout对应，用于格式化一个日志事件（输出log4j日志格式）。</li>
<li>该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。<ul>
<li>pattern中每个模板参数或字符串对应一个FormatItem派生类</li>
</ul>
</li>
</ul>
<h2 id="LogEvent：日志事件"><a href="#LogEvent：日志事件" class="headerlink" title="LogEvent：日志事件"></a>LogEvent：日志事件</h2><ul>
<li>用于记录日志现场，比如该日志的级别，文件名&#x2F;行号，日志消息，线程&#x2F;协程号，所属日志器名称等。</li>
<li>可以理解为一个日志事件对应一条日志</li>
</ul>
<h2 id="LogEventWrap：日志事件包装类"><a href="#LogEventWrap：日志事件包装类" class="headerlink" title="LogEventWrap：日志事件包装类"></a>LogEventWrap：日志事件包装类</h2><ul>
<li>LogEventWrap是一个<strong>RAII类</strong><ul>
<li>LogEventWrap在构造时指定日志事件和日志器</li>
<li>在析构时调用日志器的log方法将日志事件进行输出</li>
</ul>
</li>
<li>LogEventWrap将日志事件和日志器包装到一起<ul>
<li>一条日志只会在一个日志器上进行输出</li>
<li>将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。</li>
</ul>
</li>
<li>为什么需要LogEventWrap？<ul>
<li>由于LogEvent::ptr是智能指针，所以如果直接创建LogEvent::ptr，智能指针将在主函数结束时才释放。</li>
<li>LogEventWrap的getSS()方法支持以流式方式将日志写入logger</li>
<li>使用RAII类管理LogEvent，可以<strong>在LogEventWrap析构时自动提交日志事件，并将其释放</strong></li>
</ul>
</li>
</ul>
<h2 id="LogManager：日志器管理类"><a href="#LogManager：日志器管理类" class="headerlink" title="LogManager：日志器管理类"></a>LogManager：日志器管理类</h2><ul>
<li><strong>单例模式</strong>，用于统一管理所有的日志器，提供日志器的创建与获取方法<ul>
<li><strong>LogManager应成为创建Logger的唯一方式，所有的Logger都应该经由LogManager获取</strong></li>
<li>通过singleton.h中定义的单例类GetInstance方法返回LoggerManager的单例对象</li>
</ul>
</li>
<li>getRoot方法：LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。</li>
<li>getLogger方法：根据一个名字搜索容器中已有的logger或新建一个logger</li>
</ul>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p><code>~LogEventWrap()</code> → <code>Logger::log()</code> → <code>LogAppender::log()</code> → <code>LogFormatter::format()</code></p>
<h1 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h1><h2 id="LogLevel"><a href="#LogLevel" class="headerlink" title="LogLevel"></a>LogLevel</h2><blockquote>
<p>LogLevel表示日志级别</p>
</blockquote>
<ul>
<li>类中定义了7种日志级别，实现了日志的分级输出</li>
<li>提供了<code>ToString</code>和<code>FromString</code>两个静态方法，支持将日志级别名称转换为字符串，或将字符串转换为日志级别<ul>
<li><code>FromString</code>对输入字符串的大小写不敏感</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogLevel</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Level</span>&#123;</span><br><span class="line">        UNKNOW = <span class="number">0</span>,     <span class="comment">// 未知级别</span></span><br><span class="line">        DEBUG = <span class="number">1</span>,      <span class="comment">// DEBUG级别</span></span><br><span class="line">        INFO = <span class="number">2</span>,       <span class="comment">// INFO级别</span></span><br><span class="line">        WARN = <span class="number">3</span>,       <span class="comment">// WARN级别</span></span><br><span class="line">        ERROR = <span class="number">4</span>,      <span class="comment">// ERROR级别</span></span><br><span class="line">        FATAL = <span class="number">5</span>,      <span class="comment">// FATAL级别</span></span><br><span class="line">        NOTSET = <span class="number">100</span>    <span class="comment">// NOSET级别，表示不可访问</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ToString</span><span class="params">(Level level)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Level <span class="title">FromString</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过宏函数简化了<code>ToString</code>和<code>FromString</code>的书写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">LogLevel::ToString</span><span class="params">(Level level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (level)&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XX(name) case LogLevel::name: return #name;</span></span><br><span class="line">        <span class="built_in">XX</span>(DEBUG);</span><br><span class="line">        <span class="built_in">XX</span>(INFO);</span><br><span class="line">        <span class="built_in">XX</span>(WARN);</span><br><span class="line">        <span class="built_in">XX</span>(ERROR);</span><br><span class="line">        <span class="built_in">XX</span>(FATAL);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XX</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UNKNOW&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LogLevel::Level <span class="title">LogLevel::FromString</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">strlower</span><span class="params">(str.size(), <span class="string">&#x27;\0&#x27;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">transform</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>(), strlower.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XX(level, v) <span class="keyword">if</span>(strlower == #v)&#123; return LogLevel::level; &#125;</span></span><br><span class="line">    <span class="built_in">XX</span>(DEBUG, debug);</span><br><span class="line">    <span class="built_in">XX</span>(INFO, info);</span><br><span class="line">    <span class="built_in">XX</span>(WARN, warn);</span><br><span class="line">    <span class="built_in">XX</span>(ERROR, error);</span><br><span class="line">    <span class="built_in">XX</span>(FATAL, fatal);</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XX</span></span><br><span class="line">    <span class="keyword">return</span> UNKNOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LogEvent"><a href="#LogEvent" class="headerlink" title="LogEvent"></a>LogEvent</h2><blockquote>
<p>LogEvent用于记录日志现场</p>
</blockquote>
<p>一个日志事件具体包括以下内容：</p>
<ul>
<li>日志内容</li>
<li>日志器名称</li>
<li>日志级别</li>
<li>文件名，对应__FILE__宏</li>
<li>行号，对应__LINE__宏</li>
<li>程序运行时间，通过sylar::GetElapsedMS()获取</li>
<li>线程ID</li>
<li>协程ID</li>
<li>UTC时间戳，对应time(0)</li>
<li>线程名称</li>
</ul>
<p>LogEvent提供了<code>format</code>方法，将以上信息格式化写入日志内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志事件，用于记录日志现场</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogEvent</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogEvent&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogEvent</span>(std::string loggerName, LogLevel::Level level, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int32_t</span> line</span><br><span class="line">        , <span class="type">int64_t</span> elapse, <span class="type">uint32_t</span> thread_id, <span class="type">uint64_t</span> fiber_id, <span class="type">time_t</span> time</span><br><span class="line">        , <span class="type">const</span> std::string &amp;thread_name);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getFile</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_file; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int32_t</span> <span class="title">getLine</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_line; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getElapse</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_elapse; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getThreadId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_threadId; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">getFiberId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_fiberId; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint64_t</span> <span class="title">getTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_time; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> std::string&amp; <span class="title">getThreadName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_threadName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getContent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ss.<span class="built_in">str</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::stringstream&amp; <span class="title">getSS</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ss; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getLoggerName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_loggerName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LogLevel::Level <span class="title">getLevel</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_level; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以格式化方式将内容写入m_ss</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* fmt, Args&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取格式化字符串的长度</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">snprintf</span>(<span class="literal">nullptr</span>, <span class="number">0</span>, fmt, args...);</span><br><span class="line">        <span class="keyword">if</span>(len &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用snprintf，将格式化字符串写入缓冲区</span></span><br><span class="line">            <span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">snprintf</span>(buf, len + <span class="number">1</span>, fmt, args...);</span><br><span class="line">            m_ss &lt;&lt; std::<span class="built_in">string</span>(buf, len);</span><br><span class="line">            <span class="keyword">delete</span>[] buf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_loggerName;           <span class="comment">// 日志器</span></span><br><span class="line">    LogLevel::Level m_level;            <span class="comment">// 日志级别</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* m_file = <span class="literal">nullptr</span>;       <span class="comment">// 文件名</span></span><br><span class="line">    <span class="type">int32_t</span> m_line = <span class="number">0</span>;                 <span class="comment">// 行号</span></span><br><span class="line">    <span class="type">uint32_t</span> m_elapse = <span class="number">0</span>;              <span class="comment">// 程序启动到现在的毫秒数</span></span><br><span class="line">    <span class="type">uint32_t</span> m_threadId = <span class="number">0</span>;            <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="type">uint32_t</span> m_fiberId = <span class="number">0</span>;             <span class="comment">// 协程ID</span></span><br><span class="line">    <span class="type">uint64_t</span> m_time = <span class="number">0</span>;                <span class="comment">// 时间戳</span></span><br><span class="line">    std::string m_threadName;           <span class="comment">// 线程名称</span></span><br><span class="line">    std::stringstream m_ss;             <span class="comment">// 日志内容流</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line">LogEvent::<span class="built_in">LogEvent</span>(std::string loggerName, LogLevel::Level level, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int32_t</span> line</span><br><span class="line">        , <span class="type">int64_t</span> elapse, <span class="type">uint32_t</span> thread_id, <span class="type">uint64_t</span> fiber_id, <span class="type">time_t</span> time</span><br><span class="line">        , <span class="type">const</span> std::string &amp;thread_name)</span><br><span class="line">    : <span class="built_in">m_loggerName</span>(loggerName) </span><br><span class="line">    , <span class="built_in">m_level</span>(level)</span><br><span class="line">    , <span class="built_in">m_file</span>(file)</span><br><span class="line">    , <span class="built_in">m_line</span>(line)</span><br><span class="line">    , <span class="built_in">m_elapse</span>(elapse)</span><br><span class="line">    , <span class="built_in">m_threadId</span>(thread_id)</span><br><span class="line">    , <span class="built_in">m_fiberId</span>(fiber_id)</span><br><span class="line">    , <span class="built_in">m_time</span>(time)</span><br><span class="line">    , <span class="built_in">m_threadName</span>(thread_name) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LogFormatter"><a href="#LogFormatter" class="headerlink" title="LogFormatter"></a>LogFormatter</h2><blockquote>
<p>LogFormatter用于将日志事件LogEvent格式化（模仿log4j日志框架）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志格式器，将日志事件格式化为字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogFormatter</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogFormatter&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogFormatter</span>(<span class="type">const</span> std::string&amp; pattern = <span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ostream&amp; <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isError</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_error; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getPattern</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_pattern; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 抽象基类FormatItem，用于格式化某一项日志内容</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">FormatItem</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> ptr = std::shared_ptr&lt;FormatItem&gt;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">FormatItem</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_pattern;</span><br><span class="line">    std::vector&lt;FormatItem::ptr&gt; m_items;</span><br><span class="line">    <span class="type">bool</span> m_error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h3><p>由于一个日志事件包括了很多的内容（参考LogEvent），但实际上用户并不希望每次输出日志时都将这些信息全部进行输出，而是希望可以自由地选择要输出的信息。并且，用户还可能需要在每条日志里增加一些指定的字符，比如在文件名和行号之间加上一个冒号的情况。</p>
<p>为了实现这项功能，LogFormatter使用了一个模板字符串来指定格式化的方式。模板字符串由普通字符和转义字符构成，<strong>转义字符以%开头</strong>，比如%m，%p等。除了转义字符，剩下的全部都是普通字符，包括空格，当前支持以下转义字符：</p>
<figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%m 消息</span><br><span class="line">%p 日志级别</span><br><span class="line">%r 累计毫秒数</span><br><span class="line">%c 日志名称</span><br><span class="line">%t 线程id</span><br><span class="line">%n 换行</span><br><span class="line">%d 时间</span><br><span class="line">%f 文件名</span><br><span class="line">%l 行号</span><br><span class="line">%T 制表符</span><br><span class="line">%F 协程id</span><br><span class="line">%N 线程名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认格式</p>
</blockquote>
<ul>
<li>默认格式： <code>&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125;%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n&quot;</code></li>
<li>描述：年-月-日 时:分:秒 [累计运行毫秒数] \t 线程id \t 线程名称 \t 协程id \t [日志级别] \t [日志器名称] \t 文件名:行号 \t 日志消息 换行符</li>
</ul>
<h3 id="嵌套类FormatItem"><a href="#嵌套类FormatItem" class="headerlink" title="嵌套类FormatItem"></a>嵌套类FormatItem</h3><ul>
<li><p>FormatItem：日志内容格式化项，一个抽象基类，每个格式模板参数实现一个FormatItem的派生类</p>
<ul>
<li><code>void format(std::ostream os, LogEvent::ptr event)</code>：将event中对应模板参数的内容格式化后写入os</li>
</ul>
</li>
<li><p>具体的派生类如下：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// %m</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MessageFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getContent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %p</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LevelFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LevelFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; LogLevel::<span class="built_in">ToString</span>(event-&gt;<span class="built_in">getLevel</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %c</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggerNameFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LoggerNameFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getLoggerName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %d</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateTimeFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DateTimeFormatItem</span>(<span class="type">const</span> std::string&amp; format = <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">    : <span class="built_in">m_format</span>(format)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_format.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            m_format = <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;    </span><br><span class="line">        <span class="type">time_t</span> time = event-&gt;<span class="built_in">getTime</span>();</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* tm = <span class="built_in">localtime</span>(&amp;time);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strftime</span>(buf, <span class="built_in">sizeof</span>(buf), m_format.<span class="built_in">c_str</span>(), tm);</span><br><span class="line">        os &lt;&lt; buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_format;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %r</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElapseFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ElapseFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getElapse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %f</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FilenameFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FilenameFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getFile</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %l</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LineFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LineFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getLine</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %t</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadIdFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadIdFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getThreadId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %f</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FiberIdFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FiberIdFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getFiberId</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %N</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadNameFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadNameFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; event-&gt;<span class="built_in">getThreadName</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %%</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PercentSignFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PercentSignFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TabFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TabFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %n</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewLineFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NewLineFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化模板参数外的字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringFormatItem</span>: <span class="keyword">public</span> LogFormatter::FormatItem&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringFormatItem</span>(<span class="type">const</span> std::string&amp; str = <span class="string">&quot;&quot;</span>): <span class="built_in">m_string</span>(str)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; m_string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_string;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>format使用多态，逐个调用FormatItem派生类的format方法，将日志信息写入os</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostream&amp; <span class="title">LogFormatter::format</span><span class="params">(std::ostream&amp; os, LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; formatItem : m_items)&#123;</span><br><span class="line">        formatItem-&gt;format(os, event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote>
<p><code>init()</code>是LogFormatter的实现重点，其作用是将m_pattern解析为一个FormatItem::ptr数组，并存入m_item</p>
</blockquote>
<p>init的逻辑大致只有以下两步，但实现方式需要多琢磨</p>
<ol>
<li><p>使用一个简单的基于状态机的解析方案，解析模板字符串与常规字符</p>
<ul>
<li>支持解析上面列举的转义字符，并且支持将连续的普通字符合并成一个字符串</li>
</ul>
 <figure class="highlight plaintext"><figcaption><span>text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">| 当前字符是否是%？</span><br><span class="line">    --&gt;是</span><br><span class="line">        --&gt;状态机状态为正在解析模板参数</span><br><span class="line">            - 当前字符为转义%，将模板参数记录到数组</span><br><span class="line">        --&gt;状态机状态为正在解析常规字符串</span><br><span class="line">            - 当前常规字符串解析完成，保存已解析的常规字符串</span><br><span class="line">            - 准备开始解析模板参数，状态机状态变为正在解析模板参数</span><br><span class="line">    --&gt;否</span><br><span class="line">        --&gt;状态机状态为正在解析模板参数</span><br><span class="line">            - 将模板参数记录到数组（对于日期格式(模板参数为d)，还需要进一步进行处理）</span><br><span class="line">            - 解析完模板参数，状态机状态变为正在解析常规字符串</span><br><span class="line">        --&gt;状态机状态为正在解析常规字符串</span><br><span class="line">            - 记录字符到字符串</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建模板参数对应的<code>FormatItem</code>对象（使用宏函数）</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogFormatter::init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// &lt;type, str&gt;</span></span><br><span class="line">    <span class="comment">// type: 为0时表示为普通字符串，为1时表示为需要解析的模板参数</span></span><br><span class="line">    <span class="comment">// str: 存储字符串内容（普通字符串 or 模板参数）</span></span><br><span class="line">    std::vector&lt;std::pair&lt;<span class="type">int</span>, std::string&gt;&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板参数中只有%d（日期时间）需要额外存储模板字符串，所以使用一个单独的变量dataFormat来存储</span></span><br><span class="line">    std::string dateFormat;</span><br><span class="line">    <span class="comment">// 存储常规字符串</span></span><br><span class="line">    std::string normalString;</span><br><span class="line">    <span class="comment">// 状态机，true表示正在解析普通字符串，false表示正在解析模板参数或模板字符串</span></span><br><span class="line">    <span class="type">bool</span> parsing_string = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; m_pattern.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        std::string c = std::<span class="built_in">string</span>(<span class="number">1</span>, m_pattern[i]);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&quot;%&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parsing_string)&#123;</span><br><span class="line">                <span class="comment">// 解析常规字符串时碰到%，本段常规字符串的解析完成，状态机变为解析模板字符串模式</span></span><br><span class="line">                <span class="keyword">if</span>(!normalString.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, normalString));</span><br><span class="line">                    normalString.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                parsing_string = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 解析模板参数时碰到%，说明是转义%</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, c));</span><br><span class="line">                parsing_string = <span class="literal">true</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(parsing_string)&#123;</span><br><span class="line">                <span class="comment">// 解析常规字符串时，不断将当前字符加入normalString，直到遇到%</span></span><br><span class="line">                normalString += c;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 解析模板字符：直接将模板字符加入vec</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">1</span>, c));   </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对日期时间（%d），还需要另外解析dateFormat</span></span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&quot;d&quot;</span>)&#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                    <span class="keyword">if</span>(m_pattern[i] != <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">// %d后没有跟 &#123;&#125;，dateFormat为空，解析结果依赖DataFormatItem类的默认实现</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ++i;</span><br><span class="line">                        <span class="comment">// 将 &#123;&#125; 之间的所有字符都加入dateFormat</span></span><br><span class="line">                        <span class="keyword">while</span>(i &lt; m_pattern.<span class="built_in">size</span>() &amp;&amp; m_pattern[i] != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                            dateFormat.<span class="built_in">push_back</span>(m_pattern[i]);</span><br><span class="line">                            ++i;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果遍历到m_pattern尾部都没有遇到&#x27;&#125;&#x27;，说明大括号没有闭合，解析错误</span></span><br><span class="line">                        <span class="keyword">if</span>(i == m_pattern.<span class="built_in">size</span>() &amp;&amp; m_pattern[i - <span class="number">1</span>] != <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                            <span class="comment">// log中加入错误信息</span></span><br><span class="line">                            vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="string">&quot;&lt;&lt;Pattern Error&gt;&gt;&quot;</span>));</span><br><span class="line">                            dateFormat.<span class="built_in">clear</span>();</span><br><span class="line">                            m_error = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 模板字符串解析完成，状态机转为默认状态（即解析常规字符串）</span></span><br><span class="line">                parsing_string = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将尾部的常规字符串也加入vec</span></span><br><span class="line">    <span class="keyword">if</span>(!normalString.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(std::<span class="built_in">pair</span>(<span class="number">0</span>, normalString));</span><br><span class="line">        normalString.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串到具体FormatItem类的映射，相当于一个简易工厂类</span></span><br><span class="line">    <span class="comment">// 利用宏函数初始化map的成员，两个宏参数：</span></span><br><span class="line">    <span class="comment">// str：通过#str将str的内容字符串化，指定std::function需要生成FormatItem的哪个派生类</span></span><br><span class="line">    <span class="comment">// std::function：接收一个字符串，用该字符串初始化指定的派生类</span></span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string, std::function&lt;FormatItem::ptr(<span class="type">const</span> std::string&amp; str)&gt;&gt; s_format_items = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XX(str, C) &#123;#str, [](const std::string&amp; fmt)&#123; return FormatItem::ptr(new C(fmt)); &#125; &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">XX</span>(m, MessageFormatItem),       <span class="comment">// m: 消息</span></span><br><span class="line">        <span class="built_in">XX</span>(p, LevelFormatItem),         <span class="comment">// p: 日志级别</span></span><br><span class="line">        <span class="built_in">XX</span>(c, LoggerNameFormatItem),    <span class="comment">// c: 日志器名称</span></span><br><span class="line">        <span class="built_in">XX</span>(d, DateTimeFormatItem),      <span class="comment">// d: 日期时间</span></span><br><span class="line">        <span class="built_in">XX</span>(r, ElapseFormatItem),        <span class="comment">// r: 累计毫秒数</span></span><br><span class="line">        <span class="built_in">XX</span>(f, FilenameFormatItem),      <span class="comment">// f: 文件名</span></span><br><span class="line">        <span class="built_in">XX</span>(l, LineFormatItem),          <span class="comment">// l: 行号</span></span><br><span class="line">        <span class="built_in">XX</span>(t, ThreadIdFormatItem),      <span class="comment">// t: 线程号</span></span><br><span class="line">        <span class="built_in">XX</span>(F, FiberIdFormatItem),       <span class="comment">// F: 协程号</span></span><br><span class="line">        <span class="built_in">XX</span>(N, ThreadNameFormatItem),    <span class="comment">// N: 线程名称</span></span><br><span class="line">        <span class="built_in">XX</span>(%, PercentSignFormatItem),   <span class="comment">// %: 百分号</span></span><br><span class="line">        <span class="built_in">XX</span>(T, TabFormatItem),           <span class="comment">// T: 制表符</span></span><br><span class="line">        <span class="built_in">XX</span>(n, NewLineFormatItem),       <span class="comment">// n: 换行符</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XX</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; item : vec)&#123;</span><br><span class="line">        <span class="comment">// 常规字符串</span></span><br><span class="line">        <span class="keyword">if</span>(item.first == <span class="number">0</span>)&#123;</span><br><span class="line">            m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">StringFormatItem</span>(item.second)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 模板参数</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 日期时间进行特殊处理，使用dateFormat初始化，其他模板参数使用item.second初始化</span></span><br><span class="line">            <span class="keyword">if</span>(item.second == <span class="string">&quot;d&quot;</span>)&#123;</span><br><span class="line">                m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">DateTimeFormatItem</span>(dateFormat)));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = s_format_items.<span class="built_in">find</span>(item.second);</span><br><span class="line">                <span class="keyword">if</span>(it != s_format_items.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(it-&gt;<span class="built_in">second</span>(item.second)));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 不合法的模板参数，log记录错误信息</span></span><br><span class="line">                    m_items.<span class="built_in">push_back</span>(FormatItem::<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">StringFormatItem</span>(<span class="string">&quot;&lt;&lt;error_format %&quot;</span> + item.second + <span class="string">&quot;&gt;&gt;&quot;</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LogAppender"><a href="#LogAppender" class="headerlink" title="LogAppender"></a>LogAppender</h2><blockquote>
<p>LogAppender用于将一个日志事件输出到对应的输出地</p>
</blockquote>
<p>LogAppender是一个虚类，可以派生出不同的具体实现。不同类型的Appender通过重载log方法来实现往不同的目的地进行输出</p>
<p>基类指定了格式化器（LogFormatter），用户可以自定义格式化器，如果用户没有定义，则使用默认格式化器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志输出地</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogAppender</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;LogAppender&gt;;</span><br><span class="line">    <span class="keyword">using</span> MutexType = SpinLock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LogAppender</span>(LogFormatter::ptr defaultFormatter)</span><br><span class="line">        : <span class="built_in">m_defaultFormatter</span>(defaultFormatter)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">LogAppender</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFormatter</span><span class="params">(LogFormatter::ptr formatter)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LogFormatter::ptr <span class="title">getFormatter</span><span class="params">()</span> <span class="type">const</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// Logger在调用Appender之前已经判断了日志级别，这里不需要再重复判断level</span></span><br><span class="line">    <span class="comment">// LogLevel::Level m_level;</span></span><br><span class="line">    LogFormatter::ptr m_formatter;          <span class="comment">// 自定义formatter</span></span><br><span class="line">    LogFormatter::ptr m_defaultFormatter;   <span class="comment">// 默认formatter</span></span><br><span class="line">    <span class="keyword">mutable</span> MutexType m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="基类的get-set方法"><a href="#基类的get-set方法" class="headerlink" title="基类的get&#x2F;set方法"></a>基类的get&#x2F;set方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LogAppender::setFormatter</span><span class="params">(LogFormatter::ptr formatter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个MutexType的范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;   </span><br><span class="line">    m_formatter = formatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LogFormatter::ptr <span class="title">LogAppender::getFormatter</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个MutexType的范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> m_formatter; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="StdoutLogAppender——输出到终端"><a href="#StdoutLogAppender——输出到终端" class="headerlink" title="StdoutLogAppender——输出到终端"></a>StdoutLogAppender——输出到终端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StdoutLogAppender</span>: <span class="keyword">public</span> LogAppender&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StdoutLogAppender</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;StdoutLogAppender&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">StdoutLogAppender::<span class="built_in">StdoutLogAppender</span>()</span><br><span class="line">    : <span class="built_in">LogAppender</span>(LogFormatter::<span class="built_in">ptr</span>(<span class="keyword">new</span> LogFormatter))&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StdoutLogAppender::log</span><span class="params">(LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_formatter)&#123;</span><br><span class="line">        <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        m_formatter-&gt;format(std::cout, event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MutexType::Lock <span class="built_in">lock</span>(m_mutex);</span><br><span class="line">        m_defaultFormatter-&gt;format(std::cout, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="FileLogAppender——输出到文件"><a href="#FileLogAppender——输出到文件" class="headerlink" title="FileLogAppender——输出到文件"></a>FileLogAppender——输出到文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileLogAppender</span>: <span class="keyword">public</span> LogAppender&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;FileLogAppender&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FileLogAppender</span>(<span class="type">const</span> std::string&amp; filename);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重新打开文件（如果文件是打开状态，则先关闭它再打开）</span></span><br><span class="line">    <span class="comment">// 打开成功返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">reopen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_filename;         <span class="comment">// 输出目的地的文件名</span></span><br><span class="line">    std::ofstream m_filestream;     <span class="comment">// 输出目的地的文件流</span></span><br><span class="line">    <span class="type">uint64_t</span> m_lastTime;            <span class="comment">// 上次打开时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">FileLogAppender::<span class="built_in">FileLogAppender</span>(<span class="type">const</span> std::string&amp; filename)</span><br><span class="line">    : <span class="built_in">LogAppender</span>(LogFormatter::<span class="built_in">ptr</span>(<span class="keyword">new</span> LogFormatter))</span><br><span class="line">    , <span class="built_in">m_filename</span>(filename)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FileLogAppender::log</span><span class="params">(LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定时reopen文件，防止因文件被其他线程删除等原因而log失败</span></span><br><span class="line">    <span class="type">uint64_t</span> now = event-&gt;<span class="built_in">getTime</span>();</span><br><span class="line">    <span class="keyword">if</span>(now &gt;= (m_lastTime + <span class="number">3</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">reopen</span>())&#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;reopen fail, file name=&quot;</span> &lt;&lt; m_filename &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        m_lastTime = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// log</span></span><br><span class="line">    <span class="keyword">if</span>(m_filestream)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_formatter)&#123;</span><br><span class="line">            m_formatter-&gt;format(m_filestream, event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m_defaultFormatter-&gt;format(m_filestream, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h2><blockquote>
<p>Logger负责进行日志输出</p>
</blockquote>
<ul>
<li>Logger的多线程安全：因为log操作的阻塞时间较短，所以使用<strong>自旋锁</strong>来保证多线程安全</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> LogManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> ptr = std::shared_ptr&lt;Logger&gt;;</span><br><span class="line">    <span class="keyword">using</span> MutexType = SpinLock;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(LogEvent::ptr event)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAppender</span><span class="params">(LogAppender::ptr appender)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delAppender</span><span class="params">(LogAppender::ptr appender)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearAppenders</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">LogLevel::Level <span class="title">getLevel</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_level; &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLevel</span><span class="params">(LogLevel::Level level)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 日志器的名称</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="comment">// 日志级别，只有高于该级别的日志事件才会被输出</span></span><br><span class="line">    LogLevel::Level m_level;</span><br><span class="line">    <span class="comment">// 日志输出地的集合</span></span><br><span class="line">    std::list&lt;LogAppender::ptr&gt; m_appenders;</span><br><span class="line">    <span class="comment">// 主日志器，当logger没有定义appender时，其行为与该主日志器一致</span></span><br><span class="line">    Logger::ptr m_root;</span><br><span class="line">    <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">mutable</span> MutexType m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>log接受一个日志事件，先判断该日志事件的级别是否大于本日志器的日志级别。如果日志级别满足条件，则调用appender的log方法将日志事件进行输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(LogEvent::ptr event)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 仅输出大于m_level的日志事件</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;<span class="built_in">getLevel</span>() &gt;= m_level)&#123;</span><br><span class="line">        <span class="comment">// 上范围锁</span></span><br><span class="line">        <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 对所有appender进行log</span></span><br><span class="line">        <span class="keyword">if</span>(!m_appenders.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; appender: m_appenders)&#123;</span><br><span class="line">                appender-&gt;<span class="built_in">log</span>(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m_root) &#123;</span><br><span class="line">            <span class="comment">// 如果没有配置appender，就使用主日志器m_root的appenders进行log</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; appender : m_root-&gt;m_appenders)&#123;</span><br><span class="line">                appender-&gt;<span class="built_in">log</span>(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="appender操作"><a href="#appender操作" class="headerlink" title="appender操作"></a>appender操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::addAppender</span><span class="params">(LogAppender::ptr appender)</span></span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_appenders.<span class="built_in">push_back</span>(appender);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::delAppender</span><span class="params">(LogAppender::ptr appender)</span></span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_appenders.<span class="built_in">begin</span>(); it != m_appenders.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*it == appender)&#123;</span><br><span class="line">            m_appenders.<span class="built_in">erase</span>(it);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::clearAppenders</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    m_appenders.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="toYamlString"><a href="#toYamlString" class="headerlink" title="toYamlString"></a>toYamlString</h3><p>将Logger信息输出为Yaml格式的字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">Logger::toYamlString</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">    node[<span class="string">&quot;name&quot;</span>] = m_name;</span><br><span class="line">    node[<span class="string">&quot;level&quot;</span>] = LogLevel::<span class="built_in">ToString</span>(m_level);</span><br><span class="line">    <span class="comment">// 读取m_appenders，上范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; a : m_appenders)&#123;</span><br><span class="line">        node[<span class="string">&quot;appenders&quot;</span>].<span class="built_in">push_back</span>(YAML::<span class="built_in">Load</span>(a-&gt;<span class="built_in">toYamlString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; node;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LogEventWrap"><a href="#LogEventWrap" class="headerlink" title="LogEventWrap"></a>LogEventWrap</h2><blockquote>
<p>LogEventWrap是一个<strong>RAII类</strong>，它封装了一个Logger和LogEvent，在其析构时调用Logger的log方法提交日志事件</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogEventWrap</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LogEventWrap</span>(Logger::ptr logger, LogEvent::ptr event);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LogEventWrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">LogEvent::ptr <span class="title">getEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_event; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::stringstream&amp; <span class="title">getSS</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Logger::ptr m_logger;</span><br><span class="line">    LogEvent::ptr m_event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"></span><br><span class="line">LogEventWrap::<span class="built_in">LogEventWrap</span>(Logger::ptr logger, LogEvent::ptr event)</span><br><span class="line">    : <span class="built_in">m_logger</span>(logger)</span><br><span class="line">    , <span class="built_in">m_event</span>(event)&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogEventWrap析构时对日志事件进行log</span></span><br><span class="line">LogEventWrap::~<span class="built_in">LogEventWrap</span>()&#123;</span><br><span class="line">    m_logger-&gt;<span class="built_in">log</span>(m_event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::stringstream&amp; <span class="title">LogEventWrap::getSS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_event-&gt;<span class="built_in">getSS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="LogManager"><a href="#LogManager" class="headerlink" title="LogManager"></a>LogManager</h2><blockquote>
<p>LogManager用于统一管理所有的日志器，提供日志器的创建与获取方法</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Logger的管理器，管理主日志器以及所有Logger</span></span><br><span class="line"><span class="comment">// LogManager是创建Logger的唯一方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogManager</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> Singleton&lt;LogManager&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> MutexType = SpinLock;</span><br><span class="line"></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">getLogger</span><span class="params">(std::string loggerName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo: init实现从配置文件中加载日志配置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">getRoot</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_root; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">toYamlString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 单例模式，私有的构造函数</span></span><br><span class="line">    <span class="built_in">LogManager</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 主日志器</span></span><br><span class="line">    Logger::ptr m_root;</span><br><span class="line">    <span class="comment">// 管理包括m_root在内所有日志器的容器</span></span><br><span class="line">    std::map&lt;std::string, Logger::ptr&gt; m_loggers;</span><br><span class="line">    <span class="comment">// Mutex</span></span><br><span class="line">    <span class="keyword">mutable</span> MutexType m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单例模式管理LogManager</span></span><br><span class="line"><span class="keyword">using</span> LoggerMgr = Singleton&lt;LogManager&gt;;</span><br></pre></td></tr></table></figure>


<h3 id="Singleton单例类"><a href="#Singleton单例类" class="headerlink" title="Singleton单例类"></a>Singleton单例类</h3><p>基于单例模式的单例模板类，通过静态函数创建指定类的静态对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> X = <span class="type">void</span>, <span class="type">int</span> N = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Singleton&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> T* <span class="built_in">GetInstance</span>()&#123;</span><br><span class="line">        <span class="type">static</span> T v;</span><br><span class="line">        <span class="keyword">return</span> &amp;v; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>通过类型别名为用户提供创建LogManager单例的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.h</span></span><br><span class="line"><span class="keyword">using</span> LoggerMgr = Singleton&lt;LogManager&gt;;</span><br></pre></td></tr></table></figure>


<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造时默认创建一个root日志器，将日志信息输出到终端</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LogManager::<span class="built_in">LogManager</span>()&#123;</span><br><span class="line">    m_root.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Logger</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">    m_root-&gt;<span class="built_in">addAppender</span>(std::<span class="built_in">make_shared</span>&lt;StdoutLogAppender&gt;());</span><br><span class="line">    m_loggers[m_root-&gt;<span class="built_in">getName</span>()] = m_root;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="getLogger"><a href="#getLogger" class="headerlink" title="getLogger"></a>getLogger</h3><p>getLogger根据日志器名从管理的日志器中返回一个Logger，否则以该名字创建一个Logger</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Logger::ptr <span class="title">LogManager::getLogger</span><span class="params">(std::string loggerName)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 需要读取m_loggers，上范围锁</span></span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = m_loggers.<span class="built_in">find</span>(loggerName);</span><br><span class="line">    <span class="comment">// 找到logger就返回该logger</span></span><br><span class="line">    <span class="keyword">if</span>(it != m_loggers.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则以该名字创建一个logger，其主日志器指向LogManager的主日志器</span></span><br><span class="line">    <span class="function">Logger::ptr <span class="title">newLogger</span><span class="params">(std::make_shared&lt;Logger&gt;(loggerName))</span></span>;</span><br><span class="line">    newLogger-&gt;m_root = m_root;</span><br><span class="line">    m_loggers[loggerName] = newLogger;</span><br><span class="line">    <span class="keyword">return</span> newLogger;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="toYamlString-1"><a href="#toYamlString-1" class="headerlink" title="toYamlString"></a>toYamlString</h3><p>将<code>LoggerManager</code>的信息输出为Yaml格式的字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">LogManager::toYamlString</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Map)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; l : m_loggers)&#123;</span><br><span class="line">        node[<span class="string">&quot;logs&quot;</span>].<span class="built_in">push_back</span>(YAML::<span class="built_in">Load</span>(l.second-&gt;<span class="built_in">toYamlString</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; node;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="实用辅助函数"><a href="#实用辅助函数" class="headerlink" title="实用辅助函数"></a>实用辅助函数</h2><h3 id="使用流式方式写入日志"><a href="#使用流式方式写入日志" class="headerlink" title="使用流式方式写入日志"></a>使用流式方式写入日志</h3><p>使用流式方式将日志级别level的日志写入logger</p>
<p>基于宏函数实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="comment">// 使用流式方式将日志级别level的日志写入logger</span></span><br><span class="line"><span class="comment">// 这里宏函数替换的是代码段，所以不能使用inline替代宏函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_LEVEL(logger, level) \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(logger-&gt;getLevel() &lt;= level) \</span></span><br><span class="line"><span class="meta">        sylar::LogEventWrap(logger, std::make_shared<span class="string">&lt;sylar::LogEvent&gt;</span>(logger-&gt;getName(), level, __FILE__, __LINE__\</span></span><br><span class="line"><span class="meta">                            , 0, sylar::GetThreadId(), sylar::GetFiberId(), time(0), sylar::GetThreadName())).getSS()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_DEBUG(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::DEBUG)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_INFO(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::INFO)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_WARN(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::WARN)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_ERROR(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ERROR)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_FATAL(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::FATAL)</span></span><br></pre></td></tr></table></figure>


<h3 id="使用格式化方式写入日志"><a href="#使用格式化方式写入日志" class="headerlink" title="使用格式化方式写入日志"></a>使用格式化方式写入日志</h3><p>基于inline实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用格式化方式将日志级别level的日志写入logger</span></span><br><span class="line"><span class="comment">// 使用可变参数模板+inline替代宏函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_LEVEL</span><span class="params">(sylar::Logger::ptr logger, sylar::LogLevel::Level level, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(logger-&gt;<span class="built_in">getLevel</span>() &lt;= level)&#123;</span><br><span class="line">        sylar::<span class="built_in">LogEventWrap</span>(logger, std::<span class="built_in">make_shared</span>&lt;sylar::LogEvent&gt;(logger-&gt;<span class="built_in">getName</span>(), level, __FILE__, __LINE__</span><br><span class="line">                            , <span class="number">0</span>, sylar::<span class="built_in">GetThreadId</span>(), <span class="number">42</span>, <span class="built_in">time</span>(<span class="number">0</span>), <span class="string">&quot;Thread&quot;</span>)).<span class="built_in">getEvent</span>()-&gt;format(fmt, args...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_DEBUG</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::DEBUG, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_INFO</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::INFO, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_WARN</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::WARN, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_ERROR</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::ERROR, fmt, args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Arg&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SYLAR_LOG_FMT_FATAL</span><span class="params">(sylar::Logger::ptr logger, <span class="type">const</span> <span class="type">char</span>* fmt, Arg&amp;&amp;... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_LEVEL</span>(logger, sylar::LogLevel::FATAL, fmt, args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="获取日志器"><a href="#获取日志器" class="headerlink" title="获取日志器"></a>获取日志器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取LogManager中的主日志器（root）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_ROOT() sylar::LoggerMgr::GetInstance()-&gt;getRoot()</span></span><br><span class="line"><span class="comment">// 根据名字获取logger</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYLAR_LOG_NAME(name) sylar::LoggerMgr::GetInstance()-&gt;getLogger(name)</span></span><br></pre></td></tr></table></figure>


<h1 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h1><h2 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义输出地与输出格式</span></span><br><span class="line">    sylar::<span class="function">FileLogAppender::ptr <span class="title">file_appender</span><span class="params">(<span class="keyword">new</span> sylar::FileLogAppender(<span class="string">&quot;./log.txt&quot;</span>))</span></span>;</span><br><span class="line">    sylar::<span class="function">LogFormatter::ptr <span class="title">fmt</span><span class="params">(<span class="keyword">new</span> sylar::LogFormatter(<span class="string">&quot;%d%T%p%T%m%n&quot;</span>))</span></span>;</span><br><span class="line">    file_appender-&gt;<span class="built_in">setFormatter</span>(fmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取LogerManager单例</span></span><br><span class="line">    <span class="keyword">auto</span> mgr = sylar::LoggerMgr::<span class="built_in">GetInstance</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根日志器新增appender</span></span><br><span class="line">    mgr-&gt;<span class="built_in">getRoot</span>()-&gt;<span class="built_in">addAppender</span>(file_appender);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据LogManager单例创建Logger</span></span><br><span class="line">    <span class="keyword">auto</span> logger = mgr-&gt;<span class="built_in">getLogger</span>(<span class="string">&quot;Logger01&quot;</span>);</span><br><span class="line">    logger-&gt;<span class="built_in">addAppender</span>(std::<span class="built_in">make_shared</span>&lt;sylar::StdoutLogAppender&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用宏函数流式输出日志信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;LoggerManager&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_ERROR</span>(mgr-&gt;<span class="built_in">getRoot</span>()) &lt;&lt; <span class="string">&quot;test &quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; Error&quot;</span>;</span><br><span class="line">    <span class="built_in">SYLAR_LOG_INFO</span>(logger) &lt;&lt; <span class="string">&quot;test logger01&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实用格式化方式输出日志信息</span></span><br><span class="line">    <span class="built_in">SYLAR_LOG_FMT_DEBUG</span>(mgr-&gt;<span class="built_in">getRoot</span>(), <span class="string">&quot;test %s Debug &lt;%s&gt;&quot;</span>, str.<span class="built_in">c_str</span>(), <span class="string">&quot;using inline and template&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取system日志器</span></span><br><span class="line"><span class="type">static</span> sylar::Logger::ptr g_logger1 = <span class="built_in">SYLAR_LOG_NAME</span>(<span class="string">&quot;system&quot;</span>);</span><br><span class="line"><span class="comment">// 使用system日志器流式打印INFO级别的日志</span></span><br><span class="line"><span class="built_in">SYLAR_LOG_INFO</span>(g_logger1) &lt;&lt; <span class="string">&quot;test logger01&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取root日志器</span></span><br><span class="line"><span class="type">static</span> sylar::Logger::ptr g_logger2 = <span class="built_in">SYLAR_LOG_ROOT</span>();</span><br><span class="line"><span class="comment">// 使用root日志器流式打印INFO级别的日志</span></span><br><span class="line"><span class="built_in">SYLAR_LOG_INFO</span>(g_logger2) &lt;&lt; <span class="string">&quot;test logger02&quot;</span>;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://atelieryu.site">Yu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://atelieryu.site/Sylar%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97">https://atelieryu.site/Sylar%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://atelieryu.site" target="_blank">Yu的炼金工房</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%BF%97%E5%BA%93/">日志库</a><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/">服务器框架</a></div><div class="post-share"><div class="social-share" data-image="https://atelieryu.xyz/elog/202503/a8604dd41597308b4187f82906e13a21.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related  no-desc" href="/RPC" title="C++实现轻量级RPC分布式网络通信框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">C++实现轻量级RPC分布式网络通信框架</div></div></div></a><a class="pagination-related  no-desc" href="/Sylar%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（二）——配置模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/b1738be865fb17e115bb8938b3f4b2ec.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++高性能服务器框架Sylar（二）——配置模块</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/Sylar%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（三）——线程模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/480969dd9045574653c6c6d8bbfa61dc.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-02</div><div class="info-item-2">C++高性能服务器框架Sylar（三）——线程模块</div></div></div></a><a class="pagination-related no-desc" href="/Sylar%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（二）——配置模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/b1738be865fb17e115bb8938b3f4b2ec.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-01</div><div class="info-item-2">C++高性能服务器框架Sylar（二）——配置模块</div></div></div></a><a class="pagination-related no-desc" href="/RPC" title="C++实现轻量级RPC分布式网络通信框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/7f9beb5a969a433c461b87c3ef431ead.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-18</div><div class="info-item-2">C++实现轻量级RPC分布式网络通信框架</div></div></div></a><a class="pagination-related no-desc" href="/Protobuf" title="Protobuf简易使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202503/29adb56737da425f642d3dd22328e4eb.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="info-item-2">Protobuf简易使用</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/PicGo/kurumi.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yu</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/YVollerei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon faa-parent animated-hover" href="https://github.com/YVollerei" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-githublogo"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/7661819" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://steamcommunity.com/profiles/76561198310594699/" target="_blank" title="Steam"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-steam_icon"></use></svg></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">模块概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97UML%E7%B1%BB%E5%9B%BE"><span class="toc-number">2.</span> <span class="toc-text">模块UML类图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Logger%EF%BC%9A%E6%97%A5%E5%BF%97%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">Logger：日志器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogAppender%EF%BC%9A%E6%97%A5%E5%BF%97%E8%BE%93%E5%87%BA%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">LogAppender：日志输出器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogFormatter%EF%BC%9A%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">LogFormatter：日志格式器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogEvent%EF%BC%9A%E6%97%A5%E5%BF%97%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">LogEvent：日志事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogEventWrap%EF%BC%9A%E6%97%A5%E5%BF%97%E4%BA%8B%E4%BB%B6%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">LogEventWrap：日志事件包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogManager%EF%BC%9A%E6%97%A5%E5%BF%97%E5%99%A8%E7%AE%A1%E7%90%86%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">LogManager：日志器管理类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">2.7.</span> <span class="toc-text">调用栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">代码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LogLevel"><span class="toc-number">3.1.</span> <span class="toc-text">LogLevel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogEvent"><span class="toc-number">3.2.</span> <span class="toc-text">LogEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogFormatter"><span class="toc-number">3.3.</span> <span class="toc-text">LogFormatter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pattern"><span class="toc-number">3.3.1.</span> <span class="toc-text">pattern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BBFormatItem"><span class="toc-number">3.3.2.</span> <span class="toc-text">嵌套类FormatItem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#format"><span class="toc-number">3.3.3.</span> <span class="toc-text">format</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#init"><span class="toc-number">3.3.4.</span> <span class="toc-text">init</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogAppender"><span class="toc-number">3.4.</span> <span class="toc-text">LogAppender</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E7%9A%84get-set%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.1.</span> <span class="toc-text">基类的get&#x2F;set方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StdoutLogAppender%E2%80%94%E2%80%94%E8%BE%93%E5%87%BA%E5%88%B0%E7%BB%88%E7%AB%AF"><span class="toc-number">3.4.2.</span> <span class="toc-text">StdoutLogAppender——输出到终端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileLogAppender%E2%80%94%E2%80%94%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">3.4.3.</span> <span class="toc-text">FileLogAppender——输出到文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logger"><span class="toc-number">3.5.</span> <span class="toc-text">Logger</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#log"><span class="toc-number">3.5.1.</span> <span class="toc-text">log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#appender%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.2.</span> <span class="toc-text">appender操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toYamlString"><span class="toc-number">3.5.3.</span> <span class="toc-text">toYamlString</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogEventWrap"><span class="toc-number">3.6.</span> <span class="toc-text">LogEventWrap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogManager"><span class="toc-number">3.7.</span> <span class="toc-text">LogManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Singleton%E5%8D%95%E4%BE%8B%E7%B1%BB"><span class="toc-number">3.7.1.</span> <span class="toc-text">Singleton单例类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getLogger"><span class="toc-number">3.7.3.</span> <span class="toc-text">getLogger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toYamlString-1"><span class="toc-number">3.7.4.</span> <span class="toc-text">toYamlString</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">3.8.</span> <span class="toc-text">实用辅助函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%81%E5%BC%8F%E6%96%B9%E5%BC%8F%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97"><span class="toc-number">3.8.1.</span> <span class="toc-text">使用流式方式写入日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E5%BC%8F%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97"><span class="toc-number">3.8.2.</span> <span class="toc-text">使用格式化方式写入日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%A5%E5%BF%97%E5%99%A8"><span class="toc-number">3.8.3.</span> <span class="toc-text">获取日志器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">模块使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%901"><span class="toc-number">4.1.</span> <span class="toc-text">例子1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%902"><span class="toc-number">4.2.</span> <span class="toc-text">例子2</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Nas-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" title="自建Nas内网穿透——ZeroTier/FRP"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202506/b8b24bcfd6ef35d87082dd5a4a7a0685.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自建Nas内网穿透——ZeroTier/FRP"/></a><div class="content"><a class="title" href="/Nas-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F" title="自建Nas内网穿透——ZeroTier/FRP">自建Nas内网穿透——ZeroTier/FRP</a><time datetime="2025-08-04T11:21:00.000Z" title="发表于 2025-08-04 19:21:00">2025-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%BF%BD%E7%95%AA%E8%AE%B0%E5%BD%95-2025-Spring" title="2025四月番追番记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202507/e1fbc76878de30645319135bb0176c6d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2025四月番追番记录"/></a><div class="content"><a class="title" href="/%E8%BF%BD%E7%95%AA%E8%AE%B0%E5%BD%95-2025-Spring" title="2025四月番追番记录">2025四月番追番记录</a><time datetime="2025-06-29T03:03:00.000Z" title="发表于 2025-06-29 11:03:00">2025-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%9C%BA%E5%A8%98%E5%88%B6%E4%BD%9C-%E6%B3%B3%E8%A3%85%E7%9F%AD%E5%89%91" title="机娘制作记录——FAG 短剑 Swimsuit Ver."><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202506/ac0acafc7727715d80e0c9811c6d4ee0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机娘制作记录——FAG 短剑 Swimsuit Ver."/></a><div class="content"><a class="title" href="/%E6%9C%BA%E5%A8%98%E5%88%B6%E4%BD%9C-%E6%B3%B3%E8%A3%85%E7%9F%AD%E5%89%91" title="机娘制作记录——FAG 短剑 Swimsuit Ver.">机娘制作记录——FAG 短剑 Swimsuit Ver.</a><time datetime="2025-06-22T03:24:00.000Z" title="发表于 2025-06-22 11:24:00">2025-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A5%E9%97%A8%E7%90%86%E8%AE%BA" title="分布式入门——基础理论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202508/72e1b397531a821fbfd91c373d025617.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式入门——基础理论"/></a><div class="content"><a class="title" href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A5%E9%97%A8%E7%90%86%E8%AE%BA" title="分布式入门——基础理论">分布式入门——基础理论</a><time datetime="2025-04-14T08:12:00.000Z" title="发表于 2025-04-14 16:12:00">2025-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Sylar%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（三）——线程模块"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://atelieryu.xyz/elog/202504/480969dd9045574653c6c6d8bbfa61dc.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++高性能服务器框架Sylar（三）——线程模块"/></a><div class="content"><a class="title" href="/Sylar%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97" title="C++高性能服务器框架Sylar（三）——线程模块">C++高性能服务器框架Sylar（三）——线程模块</a><time datetime="2025-04-02T06:40:00.000Z" title="发表于 2025-04-02 14:40:00">2025-04-02</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://atelieryu.xyz/PicGo/footer.jpeg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Yu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.atelieryu.site/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo.atelieryu.site/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://fastly.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script>addEventListener("DOMContentLoaded",function(){let models=[{width:300,height:350,right:"40px",bottom:"0px",role:"/live2d_models/阿米娅/阿米娅(1).model3.json",background:"",opacity:1,mobile:false,draggable:false,scale:0.1},];new Live2dLoader(models)});</script><div class="aplayer no-destroy" data-id="13432525808" data-server="netease" data-type="playlist" data-order="random" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" data-volume="0.25" data-showlrc="false" data-lrc-type="0"></div><script id="canvas_nest" defer="defer" color="106,114,255" opacity="0.7" zIndex="-1" count="100" mobile="false" src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://fastly.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://fastly.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://fastly.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false 
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="会搜出什么呢......" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '3d14be69ac344084881f00a1a2ba6169';
  var gaud_map_key = 'db9c16c529193cc3f1649f61aca0db13';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover1.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACGN/&quot;);" href="javascript:void(0);">ACGN</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover2.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/学习笔记/&quot;);" href="javascript:void(0);">学习笔记</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover3.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/模型制作/&quot;);" href="javascript:void(0);">模型制作</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://atelieryu.xyz/PicGo/cover4.jpeg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/技术随记/&quot;);" href="javascript:void(0);">技术随记</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --></body></html>